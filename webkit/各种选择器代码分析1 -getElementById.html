<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 6.10 (454267)"/><meta name="author" content="管伟"/><meta name="created" content="2016-10-31 06:09:07 +0000"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2016-10-31 08:08:28 +0000"/><title>各种选择器代码分析1 -getElementById</title></head><body><style>
    a { color: #43B0D6 !important; }
    a:visited { color: #7b7ed2 !important; }
    .title-p { font-size:12px; color:gray; }
    .title-hr { margin-bottom: 20px; }
    .tail-hr { margin-top: 20px; }
    .tail-licenses { border:1px dashed lightgray; margin:20px 0 20px 0; padding:20px; font-size:14px; }
</style>
<h2>各种选择器代码分析1 -getElementById</h2>
<p class="title-p">版权声明：自由转载-非商用-非衍生-保持署名(<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">创意共享3.0许可证</a>)</p>
<p class="title-p">文章作者：Pooky (<a href="mailto:guananddu@icloud.com">guananddu@icloud.com</a>)</p>
<hr class="title-hr">
<div>趁热打铁，在分析完毕 DOM 树的构建之后，继续分析一下与选择器相关的部分代码原理，首先来看 getElementById，测试代码是：</div>
<div><br/></div>
<div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;">
<div>&lt;!DOCTYPE html&gt;</div>
<div>&lt;html lang="en"&gt;</div>
<div>&lt;head&gt;</div>
<div>    &lt;meta charset="UTF-8"&gt;</div>
<div>    &lt;title&gt;Document&lt;/title&gt;</div>
<div>    &lt;style&gt;</div>
<div>        .special {</div>
<div>            width: 100px;</div>
<div>            height: 100px;</div>
<div>            background-color: green;</div>
<div>        }</div>
<div>        .container {</div>
<div>            font-size: 20px;</div>
<div>        }</div>
<div>    &lt;/style&gt;</div>
<div>&lt;/head&gt;</div>
<div>&lt;body&gt;</div>
<div>    &lt;div class="special"&gt;&lt;/div&gt;</div>
<div>    &lt;div id="container" class="container"&gt;</div>
<div>        &lt;p&gt;我是一个测试的段落&lt;/p&gt;</div>
<div>    &lt;/div&gt;</div>
<div>    &lt;div id="testquery" class="testquery"&gt;</div>
<div>        这里是测试文字</div>
<div>        &lt;div class="innertestquery"&gt;</div>
<div>            &lt;span&gt;里面的文字&lt;/span&gt;</div>
<div>            &lt;span&gt;里面的文字2&lt;/span&gt;</div>
<div>            &lt;span&gt;里面的文字3&lt;/span&gt;</div>
<div>        &lt;/div&gt;</div>
<div>    &lt;/div&gt;</div>
<div>    &lt;script&gt;</div>
<div>        // test 4 getElementById【此节主要分析此句的底层调用】</div>
<div>        var $container = document.getElementById( 'container' );</div>
<div>        // test 4 queryselector</div>
<div>        var $firstSpan = document.querySelector( '.testquery .innertestquery span' );</div>
<div>        // test 4 all</div>
<div>        var $allSpan = document.querySelectorAll( '#testquery span' );</div>
<div>        // test 4 innerHTML</div>
<div>        var special = document.querySelector( '.special' );</div>
<div>        special.innerHTML = '123';</div>
<div>        special.style.color = 'white';</div>
<div>    &lt;/script&gt;</div>
<div>&lt;/body&gt;</div>
<div>&lt;/html&gt;</div>
</div>
<div><br/></div>
<div>打入适当断点，我们先记录一下现在的深层调用栈：</div>
<div><img src="%E5%90%84%E7%A7%8D%E9%80%89%E6%8B%A9%E5%99%A8%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%901%20-getElementById.resources/FBBCC2B1-98C8-4E6F-8B0D-1BAB5673F52A.png" height="auto" width="100%"/></div>
<div><img src="%E5%90%84%E7%A7%8D%E9%80%89%E6%8B%A9%E5%99%A8%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%901%20-getElementById.resources/34B1C496-856B-4E94-A288-EE1CC1FD3FF7.png" height="auto" width="100%"/></div>
<div><br/></div>
<div>可见从，C++层面调用js的vm虚拟机，又到最终调用回C++中间经历了“汇编阶段”，以现在的能力没法分析，我们直接看调回C++的位置：</div>
<div><br/></div>
<div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;">
<div>#0    0x0000000107a974cf in WebCore::jsDocumentPrototypeFunctionGetElementById(JSC::ExecState*) at /Users/mrguan/work/svn/Webkit/WebKit/WebKitBuild/Debug/DerivedSources/WebCore/JSDocument.cpp:4815</div>
<div>// 首先可以见的：DerivedSources中的代码是在编译阶段生成，具体如何生成不再深究，之前的理解是：这些接口性质的代码，是由人为编写的IDL语言来定义，然后使用工具来生成C++代码。</div>
<div>// js层面的getElementById函数最终调入这里：</div>
<div>
<div>EncodedJSValue JSC_HOST_CALL jsDocumentPrototypeFunctionGetElementById(ExecState* state)</div>
</div>
<div>{</div>
<div>    // 从代码来看，这种接口函数应该都是“静态”函数，所以调用“静态函数”首先要获取各种环境以及上下文</div>
<div>    // 之后分析V8也会有类似的代码</div>
<div>    // state    JSC::ExecState *    0x7fff5fbfad00    0x00007fff5fbfad00</div>
<div>    // thisValue    JSC::JSValue   </div>
<div>    JSValue thisValue = state-&gt;thisValue();</div>
<div>    // castedThis    WebCore::JSDocument *    0x116b0de80    0x0000000116b0de80【获取js中的document在c++世界中的表现】</div>
<div>
<div>    auto castedThis = jsDocumentCast(thisValue);</div>
<div>    if (UNLIKELY(!castedThis))</div>
<div>        return throwThisTypeError(*state, "Document", "getElementById");</div>
</div>
<div>    ASSERT_GC_OBJECT_INHERITS(castedThis, JSDocument::info());</div>
<div>    // impl    WebCore::HTMLDocument &amp;    0x00000001165cf600【解析出HTMLDocument对象】</div>
<div>    auto&amp; impl = castedThis-&gt;wrapped();</div>
<div>    // 以上几步操作在所有的接口函数中都是一样的</div>
<div>    // elementId    WTF::AtomicString   m_string    WTF::String   m_data8    const LChar *    "container”    0x0000000115418974【获取到参数字符串】 </div>
<div>
<div>    auto elementId = AtomicString(state-&gt;argument(0).toString(state)-&gt;toExistingAtomicString(state));</div>
<div>    if (UNLIKELY(state-&gt;hadException()))</div>
</div>
<div>        return JSValue::encode(jsUndefined());</div>
<div>    // 进入 impl 的对应的实现函数</div>
<div>
<div>    JSValue result = toJS(state, castedThis-&gt;globalObject(), WTF::getPtr(impl.getElementById(WTFMove(elementId))));</div>
<div>    return JSValue::encode(result);</div>
</div>
<div>}</div>
<div>---</div>
<div>首先看一下JSC_HOST_CALL 这个宏：</div>
<div>
<div>/* Configure the JIT */</div>
<div>#if CPU(X86) &amp;&amp; COMPILER(MSVC)</div>
<div>#define JSC_HOST_CALL __fastcall</div>
<div>#elif CPU(X86) &amp;&amp; COMPILER(GCC_OR_CLANG)</div>
<div>#define JSC_HOST_CALL __attribute__ ((fastcall))</div>
<div>#else</div>
<div>#define JSC_HOST_CALL</div>
</div>
<div>#endif</div>
<div>// 有关 fastcall 涉及到汇编相关知识点，太他妈底层了，先不深究了：</div>
<div>— <a href="https://gcc.gnu.org/onlinedocs/gcc/x86-Function-Attributes.html">https://gcc.gnu.org/onlinedocs/gcc/x86-Function-Attributes.html</a></div>
<div>---</div>
<div>===</div>
<div>★ 进入 impl.getElementById 函数：</div>
<div>#0    0x0000000108dbf114 in WebCore::TreeScope::getElementById(WTF::AtomicString const&amp;) const at /Users/mrguan/work/svn/Webkit/WebKit/Source/WebCore/dom/TreeScope.cpp:103</div>
<div>
<div>Element* TreeScope::getElementById(const AtomicString&amp; elementId) const</div>
</div>
<div>{</div>
<div>    // this    const WebCore::TreeScope *    0x1165cf658    0x00000001165cf658</div>
<div>
<div>    if (elementId.isNull())</div>
</div>
<div>        return nullptr;</div>
<div>    // m_elementsById    std::__1::unique_ptr&lt;WebCore::DocumentOrderedMap, std::__1::default_delete&lt;WebCore::DocumentOrderedMap&gt; &gt;   </div>
<div>
<div>    if (!m_elementsById)</div>
<div>        return nullptr;</div>
<div>    return m_elementsById-&gt;getElementById(*elementId.impl(), *this);</div>
<div>}</div>
</div>
<div>===</div>
<div>★ 进入 m_elementsById-&gt;getElementById：</div>
<div>#0    0x00000001070c078c in WebCore::DocumentOrderedMap::getElementById(WTF::AtomicStringImpl const&amp;, WebCore::TreeScope const&amp;) const at /Users/mrguan/work/svn/Webkit/WebKit/Source/WebCore/dom/DocumentOrderedMap.cpp:131</div>
<div>
<div>Element* DocumentOrderedMap::getElementById(const AtomicStringImpl&amp; key, const TreeScope&amp; scope) const</div>
</div>
<div>{</div>
<div>    // this    const WebCore::DocumentOrderedMap *    0x115436e10    0x0000000115436e10</div>
<div>    // key    const WTF::AtomicStringImpl &amp;    0x0000000115418960 m_data8    const LChar *    "container"    0x0000000115418974</div>
<div>    // scope    const WebCore::TreeScope &amp;    0x00000001165cf658</div>
<div>
<div>    return get(key, scope, [] (const AtomicStringImpl&amp; key, const Element&amp; element) {</div>
<div>        return element.getIdAttribute().impl() == &amp;key;</div>
<div>    });</div>
<div>}</div>
</div>
<div>===</div>
<div>★ 进入get函数：</div>
<div>#0    0x00000001070c07d3 in WebCore::Element* WebCore::DocumentOrderedMap::get&lt;WebCore::DocumentOrderedMap::getElementById(WTF::AtomicStringImpl const&amp;, WebCore::TreeScope const&amp;) const::$_0&gt;(WTF::AtomicStringImpl const&amp;, WebCore::TreeScope const&amp;, WebCore::DocumentOrderedMap::getElementById(WTF::AtomicStringImpl const&amp;, WebCore::TreeScope const&amp;) const::$_0 const&amp;) const at /Users/mrguan/work/svn/Webkit/WebKit/Source/WebCore/dom/DocumentOrderedMap.cpp:100</div>
<div>
<div>template &lt;typename KeyMatchingFunction&gt;</div>
<div>inline Element* DocumentOrderedMap::get(const AtomicStringImpl&amp; key, const TreeScope&amp; scope, const KeyMatchingFunction&amp; keyMatches) const</div>
<div>{</div>
</div>
<div>    m_map.checkConsistency();</div>
<div>    // this    const WebCore::DocumentOrderedMap *    0x115436e10    0x0000000115436e10</div>
<div>    //      m_map    WebCore::DocumentOrderedMap::Map  </div>
<div>    //           m_impl    WTF::HashMap&lt;const WTF::AtomicStringImpl *, WebCore::DocumentOrderedMap::MapEntry, WTF::PtrHash&lt;const WTF::AtomicStringImpl *&gt;, WTF::HashTraits&lt;const WTF::AtomicStringImpl *&gt;, WTF::HashTraits&lt;WebCore::DocumentOrderedMap::MapEntry&gt; &gt;::HashTableType    </div>
<div>    // 首先直接调用 HashMap 的 find 方法</div>
<div>    // it    WTF::HashTableIteratorAdapter&lt;WTF::HashTable&lt;const WTF::AtomicStringImpl *, WTF::KeyValuePair&lt;const WTF::AtomicStringImpl *, WebCore::DocumentOrderedMap::MapEntry&gt;, WTF::KeyValuePairKeyExtractor&lt;WTF::KeyValuePair&lt;const WTF::AtomicStringImpl *, WebCore::DocumentOrderedMap::MapEntry&gt; &gt;, WTF::PtrHash&lt;const WTF::AtomicStringImpl *&gt;, WTF::HashMap&lt;const WTF::AtomicStringImpl *, WebCore::DocumentOrderedMap::MapEntry, WTF::PtrHash&lt;const WTF::AtomicStringImpl *&gt;, WTF::HashTraits&lt;const WTF::AtomicStringImpl *&gt;, WTF::HashTraits&lt;WebCore::DocumentOrderedMap::MapEntry&gt; &gt;::KeyValuePairTraits, WTF::HashTraits&lt;const WTF::AtomicStringImpl *&gt; &gt;, WTF::KeyValuePair&lt;const WTF::AtomicStringImpl *, WebCore::DocumentOrderedMap::MapEntry&gt; &gt;   </div>
<div>    auto it = m_map.find(&amp;key);</div>
<div>    // 如果没找到则返回空</div>
<div>
<div>    if (it == m_map.end())</div>
</div>
<div>        return nullptr;</div>
<div>    // 获取value</div>
<div>
<div>    MapEntry&amp; entry = it-&gt;value;</div>
</div>
<div>    ASSERT(entry.count);</div>
<div>    // 检查是不是存在element成员</div>
<div>
<div>    if (entry.element) {</div>
<div>        ASSERT_WITH_SECURITY_IMPLICATION(entry.element-&gt;isInTreeScope());</div>
<div>        ASSERT_WITH_SECURITY_IMPLICATION(&amp;entry.element-&gt;treeScope() == &amp;scope);</div>
</div>
<div>        ASSERT_WITH_SECURITY_IMPLICATION(entry.registeredElements.contains(entry.element));</div>
<div>        // 经过一系列检查后，返回其值</div>
<div>        // entry    WebCore::DocumentOrderedMap::MapEntry &amp;    0x00000001209fc5a8</div>
<div>        // element    WebCore::HTMLDivElement *    0x120887f08    0x0000000120887f08【找到对应的】</div>
<div>        // count    unsigned int    1</div>
<div>
<div>        return entry.element;</div>
</div>
<div>    }</div>
<div>    // 如果entry没有element成员，则从treeScope中迭代查找</div>
<div>
<div>    // We know there's at least one node that matches; iterate to find the first one.</div>
<div>    for (auto&amp; element : descendantsOfType&lt;Element&gt;(scope.rootNode())) {</div>
<div>        if (!keyMatches(key, element))</div>
<div>            continue;</div>
<div>        entry.element = &amp;element;</div>
<div>        ASSERT_WITH_SECURITY_IMPLICATION(element.isInTreeScope());</div>
<div>        ASSERT_WITH_SECURITY_IMPLICATION(&amp;element.treeScope() == &amp;scope);</div>
<div>        ASSERT_WITH_SECURITY_IMPLICATION(entry.registeredElements.contains(entry.element));</div>
<div>        return &amp;element;</div>
<div>    }</div>
<div>    ASSERT_NOT_REACHED();</div>
<div>    return nullptr;</div>
<div>}</div>
</div>
<div>===</div>
<div>---</div>
<div>// 看下m_map的定义</div>
<div>
<div>class DocumentOrderedMap {</div>
<div>    WTF_MAKE_FAST_ALLOCATED;</div>
</div>
<div>public:</div>
<div>    ...</div>
<div>    ...</div>
<div>    // 本质上是一个 HashMap</div>
<div>
<div>    typedef HashMap&lt;const AtomicStringImpl*, MapEntry&gt; Map;</div>
<div><br/></div>
<div>    mutable Map m_map;</div>
<div>};</div>
</div>
<div>---</div>
<div>===</div>
</div>
<div><br/></div>
<div>至于 DocumentOrderedMap 的 m_map 是什么时候被“塞”入元素的，应该是在DOM树构建阶段【猜测】，这里不再深究。附加调用堆栈：</div>
<div><img src="%E5%90%84%E7%A7%8D%E9%80%89%E6%8B%A9%E5%99%A8%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%901%20-getElementById.resources/694FB86C-1EE9-432E-8953-31984CA2FCE5.png" height="auto" width="100%"/></div>


<hr class="tail-hr">
<div class="tail-licenses">
<p>版权声明：自由转载-非商用-非衍生-保持署名(<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">创意共享3.0许可证</a>)</p>
<p>文章作者：Pooky (<a href="mailto:guananddu@icloud.com">guananddu@icloud.com</a>)</p>
<p>更新日期：Thu Dec 22 2016 16:38:14 GMT+0800 (CST)</p>
</div></body></html>