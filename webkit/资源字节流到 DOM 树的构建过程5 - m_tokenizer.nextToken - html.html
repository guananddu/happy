<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 6.10 (454267)"/><meta name="author" content="管伟"/><meta name="created" content="2016-10-27 02:49:21 +0000"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2016-12-24 07:36:26 +0000"/><title>资源字节流到 DOM 树的构建过程5 - m_tokenizer.nextToken - html</title></head><body><style>
    a { color: #43B0D6 !important; }
    a:visited { color: #7b7ed2 !important; }
    .title-p { font-size:12px; color:gray; }
    .title-hr { margin-bottom: 20px; }
    .tail-hr { margin-top: 20px; }
    .tail-licenses { border:1px dashed lightgray; margin:20px 0 20px 0; padding:20px; font-size:14px; }
</style>
<h2>资源字节流到 DOM 树的构建过程5 - m_tokenizer.nextToken - html</h2>
<p class="title-p">版权声明：自由转载-非商用-非衍生-保持署名(<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">创意共享3.0许可证</a>)</p>
<p class="title-p">文章作者：Pooky (<a href="mailto:guananddu@icloud.com">guananddu@icloud.com</a>)</p>
<hr class="title-hr"><div>此节继续从函数 WebCore::HTMLDocumentParser::pumpTokenizerLoop 中的循环，开始追寻 token “html” 的构建流程，直走主线，其他的细节在上一节中已有描述。</div><div><br/></div><div>首先看一下此时（处理完上一步的Doctype token）的输入字节流变成了什么样子：</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>(lldb) print m_input.current().toString().show()</div><div>\u000A&lt;html lang="en"&gt;\u000A&lt;head&gt;\u000A    &lt;meta charset="UTF-8"&gt;\u000A    &lt;title&gt;Document&lt;/title&gt;\u000A    &lt;style&gt;\u000A        .special {\u000A            width: 100px;\u000A            height: 100px;\u000A            background-color: green;\u000A        }\u000A        .container {\u000A            font-size: 20px;\u000A        }\u000A    &lt;/style&gt;\u000A&lt;/head&gt;\u000A&lt;body&gt;\u000A    &lt;div class="special"&gt;&lt;/div&gt;\u000A    &lt;div class="container"&gt;\u000A        &lt;p&gt;\u6211\u662F\u4E00\u4E2A\u6D4B\u8BD5\u7684\u6BB5\u843D&lt;/p&gt;\u000A    &lt;/div&gt;\u000A    &lt;script&gt;\u000A        var special = document.querySelector( '.special' );\u000A        special.innerHTML = '123';\u000A        special.style.color = 'white';\u000A    &lt;/script&gt;\u000A&lt;/body&gt;\u000A&lt;/html&gt;\u000A</div><div>// 可以看到，已经处理完的token已经不见了，接下来则要分析如何处理下一个&lt;html lang=“en”&gt; token</div><div>// 需要注意的是，在&lt;html&gt;之前，还有一个\u000A的文本token</div></div><div><br/></div><div>仍旧观察：</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>#0    0x00000001076738af in WebCore::HTMLTokenizer::processToken(WebCore::SegmentedString&amp;) at /Users/mrguan/work/svn/Webkit/WebKit/Source/WebCore/html/parser/HTMLTokenizer.cpp:211</div><div>此处的执行：</div><div><br/></div><div>// this    WebCore::HTMLTokenizer *    0x1165f17c8    0x00000001165f17c8</div><div>//      m_state    WebCore::HTMLTokenizer::State    DataState【初始状态】</div><div>// character    UChar    10</div><div>===</div><div>★ 状态转移顺序：</div><div>BEGIN_STATE(DataState) character    UChar    10【\u000A】</div><div>WebCore::HTMLTokenizer::bufferCharacter  character    UChar    10</div><div>     -&gt; m_token.appendToCharacter(character)</div><div style="margin-left:80px;">inline void HTMLToken::appendToCharacter(UChar character)</div><div style="margin-left:80px;">{</div><div style="margin-left:80px;">    // 默认是 Uninitialized 类型</div><div style="margin-left:80px;">    ASSERT(m_type == Uninitialized || m_type == Character);</div><div style="margin-left:80px;">    m_type = Character; // 标记此token为Character类型</div><div style="margin-left:80px;">    m_data.append(character); // append data</div><div style="margin-left:80px;">    m_data8BitCheck |= character;</div><div style="margin-left:80px;">}</div><div>ADVANCE_TO(DataState)</div><div>BEGIN_STATE(DataState) character    UChar    60(&lt;) || currentState    const State    DataState</div><div>RETURN_IN_CURRENT_STATE(true) // 因为之前设置token的m_type为Character类型，导致进入此宏，直接跳出了 processToken 函数</div><div>===</div><div>宏定义：</div><div><div>#define RETURN_IN_CURRENT_STATE(expression)                     \</div><div>    do {                                                        \</div><div>        m_state = currentState;                                 \</div><div>        return expression;                                      \</div></div><div>    } while (false)</div><div>===</div></div><div><br/></div><div>因为在&lt;html&gt;之前，还有一个\u000A的字符，所以上面的状态转移流程是为此字符token的处理流程，先看调用栈截图：</div><div><br/></div><div><img src="%E8%B5%84%E6%BA%90%E5%AD%97%E8%8A%82%E6%B5%81%E5%88%B0%20DOM%20%E6%A0%91%E7%9A%84%E6%9E%84%E5%BB%BA%E8%BF%87%E7%A8%8B5%20-%20m_tokenizer.nextToken%20-%20html.resources/1119ECF5-D1B1-4FED-9059-512B39D6248B.png" height="auto" width="100%"/><br/></div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>可以确定，在 auto token = m_tokenizer.nextToken(m_input.current()); 运行完毕后，获取到了这样的token：</div><div>token    WebCore::HTMLTokenizer::TokenPtr  </div><div>     m_token    WebCore::HTMLToken *    0x1165f17d0    0x00000001165f17d0</div><div>          m_type    WebCore::HTMLToken::Type    Character【字符类型的Character token】</div><div>          m_data8BitCheck    UChar    10</div><div>===</div><div>★ 此\u000A的处理最终进入上述截图顶部的第一层函数：</div><div>#0    0x0000000107689b6b in WebCore::HTMLTreeBuilder::processCharacterBuffer(WebCore::HTMLTreeBuilder::ExternalCharacterTokenBuffer&amp;) at /Users/mrguan/work/svn/Webkit/WebKit/Source/WebCore/html/parser/HTMLTreeBuilder.cpp:2339</div><div>此函数的处理也是遵循规范：</div><div><a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/tokenization.html#parsing-main-inbody">http://www.whatwg.org/specs/web-apps/current-work/multipage/tokenization.html#parsing-main-inbody</a></div><div>此函数执行的上下文：</div><div>this    WebCore::HTMLTreeBuilder *    0x120adfde0    0x0000000120adfde0</div><div>     m_insertionMode    WebCore::HTMLTreeBuilder::InsertionMode    BeforeHTML</div><div>     m_shouldSkipLeadingNewline    bool    false</div><div>进入switch分支：</div><div>...</div><div><div>    case InsertionMode::BeforeHTML:</div><div>        buffer.skipLeadingWhitespace();</div></div><div>        if (buffer.isEmpty())</div><div>            // 从此处跳出</div><div>            return;</div><div>...</div><div>===</div><div>★ 跳出以后，processToken也跳出了</div><div>自此，\u000A的处理已经完成</div><div>===</div></div><div><br/></div><hr/><div><br/></div><div>html token的真正处理，在处理完\u000A后再看：</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>(lldb) print m_input.current().toString().show()</div><div>&lt;html lang="en"&gt;\u000A&lt;head&gt;\u000A    &lt;meta charset="UTF-8"&gt;\u000A    &lt;title&gt;Document&lt;/title&gt;\u000A    &lt;style&gt;\u000A        .special {\u000A            width: 100px;\u000A            height: 100px;\u000A            background-color: green;\u000A        }\u000A        .container {\u000A            font-size: 20px;\u000A        }\u000A    &lt;/style&gt;\u000A&lt;/head&gt;\u000A&lt;body&gt;\u000A    &lt;div class="special"&gt;&lt;/div&gt;\u000A    &lt;div class="container"&gt;\u000A        &lt;p&gt;\u6211\u662F\u4E00\u4E2A\u6D4B\u8BD5\u7684\u6BB5\u843D&lt;/p&gt;\u000A    &lt;/div&gt;\u000A    &lt;script&gt;\u000A        var special = document.querySelector( '.special' );\u000A        special.innerHTML = '123';\u000A        special.style.color = 'white';\u000A    &lt;/script&gt;\u000A&lt;/body&gt;\u000A&lt;/html&gt;\u000A</div></div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>接着查看：WebCore::HTMLTokenizer::processToken 函数的执行：</div><div>#0    0x00000001076738af in WebCore::HTMLTokenizer::processToken(WebCore::SegmentedString&amp;) at /Users/mrguan/work/svn/Webkit/WebKit/Source/WebCore/html/parser/HTMLTokenizer.cpp:211</div><div><br/></div><div>this    WebCore::HTMLTokenizer *    0x1165f17c8    0x00000001165f17c8</div><div>m_state    WebCore::HTMLTokenizer::State    DataState</div><div>character    UChar    60(&lt;)</div><div>===</div><div>★ 状态迁移顺序：</div><div>BEGIN_STATE(DataState) character    UChar    60</div><div>ADVANCE_TO(TagOpenState)</div><div>BEGIN_STATE(TagOpenState) character    UChar    104(h)</div><div>m_token.beginStartTag(convertASCIIAlphaToLower(character))</div><div>     -&gt;    // 执行代码见下</div><div style="margin-left:80px;">inline void HTMLToken::beginStartTag(UChar character)</div><div style="margin-left:80px;">{</div><div style="margin-left:80px;">    ...</div><div style="margin-left:80px;">    m_type = StartTag; // 设置此时的token类型</div><div style="margin-left:80px;">    m_selfClosing = false; // 自闭合默认为false</div><div style="margin-left:80px;">    m_attributes.clear(); // 见附录2，清空属性列表</div><div style="margin-left:80px;"><br/></div><div style="margin-left:80px;">#if !ASSERT_DISABLED</div><div style="margin-left:80px;">    m_currentAttribute = nullptr;</div><div style="margin-left:80px;">#endif</div><div style="margin-left:80px;"><br/></div><div style="margin-left:80px;">    m_data.append(character);</div><div style="margin-left:80px;">    m_data8BitCheck = character;</div><div style="margin-left:80px;">}</div><div>ADVANCE_TO(TagNameState)</div><div>BEGIN_STATE(TagNameState) character    UChar    116(t)</div><div>m_token.appendToName(toASCIILower(character))</div><div>     -&gt; 往 token 的 m_data中继续append数据</div><div>ADVANCE_TO(TagNameState)</div><div>BEGIN_STATE(TagNameState) character    UChar    109(m)</div><div>m_token.appendToName(toASCIILower(character));</div><div>ADVANCE_TO(TagNameState);</div><div>BEGIN_STATE(TagNameState) character    UChar    108(l)</div><div>m_token.appendToName(toASCIILower(character));</div><div>ADVANCE_TO(TagNameState);</div><div>BEGIN_STATE(TagNameState) character    UChar    32(␚ (SUB))</div><div>ADVANCE_TO(BeforeAttributeNameState)</div><div>BEGIN_STATE(BeforeAttributeNameState) character    UChar    108(l)</div><div>m_token.beginAttribute(source.numberOfCharactersConsumed());</div><div>     -&gt;    // 函数体</div><div style="margin-left:80px;">inline void HTMLToken::beginAttribute(unsigned offset)</div><div style="margin-left:80px;">{</div><div style="margin-left:80px;">    …</div><div style="margin-left:80px;">    // 属性容器空间增加</div><div style="margin-left:80px;">    m_attributes.grow(m_attributes.size() + 1);</div><div style="margin-left:80px;">    // 当前要处理的属性对象指针</div><div style="margin-left:80px;">    m_currentAttribute = &amp;m_attributes.last();</div><div style="margin-left:80px;">    // 设置偏移（相对于原始字节流，未经过截断的）</div><div style="margin-left:80px;">    // startOffset    unsigned int    22</div><div style="margin-left:80px;">    m_currentAttribute-&gt;startOffset = offset;</div><div style="margin-left:80px;">}</div><div>m_token.appendToAttributeName(toASCIILower(character))</div><div>     -&gt;</div><div>inline void HTMLToken::appendToAttributeName(UChar character)</div><div>{</div><div>    ...</div><div>    // 给name append字符</div><div>    m_currentAttribute-&gt;name.append(character);</div><div>}</div><div>ADVANCE_TO(AttributeNameState)</div><div>BEGIN_STATE(AttributeNameState) character    UChar    97(a)</div><div>m_token.appendToAttributeName(toASCIILower(character));</div><div>ADVANCE_TO(AttributeNameState);</div><div>… // 这里直到解析完 lang=“en” 中的 lang 中的 g，都会重复上面的两个过程，直到遇到 = 号</div><div>BEGIN_STATE(AttributeNameState) character    UChar    61(=)</div><div>ADVANCE_TO(BeforeAttributeValueState)</div><div>BEGIN_STATE(BeforeAttributeValueState) character    UChar    34(")</div><div>ADVANCE_TO(AttributeValueDoubleQuotedState)</div><div>BEGIN_STATE(AttributeValueDoubleQuotedState) character    UChar    101（e）</div><div>m_token.appendToAttributeValue(character)</div><div>     -&gt;</div><div style="margin-left:40px;">inline void HTMLToken::appendToAttributeValue(UChar character)</div><div style="margin-left:40px;">{</div><div style="margin-left:40px;">    ...</div><div style="margin-left:40px;">    // 向当前的属性对象值中追加字符</div><div style="margin-left:40px;">    m_currentAttribute-&gt;value.append(character);</div><div style="margin-left:40px;">}</div><div>… // 直至处理完n，等待再次遇到"</div><div>BEGIN_STATE(AttributeValueDoubleQuotedState) character    UChar    34(")</div><div>m_token.endAttribute(source.numberOfCharactersConsumed())</div><div>     -&gt;</div><div style="margin-left:40px;">inline void HTMLToken::endAttribute(unsigned offset)</div><div style="margin-left:40px;">{</div><div style="margin-left:40px;">    ...</div><div style="margin-left:40px;">    // 设置结束的偏移值</div><div style="margin-left:40px;">    m_currentAttribute-&gt;endOffset = offset;</div><div style="margin-left:40px;">#if !ASSERT_DISABLED</div><div style="margin-left:40px;">    // 同时清楚当前的属性操作指针</div><div style="margin-left:40px;">    m_currentAttribute = nullptr;</div><div style="margin-left:40px;">#endif</div><div style="margin-left:40px;">}</div><div>ADVANCE_TO(AfterAttributeValueQuotedState)</div><div>BEGIN_STATE(AfterAttributeValueQuotedState) character    UChar    62(&gt;)</div><div>return emitAndResumeInDataState(source)</div><div>===</div><div>★ 跳出了 auto token = m_tokenizer.nextToken(m_input.current()) 的处理，因为解析到了&lt;html lang=“en"&gt;</div><div>最终调入：</div><div>#0    0x00000001076862dd in WebCore::HTMLTreeBuilder::processStartTag(WebCore::AtomicHTMLToken&amp;) at /Users/mrguan/work/svn/Webkit/WebKit/Source/WebCore/html/parser/HTMLTreeBuilder.cpp:1072</div><div>...</div><div>if (token.name() == htmlTag) {</div><div>      // 走入这里</div><div>      m_tree.insertHTMLHtmlStartTagBeforeHTML(token);</div><div>      // 更新此时的插入模式</div><div>      m_insertionMode = InsertionMode::BeforeHead;</div><div>      return;</div><div>}</div><div>...</div><div>===</div><div>★ WebCore::HTMLConstructionSite::insertHTMLHtmlStartTagBeforeHTML</div><div>#0    0x00000001075410e8 in WebCore::HTMLConstructionSite::insertHTMLHtmlStartTagBeforeHTML(WebCore::AtomicHTMLToken&amp;) at /Users/mrguan/work/svn/Webkit/WebKit/Source/WebCore/html/parser/HTMLConstructionSite.cpp:262</div><div>void HTMLConstructionSite::insertHTMLHtmlStartTagBeforeHTML(AtomicHTMLToken&amp; token)</div><div>{</div><div>    // element    WTF::Ref&lt;WebCore::HTMLHtmlElement&gt;   其继承机构见附录3</div><div>    auto element = HTMLHtmlElement::create(m_document);</div><div>    // 设置元素的属性，并且附带与行内元素的style相关的样式标记？还有属性变化相关的事件？（不作为重点）</div><div>    setAttributes(element, token, m_parserContentPolicy);</div><div>    // m_attachmentRoot    WebCore::HTMLDocument &amp;    0x00000001165c7000【其继承结构见附录4】</div><div>    // 此函数的具体分析见上一节，主要是新建节点插入任务，并且append入队列</div><div>    attachLater(m_attachmentRoot, element.copyRef());</div><div>    // m_openElements    WebCore::HTMLElementStack    </div><div>    m_openElements.pushHTMLHtmlElement(HTMLStackItem::create(element.copyRef(), token));</div><div>    // 待上述入栈以后见数据结构：</div><div>    // m_openElements    WebCore::HTMLElementStack  </div><div>    //     m_rootNode    WebCore::HTMLHtmlElement *    0x120a87340    0x0000000120a87340【根节点】</div><div>    //     m_stackDepth    unsigned int    1【栈深度为1】</div><div>    //     m_headElement    WebCore::Element *    NULL    0x0000000000000000</div><div>    //     m_bodyElement    WebCore::Element *    NULL    0x0000000000000000 </div><div>    // 这里的执行插入任务的过程和上一节几乎一模一样，不再赘述</div><div>    executeQueuedTasks();</div><div>    // 这里处理了一些和manifest相关的标记工作：const AtomicString&amp; manifest = fastGetAttribute(manifestAttr)</div><div><div>    element-&gt;insertedByParser();</div><div>    dispatchDocumentElementAvailableIfNeeded();</div><div>}</div></div><div>===</div><div>★ htmlElement构建完毕</div></div><div><br/></div><hr/><div><br/></div><div>【附录1】</div><div><br/></div><div>对照ASCII码表，10也就是\u000A就是下面这位：</div><div><br/></div><div><img src="%E8%B5%84%E6%BA%90%E5%AD%97%E8%8A%82%E6%B5%81%E5%88%B0%20DOM%20%E6%A0%91%E7%9A%84%E6%9E%84%E5%BB%BA%E8%BF%87%E7%A8%8B5%20-%20m_tokenizer.nextToken%20-%20html.resources/B448C293-8663-4C77-ACB5-0B07ED1AB96E.png" height="auto" width="100%"/><br/></div><div><br/></div><div><img src="%E8%B5%84%E6%BA%90%E5%AD%97%E8%8A%82%E6%B5%81%E5%88%B0%20DOM%20%E6%A0%91%E7%9A%84%E6%9E%84%E5%BB%BA%E8%BF%87%E7%A8%8B5%20-%20m_tokenizer.nextToken%20-%20html.resources/1FD4DA67-032E-427F-8B12-EF965E621D03.png" height="auto" width="100%"/> </div><div><br/></div><div>美其名曰：换行符</div><div><br/></div><div><br/></div><div>【附录2】</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>AttributeList m_attributes;</div><div>typedef Vector&lt;Attribute, 10&gt; AttributeList; // 最多10个属性？</div><div>struct Attribute {</div><div>    Vector&lt;UChar, 32&gt; name;</div><div>    Vector&lt;UChar, 32&gt; value;</div><div><br/></div><div>    // Used by HTMLSourceTracker.</div><div>    unsigned startOffset;</div><div>    unsigned endOffset;</div><div>};</div></div><div><br/></div><div><br/></div><div>【附录3】</div><div><br/></div><div><img src="%E8%B5%84%E6%BA%90%E5%AD%97%E8%8A%82%E6%B5%81%E5%88%B0%20DOM%20%E6%A0%91%E7%9A%84%E6%9E%84%E5%BB%BA%E8%BF%87%E7%A8%8B5%20-%20m_tokenizer.nextToken%20-%20html.resources/B11CB782-5218-4952-A764-B6224238062F.png" height="auto" width="100%"/><br/></div><div><br/></div><div><br/></div><div>【附录4】</div><div><br/></div><div><img src="%E8%B5%84%E6%BA%90%E5%AD%97%E8%8A%82%E6%B5%81%E5%88%B0%20DOM%20%E6%A0%91%E7%9A%84%E6%9E%84%E5%BB%BA%E8%BF%87%E7%A8%8B5%20-%20m_tokenizer.nextToken%20-%20html.resources/B95FC75E-F8D3-4F6C-9F5C-BCB1B6E72EEF.png" height="auto" width="100%"/><br/></div><div><br/></div><div><br/></div>

<hr class="tail-hr">
<div class="tail-licenses">
<p>版权声明：自由转载-非商用-非衍生-保持署名(<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">创意共享3.0许可证</a>)</p>
<p>文章作者：Pooky (<a href="mailto:guananddu@icloud.com">guananddu@icloud.com</a>)</p>
<p>更新日期：Sat Dec 24 2016 16:09:09 GMT+0800 (CST)</p>
</div></body></html>