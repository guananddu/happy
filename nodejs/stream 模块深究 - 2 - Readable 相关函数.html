<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 6.10 (454267)"/><meta name="author" content="管伟"/><meta name="created" content="2017-01-04 09:13:49 +0000"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2017-01-05 08:39:44 +0000"/><title>stream 模块深究 - 2 - Readable 相关函数</title></head><body><style>
    a { color: #43B0D6 !important; }
    a:visited { color: #7b7ed2 !important; }
    .title-p { font-size:12px; color:gray; }
    .title-hr { margin-bottom: 20px; }
    .tail-hr { margin-top: 20px; }
    .tail-licenses { border:1px dashed lightgray; margin:20px 0 20px 0; padding:20px; font-size:14px; }
</style>
<h2>stream 模块深究 - 2 - Readable 相关函数</h2>
<p class="title-p">版权声明：自由转载-非商用-非衍生-保持署名(<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">创意共享3.0许可证</a>)</p>
<p class="title-p">文章作者：Pooky (<a href="mailto:guananddu@icloud.com">guananddu@icloud.com</a>)</p>
<hr class="title-hr"><div>通过官方手册和相关资料，先来回顾一下 Readable Stream 的相关知识点，网上有一些针对 Stream 的学习资料，见：<a href="http://tech.meituan.com/stream-internals.html">http://tech.meituan.com/stream-internals.html</a>，从里面抽取两张 Readable Stream 的运行流程：</div><div><br/></div><div><img src="stream%20%E6%A8%A1%E5%9D%97%E6%B7%B1%E7%A9%B6%20-%202%20-%20Readable%20%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0.resources/0C0C86DB-3088-437B-8068-458B0BD062E0.png" height="auto" width="100%"/><br/></div><div><br/></div><div>关于 read 函数的调用：</div><div><br/></div><div><img src="stream%20%E6%A8%A1%E5%9D%97%E6%B7%B1%E7%A9%B6%20-%202%20-%20Readable%20%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0.resources/01E4AEB7-200D-47AC-B33F-8BE91F5E0BF4.png" height="auto" width="100%"/><br/></div><div><br/></div><div>官方的文档则给出了“两种运行模式／三种内部状态”的阐述（非常重要），见：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">Two Modes#【两种运行模式】</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">Readable streams effectively operate in one of two modes: flowing and paused.</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">When in flowing mode, data is read from the underlying system automatically and provided to an application as quickly as possible using events via the EventEmitter interface.【flowing 模式下，自动读取数据并通过 EventEmitter 触发 data 事件来传递可消费数据资源】</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">In paused mode, the stream.read() method must be called explicitly to read chunks of data from the stream.【而 paused 模式下，则需要明确的调用 read() 函数来获取可消费的数据资源】</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">All Readable streams begin in paused mode but can be switched to flowing mode in one of the following ways:</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">Adding a 'data' event handler.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">Calling the stream.resume() method.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">Calling the stream.pipe() method to send the data to a Writable.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">The Readable can switch back to paused mode using one of the following:</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">If there are no pipe destinations, by calling the stream.pause() method.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">If there are pipe destinations, by removing any 'data' event handlers, and removing all pipe destinations by calling the stream.unpipe() method.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">The important concept to remember is that a Readable will not generate data until a mechanism for either consuming or ignoring that data is provided. If the consuming mechanism is disabled or taken away, the Readable will attempt to stop generating the data.</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">Three States#【三种内部状态】</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">The "two modes" of operation for a Readable stream are a simplified abstraction for the more complicated internal state management that is happening within the Readable stream implementation.【作为 Readable Stream 实现的底层逻辑，则用三种内部状态来为上层的“两种运行模式”提供支持 】</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">Specifically, at any given point in time, every Readable is in one of three possible states:</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">readable._readableState.flowing = null</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">readable._readableState.flowing = false</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">readable._readableState.flowing = true</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">When readable._readableState.flowing is null, no mechanism for consuming the streams data is provided so the stream will not generate its data.【null 说明并没有挂载数据资源消费者】</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">Attaching a listener for the 'data' event, calling the readable.pipe() method, or calling the readable.resume() method will switch readable._readableState.flowing to true, causing the Readable to begin actively emitting events as data is generated.【true 则说明可以持续产生可消费数据】</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">Calling readable.pause(), readable.unpipe(), or receiving "back pressure" will cause the readable._readableState.flowing to be set as false, temporarily halting the flowing of events but not halting the generation of data.【false 代表消费数据仍旧存在于 internal buffer，但是不再触发 data 事件】</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">While readable._readableState.flowing is false, data may be accumulating within the streams internal buffer.【在 false 的状态下，产生的可消费数据被保持在内部的 buffer 中，等待消费】</font><br/></div></div><div><br/></div><div>大体上有个了解以后，从下面的测试代码进入实现流程，来一探究竟：<br/></div><div><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'Menlo';font-size:13.5pt;"><span style="color:#cc7832;font-weight:bold;">const </span>readable = fs.<span style="color:#ffc66d;">createReadStream</span>( filePath<span style="color:#cc7832;">, </span>{<br/>    <span style="color:#9876aa;">highWaterMark</span>: <span style="color:#6897bb;">20000<br/></span>} )<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;"><br/></span>readable.<span style="color:#ffc66d;">on</span>( <span style="color:#6a8759;">'data'</span><span style="color:#cc7832;">, </span>( chunk ) =&gt; {<br/>    <span style="color:#9876aa;">console</span>.<span style="color:#ffc66d;">log</span>( <span style="color:#6a8759;">`readable on data: received </span>${chunk.<span style="color:#9876aa;">length</span>}<span style="color:#6a8759;"> bytes of data.` </span>)<span style="color:#cc7832;">;<br/></span>} )<span style="color:#cc7832;">;</span>
</pre>上面的代码，通过 fs.createReadStream 函数创建了一个可读流，紧接着通过监听 data 事件，进入 on 函数来看看发生了什么：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">// set up data events if they are asked for</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">// Ensure readable listeners eventually get something</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">Readable.prototype.on = function(ev, fn) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  const res = Stream.prototype.on.call(this, ev, fn);</font></div><div><span>  // ev 如果全等 `data`</span><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (ev === 'data') {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    // Start flowing on next tick if stream isn't explicitly paused</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    // 默认新创建的 readstream 的 _readableState.flowing 是 null，因为还没有挂载任何消费机制</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><span>    // 所以下列判断是正确的</span><br/></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    if (this._readableState.flowing !== false)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      this.resume(); // 走入这里</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  } else if (ev === 'readable') {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    . . .</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  }</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  return res;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">};</font><br/></div></div><div><br/></div><div>来看进入 this.resume() ：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">// pause() and resume() are remnants of the legacy readable stream API</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">// If the user uses them, then switch into old mode.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">Readable.prototype.resume = function() {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  var state = this._readableState;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // 如果 state.flowing 不为 null 和 false</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (!state.flowing) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    debug('resume');</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    state.flowing = true; // 切换状态</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    resume(this, state);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  }</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  return this;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">};</font><br/></div></div><div><br/></div><div>走入内部私有函数 resume( this, state )：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">function resume(stream, state) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // 初始化时，<font style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51);">state.resumeScheduled 为 <font style="font-size: 12px; color: rgb(51, 51, 51);">false</font></font></span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (!state.resumeScheduled) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    state.resumeScheduled = true; // 更新状态</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    process.nextTick(resume_, stream, state);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  }</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">}</font><br/></div></div><div><br/></div><div>再来看 process.nextTick 中的 resume_ 函数构成：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">function resume_(stream, state) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // 初始化的 state.reading 为 false</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (!state.reading) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    debug('resume read 0’);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    stream.read(0); // 走入 read 函数</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  }</font></div><div>  // 恢复状态</div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  state.resumeScheduled = false;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  state.awaitDrain = 0;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  stream.emit('resume’); // 触发 resume 事件</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  flow(stream); // flow 函数见下</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (state.flowing &amp;&amp; !state.reading)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    stream.read(0);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">}</font><br/></div></div><div><br/></div><div>flow 函数：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">function flow(stream) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  const state = stream._readableState;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  debug('flow', state.flowing);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // 如果 state.flowing 为 true ，且 stream.read() 的返回值不为空，则持续下去</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  while (state.flowing &amp;&amp; stream.read() !== null);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">}</font><br/></div></div><div><br/></div><div>从 resume 到 process.nextTick 的 resume_ 和 flow ，都少不了 stream 的 read 函数调用，可见，通过监听 data 事件，实现了可读流的“全自动化”，接下来分析 read 函数调用。</div><div><br/></div><div><hr/></div><div><br/></div><div>分析 read 函数，则不需要开启 data 事件监听，因为新建的 Readable Stream 会自动进入 paused 状态，见测试代码：</div><div><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'Menlo';font-size:13.5pt;"><span style="color:#cc7832;font-weight:bold;">const </span>readable = fs.<span style="color:#ffc66d;">createReadStream</span>( filePath<span style="color:#cc7832;">, </span>{<br/>    <span style="color:#9876aa;">highWaterMark</span>: <span style="color:#6897bb;">20000<br/></span>} )<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;"><br/></span>readable.<span style="color:#ffc66d;">on</span>( <span style="color:#6a8759;">'readable'</span><span style="color:#cc7832;">, </span>() =&gt; {<br/>    <span style="color:#cc7832;font-weight:bold;">var </span>chunk<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">    </span><span style="color:#cc7832;font-weight:bold;">while </span>( <span style="color:#cc7832;font-weight:bold;">null </span>!== ( chunk = readable.<span style="color:#ffc66d;">read</span>() ) ) {<br/>        <span style="color:#9876aa;">console</span>.<span style="color:#ffc66d;">log</span>( <span style="color:#6a8759;">`Received </span>${chunk.<span style="color:#9876aa;">length</span>}<span style="color:#6a8759;"> bytes of data.` </span>)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">    </span>}<br/>} )<span style="color:#cc7832;">;</span>
</pre>通过监听 readable 事件，来明确调用 read 函数获取数据，来看下 on 函数如何处理 readable 事件：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">// set up data events if they are asked for</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">// Ensure readable listeners eventually get something</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">Readable.prototype.on = function(ev, fn) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  const res = Stream.prototype.on.call(this, ev, fn);</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (ev === 'data') {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    . . .</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  } else if (ev === 'readable') {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    const state = this._readableState;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    if (!state.endEmitted &amp;&amp; !state.readableListening) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>      // 一些列状态变更</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      state.readableListening = state.needReadable = true;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      state.emittedReadable = false;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      if (!state.reading) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    <span>    // 走入这里，在 nextTick 执行内部函数：nReadingNextTick</span></span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">        process.nextTick(nReadingNextTick, this);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      } else if (state.length) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">        emitReadable(this, state);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      }</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    }</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  }</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  return res;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">};</font><br/></div></div><div><br/></div><div>nReadingNextTick 函数也很简单：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">function nReadingNextTick(self) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  debug('readable nexttick read 0');</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  self.read(0); // 同样是调用了 read() 函数</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">}</font><br/></div></div><div><br/></div><div>由此，当进入 readable 事件回调函数时，已经执行过一次 self.read() 函数调用，Stream 内部的 buffer 已经存有数据。read 函数的调用细节，进入 readable.read() 【不带参数】：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">// you can override either this method, or the async _read(n) below.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">Readable.prototype.read = function(n) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // 需要注意的是，在 readable 事件回调中进入 read() 函数调用之前，已经在 nReadingNextTick 中执行过一遍 self.read(0)</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><span>  // 所以 internal buffer 中，已经有了数据</span><br/></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><span><span> <span> // 下面的断点变量分析基于 readable 回调函数中的 read() 调用阶段</span></span><br/></span></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><span><span><span><span>  // 此时的 n === undefined</span><br/></span></span></span></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  debug('read', n);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  n = parseInt(n, 10); // n =&gt; NaN</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  var state = this._readableState;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  var nOrig = n;</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (n !== 0)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    state.emittedReadable = false;</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // if we're doing read(0) to trigger a readable event, but we</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // already have a bunch of data in the buffer, then just trigger</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // the 'readable' event and move on.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (n === 0 &amp;&amp;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      state.needReadable &amp;&amp;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      (state.length &gt;= state.highWaterMark || state.ended)) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    debug('read: emitReadable', state.length, state.ended);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    if (state.length === 0 &amp;&amp; state.ended)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      endReadable(this); // 满足符合 end 事件的触发</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    else</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      emitReadable(this); // 触发 readable 事件</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    return null;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  }</font></div><div><span>  // n:<font style="font-size: 12px; color: rgb(51, 51, 51);">NaN | state:<font style="font-size: 12px; color: rgb(51, 51, 51);">ReadableState</font></font></span><br/></div><div><span><font style="font-size: 12px; color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // <span>见下分析，返回 <font style="font-size: 12px; color: rgb(51, 51, 51);">20000</font></span></span><br/></font></font></span></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  n = howMuchToRead(n, state);</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // if we've ended, and we're now clear, then finish it up. 检查是不是已经结束</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (n === 0 &amp;&amp; state.ended) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    if (state.length === 0)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      endReadable(this);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    return null;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  }</font></div><div><span>  </span><br/></div><div><span>  // 注意这里的注释</span><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // All the actual chunk generation logic needs to be</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // *below* the call to _read.  The reason is that in certain</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // synthetic stream cases, such as passthrough streams, _read</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // may be a completely synchronous operation which may change</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // the state of the read buffer, providing enough data when</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // before there was *not* enough.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  //</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // So, the steps are:</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // 1. Figure out what the state of things will be after we do</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // a read from the buffer.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  //</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // 2. If that resulting state will trigger a _read, then call _read.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // Note that this may be asynchronous, or synchronous.  Yes, it is</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // deeply ugly to write APIs this way, but that still doesn't mean</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // that the Readable class should behave improperly, as streams are</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // designed to be sync/async agnostic.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // Take note if the _read call is sync or async (ie, if the read call</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // has returned yet), so that we know whether or not it's safe to emit</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // 'readable’ etc.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  //</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // 3. Actually pull the requested chunks out of the buffer and return.</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // if we need a readable event, then we need to do some reading.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  var doRead = state.needReadable;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  debug('need readable', doRead);</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // if we currently have less than the highWaterMark, then also read some</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // 如注释所说</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (state.length === 0 || state.length - n &lt; state.highWaterMark) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    doRead = true;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    debug('length less than watermark', doRead);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  }</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // however, if we've ended, then there's no point, and if we're already</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // reading, then it's unnecessary.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (state.ended || state.reading) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    doRead = false;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    debug('reading or ended', doRead);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  } else if (doRead) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    // 走入此分支</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    debug('do read');</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    state.reading = true; // read 进行中的标识</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    state.sync = true;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    // 🌟注意若此时的 state.length === 0 则需要触发一个 readable 事件</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    // if the length is currently zero, then we *need* a readable event.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    // state.length === 20000</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    if (state.length === 0)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      state.needReadable = true;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    // call internal read method 🌟🌟🌟掉入真正的实现层 _read 函数</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    // 因为此节采用 fs 模块的 createReadStream 来做实验，具体见下分析</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    this._read(state.highWaterMark); // 开始读取数据【默认异步】</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    // 实现层次的 this._read 默认是个异步函数</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    state.sync = false; // 默认异步</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    // If _read pushed data synchronously, then `reading` will be false,</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    // and we need to re-evaluate how much data we can return to the user.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    if (!state.reading) // 如果是同步</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      n = howMuchToRead(nOrig, state);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  }</font></div><div><span>  // 按照常规的异步实现，在使用 fs.read 的底层线程池读取文件数据的时候，主线程的逻辑继续往下执行</span><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  var ret;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (n &gt; 0)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    // 进入 fromList 函数，见下分析</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><span>    // 最终拿到上一次调用 read( 0 ) 时读取的数据</span><br/></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    ret = fromList(n, state);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  else</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    ret = null;</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (ret === null) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    state.needReadable = true;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    n = 0;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  } else {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    // 执行完 fromList 后，已经拿到结果，state.length 减去 n 的大小</span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><span>    // 因为 n 的大小的数据资源已经“准备拿去消费”。。。</span><br/></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><span><span>    // state.length 记录所有可消费的数据资源总长</span><br/></span></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    state.length -= n;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  }</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (state.length === 0) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    // If we have nothing in the buffer, then we want to know</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    // as soon as we *do* get something into the buffer.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    if (!state.ended)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      state.needReadable = true;</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    // If we tried to read() past the EOF, then emit end on the next tick.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    if (nOrig !== n &amp;&amp; state.ended)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      endReadable(this);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  }</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (ret !== null)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    // 终于触发了 data 事件，把第一次的 read( 0 ) 拿到的数据返回</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    this.emit('data', ret);</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  return ret;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">};</font><br/></div></div><div><br/></div><div>关于 howMuchToRead( n, state ) 函数调用：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">// This function is designed to be inlinable, so please take care when making</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">// changes to the function body.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">function howMuchToRead(n, state) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // n:<font style="font-size: 12px; color: rgb(51, 51, 51);">NaN</font></span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (n &lt;= 0 || (state.length === 0 &amp;&amp; state.ended)) // 如果达到 end 阶段</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    return 0;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (state.objectMode) // 如果是 objectMode</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    return 1; // 直接返回 1</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // 如果调用是 read() 即 n 为 NaN</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (n !== n) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    // Only flow one buffer at a time</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    // 如果 Readable Stream 是 flowing 状态</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><span>    // 上述测试代码示例为 paused 状态【因为并没有绑定 data 事件】</span><br/></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><span><span>    // 且 internal buffer 若没有数据则 state.length == 0</span><br/></span></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><span><span><span>    // 但是！此次断点调试，已经经过一次 read( 0 )，才能进入 readable 的回调函数，所以 state.length 已经有值</span><br/></span></span></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><span><span><span><span>    // 此时！state.length == 20000( highWaterMark == 20000 )</span><br/></span></span></span></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><span><span><span><span><span>    // 且！state.buffer( <font style="font-size: 12px; color: rgb(51, 51, 51);">BufferList</font> ) =&gt; head( data:<font style="font-size: 12px; color: rgb(51, 51, 51);">Uint8Array[20000];next:<font style="font-size: 12px; color: rgb(51, 51, 51);">null</font></font> ) 已有元素</span><br/></span></span></span></span></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    if (state.flowing &amp;&amp; state.length)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      return state.buffer.head.data.length;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    else</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    <span>  // 所以此次，直接返回目前 buffer 中已有的数据长度</span></span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      return state.length; // <font style="font-size: 12px; color: rgb(51, 51, 51);">20000 （为第一次调用 read( 0 ) 时的结果）</font></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  }</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  . . .</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">}</font><br/></div></div><div><br/></div><div>关于 fs.createReadStream 中的 ReadStream.prototype._read 底层函数实现：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">ReadStream.prototype._read = function(n) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  . . .</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // n === 20000</span><br/></font></div><div><span>  // 这里的 pool 作为数据缓存池，因为已经调用过一次 read( 0 )，故 pool 中已有数据</span><br/></div><div><span><span>  // pool( <font style="font-size: 12px; color: rgb(51, 51, 51);">Uint8Array[20000], pool.length:<font style="font-size: 12px; color: rgb(51, 51, 51);">20000, pool.used:<font style="font-size: 12px; color: rgb(51, 51, 51);">20000</font></font></font> )</span><br/></span></div><div><span><span><span>  // <font style="font-size: 12px; color: rgb(51, 51, 51);">const kMinPoolSpace = 128; 2^8／2</font></span><br/></span></span></div><div><span><span><span><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // 若 pool 剩余空间不足，则重新开辟空间</span><br/></font></span></span></span></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (!pool || pool.length - pool.used &lt; kMinPoolSpace) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    // discard the old pool.【抛弃旧数据】</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    pool = null;</font></div><div><span>    // 此函数的两部操作：</span><br/></div><div><span><span>    //<font style="font-size: 12px; color: rgb(51, 51, 51);">  pool = Buffer.allocUnsafe(poolSize); // Buffer 的知识点请查看相关章节</font></span></span></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  <span>  //  </span>pool.used = 0;</font><span><span/><br/></span></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    allocNewPool(this._readableState.highWaterMark);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  }</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // Grab another reference to the pool in the case that while we're</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // in the thread pool another read() finishes up the pool, and</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // allocates a new one.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  var thisPool = pool;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // 算出本次需要读取多少数据 <font style="font-size: 12px; color: rgb(51, 51, 51);">20000</font></span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  var toRead = Math.min(pool.length - pool.used, n);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  var start = pool.used; // 0</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (this.pos !== undefined)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    toRead = Math.min(this.end - this.pos + 1, toRead);</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // already read everything we were supposed to read!</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // treat as EOF.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (toRead &lt;= 0)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    return this.push(null); // 结束的标识</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // the actual read.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  var self = this;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // 🌟🌟🌟 真正开始读取文件数据</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><span>  // 函数说明（按顺序）：</span><br/></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // Read data from the file specified by fd.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // buffer is the buffer that the data will be written to.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // offset is the offset in the buffer to start writing at.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // length is an integer specifying the number of bytes to read.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // position is an integer specifying where to begin reading from in the file. If position is null, data will be read from the current file position.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // The callback is given the three arguments, (err, bytesRead, buffer).</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  fs.read(this.fd, pool, pool.used, toRead, this.pos, onread);</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // move the pool positions, and internal position for reading.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (this.pos !== undefined)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    this.pos += toRead;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  pool.used += toRead; // 自加</font></div><div><span>  // fs.read 的回调</span><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  function onread(er, bytesRead) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    if (er) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      if (self.autoClose) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">        self.destroy();</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      }</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      self.emit('error', er);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    } else {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      var b = null;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      if (bytesRead &gt; 0) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    <span>    // bytesRead 代表此次读取的字节数</span></span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    <span>    // self.bytesRead 代表总共读取的字节数</span></span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">        self.bytesRead += bytesRead;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    <span>    // 返回此次的 buffer</span></span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><span><span>    <span>    // <font style="font-size: 12px; color: rgb(51, 51, 51);">Returns a new Buffer that references the same memory as the original, but offset and cropped by the start and end indices.</font></span></span></span></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    <span>    // </span></span>Note that modifying the new Buffer slice will modify the memory in the original Buffer because the allocated memory of the two objects overlap.</font><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><span><span><span/></span><br/></span></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">        b = thisPool.slice(start, start + bytesRead);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      }</font></div><div><span>    <span>  // 最终调用 readable.push 函数【之后分析】</span></span><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      self.push(b);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    }</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  }</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">};</font><br/></div></div><div><br/></div><div>关于 fromList 是如何制造最终的结果的：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">function fromList(n, state) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // nothing buffered</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (state.length === 0)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    return null; // 没有 buffered 则直接返回 null</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  var ret;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (state.objectMode)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    // BufferList.prototype.shift // head.data 弹栈</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    ret = state.buffer.shift(); // 注意这里</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  else if (!n || n &gt;= state.length) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    // 走入此分支【第二次 read()】</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    // 读取所有数据的情况</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    // read it all, truncate the list</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    if (state.decoder) // null</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    <span>  // <font style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51);">BufferList.prototype.join</font></span></span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><span><font style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51);"><span>    <span>  // 根据代码可知，此函数是将所有元素的 data( Buffer ) 调用 toString() 即 变成 \uxxxx 编码连结输出</span></span><br/></font></span></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      ret = state.buffer.join(‘’);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    else if (state.buffer.length === 1)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    <span>  // 第二次 read() 走入这里，直接返回第一个元素的 data( Buffer  )</span></span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      ret = state.buffer.head.data;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    else</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    <span>  // BufferList.prototype.concat 新建一个 Buffer 并且把剩余的 BufferList 中的所有元素 copy 至新 Buffer 中</span></span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      ret = state.buffer.concat(state.length);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    // BufferList.prototype.clear 函数体见下，清除链表</span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><span><font style="font-size: 12px; color: rgb(51, 51, 51);">    // BufferList.prototype.clear = function() {</font></span></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  <span>  </span>//<span>    </span>this.head = this.tail = null;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    //    this.length = 0;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    // };</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    state.buffer.clear();</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  } else {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    // 获取部分数据</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    // read part of list</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    ret = fromListPartial(n, state.buffer, state.decoder);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  }</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  return ret;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">}</font><br/></div></div><div><br/></div><div><hr/></div><div><br/></div><div>记录执行点：</div><div><br/></div><div>readable.on( ‘readable’, xxx ) 在第一次执行时，通过 nextTick 回调，触发一次 read(0) 操作：</div><div><br/></div><div>🌟1⃣️第一次的 read(0)，标记 state.needReadable 为 true，且因为 readable 的 state.reading 为 false，故进入 readable._read 的底层调用开始真正获取文件数据（异步），同时标记 state.reading 为 true。readable._read 函数通过更底层的 fs.read 函数来异步获取文件数据，并最终在某时刻通过其内部回调函数最终调用 readable.push(chunk) 函数，将数据从底层推送至上层，并且将 readable.reading 置为 false，更新 state.length(可消费数据总长)，如果 state.needReadable 为 true 则继续触发 `readable` 事件，等待下次继续调用 read()；</div><div><br/></div><div>🌟2⃣️第一次执行完毕 read(0) 之后，总会有数据被 push 入 internal buffer，此时就可以触发 `readable` 事件了，于是乎，就进入了本节的分析；</div><div><br/></div><div>🌟3⃣️第一次进入 readable 事件回调，说明已经有了可消费数据，于是再次手动调用 readable.read() 函数来获取数据，最终通过本节分析的一系列调用，在第一次的 while 循环判断中，获取到第一次 read(0) 所得到的数据，并最终触发 `data` 事件，并且返回结果，与此同时，此过程还调用了底层的 readable._read 函数来获取后续数据；</div><div><br/></div><div>🌟4⃣️第二次进入 3 中的 while 循环判断，继续执行 read() 函数，此时因为 3 中的 readble._read 函数在获取后续数据时还没有完成，internal buffer 中仍旧为空，所以此一步骤，read() 函数将得到 null 的结果，最终 while 循环跳出，只能等待下一次的 `readable` 事件被触发；</div><div><br/></div><div>🌟5⃣️第二次进入 readable 事件回调，说明有第二批数据到达，会再次重复 1，2，3，4 步骤，不再赘述；</div><div><br/></div><div>🌟6⃣️第三次进入 readable 事件回调，说明有第三批数据到达，会再次重复 1，2，3，4 步骤，不再赘述；</div><div><br/></div><div>🌟7⃣️其实第三次执行 readable 回调，获取到的数据已经是最后的数据；仍旧会有第四次执行 readable 回调，但是此时的 read() 已经获取不到任何数据，同时 read 内会把 state.ended 标记为 true 以结束执行，如下代码：</div><div><br/></div><div>From Readable.read:</div><div><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'Menlo';font-size:13.5pt;"><span style="color:#808080;">// if we've ended, and we're now clear, then finish it up.<br/></span><span style="color:#cc7832;font-weight:bold;">if </span>(n === <span style="color:#6897bb;">0 </span>&amp;&amp; state.ended) {<br/>  <span style="color:#cc7832;font-weight:bold;">if </span>(state.length === <span style="color:#6897bb;">0</span>)<br/>    endReadable(<span style="color:#cc7832;font-weight:bold;">this</span>)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">  </span><span style="color:#cc7832;font-weight:bold;">return null</span><span style="color:#cc7832;">;<br/></span>}
</pre></div><div>Then 看看最终如何结束，及其如何触发 end 事件：</div><div><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'Menlo';font-size:13.5pt;"><span style="color:#cc7832;font-weight:bold;">function </span>endReadable(stream) {<br/>  <span style="color:#cc7832;font-weight:bold;">var </span>state = stream._readableState<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;"><br/></span><span style="color:#cc7832;">  </span><span style="color:#808080;">// If we get here before consuming all the bytes, then that is a<br/></span><span style="color:#808080;">  // bug in node.  Should never happen.<br/></span><span style="color:#808080;">  </span><span style="color:#cc7832;font-weight:bold;">if </span>(state.length &gt; <span style="color:#6897bb;">0</span>)<br/>    <span style="color:#cc7832;background-color:#344134;font-weight:bold;">throw new </span><span style="background-color:#344134;">Error(</span><span style="color:#6a8759;background-color:#344134;">'"endReadable()" called on non-empty stream'</span><span style="background-color:#344134;">)</span><span style="color:#cc7832;background-color:#344134;">;</span><span style="color:#cc7832;"><br/></span><span style="color:#cc7832;"><br/></span><span style="color:#cc7832;">  </span><span style="color:#cc7832;font-weight:bold;">if </span>(!state.endEmitted) {<br/>    state.ended = <span style="color:#cc7832;font-weight:bold;">true</span><span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">    </span>process.nextTick(endReadableNT<span style="color:#cc7832;">, </span>state<span style="color:#cc7832;">, </span>stream)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">  </span>}<br/><span style="background-color:#344134;">}</span><br/><br/><span style="color:#cc7832;font-weight:bold;">function </span>endReadableNT(state<span style="color:#cc7832;">, </span>stream) {<br/>  <span style="color:#808080;">// Check that we didn't get one last unshift.<br/></span><span style="color:#808080;">  </span><span style="color:#cc7832;font-weight:bold;">if </span>(!state.endEmitted &amp;&amp; state.length === <span style="color:#6897bb;">0</span>) {<br/>    state.endEmitted = <span style="color:#cc7832;font-weight:bold;">true</span><span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">    </span>stream.readable = <span style="color:#cc7832;font-weight:bold;">false</span><span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">    </span>stream.emit(<span style="color:#6a8759;">'end'</span>)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">  </span>}<br/>}
</pre>如上代码，最终在 process.nextTick 中调用 endReadableNT 函数来结束最后的 Readable Stream 执行。</div><div><br/></div><div>具体关于，fs.createReadStream 中 readable.push 的细节点，见下节分析。</div><div><br/></div>

<hr class="tail-hr">
<div class="tail-licenses">
<p>版权声明：自由转载-非商用-非衍生-保持署名(<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">创意共享3.0许可证</a>)</p>
<p>文章作者：Pooky (<a href="mailto:guananddu@icloud.com">guananddu@icloud.com</a>)</p>
<p>更新日期：Fri Jan 06 2017 00:16:11 GMT+0800 (CST)</p>
</div></body></html>