<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 6.10 (454267)"/><meta name="altitude" content="44.12213516235352"/><meta name="author" content="管伟"/><meta name="created" content="2017-01-11 06:14:25 +0000"/><meta name="latitude" content="40.07903397992509"/><meta name="longitude" content="116.3269689362817"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2017-01-11 09:25:57 +0000"/><title>stream 模块深究 - 8 - pipe 函数</title></head><body><style>
    a { color: #43B0D6 !important; }
    a:visited { color: #7b7ed2 !important; }
    .title-p { font-size:12px; color:gray; }
    .title-hr { margin-bottom: 20px; }
    .tail-hr { margin-top: 20px; }
    .tail-licenses { border:1px dashed lightgray; margin:20px 0 20px 0; padding:20px; font-size:14px; }
</style>
<h2>stream 模块深究 - 8 - pipe 函数</h2>
<p class="title-p">版权声明：自由转载-非商用-非衍生-保持署名(<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">创意共享3.0许可证</a>)</p>
<p class="title-p">文章作者：Pooky (<a href="mailto:guananddu@icloud.com">guananddu@icloud.com</a>)</p>
<hr class="title-hr"><div>本节分析 stream 中 stream.Readable 的 pipe 函数，来看测试代码，同样为了监听到所有的事件回调，修改 Stream.prototype.on 函数，看代码：</div><div><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'Menlo';font-size:13.5pt;"><span style="color:#cc7832;font-weight:bold;">const </span>fs = require( <span style="color:#6a8759;">'fs' </span>)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;font-weight:bold;">const </span>path = require( <span style="color:#6a8759;">'path' </span>)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;font-weight:bold;">const </span>stream = require( <span style="color:#6a8759;">'stream' </span>)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;"><br/></span><span style="color:#cc7832;font-weight:bold;">const </span>filePath = path.<span style="color:#ffc66d;">resolve</span>( __dirname<span style="color:#cc7832;">, </span><span style="color:#6a8759;">'bigfile.txt' </span>)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;font-weight:bold;">const </span>outFilePath = path.<span style="color:#ffc66d;">resolve</span>( __dirname<span style="color:#cc7832;">, </span><span style="color:#6a8759;">'output.bigfile.txt' </span>)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;"><br/></span><span style="color:#808080;">// 为了在所有的事件处理器回调函数中断住<br/></span><span style="color:#cc7832;font-weight:bold;">const </span>Stream = stream.<span style="color:#9876aa;">Stream</span><span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;"><br/></span><span style="color:#cc7832;font-weight:bold;">let </span>onOld = Stream.<span style="color:#9876aa;">prototype</span>.<span style="color:#ffc66d;">on</span><span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;"><br/></span>Stream.<span style="color:#9876aa;">prototype</span>.<span style="color:#ffc66d;">on </span>= <span style="color:#cc7832;font-weight:bold;">function </span>( ev<span style="color:#cc7832;">, </span>fn ) {<br/>    <span style="color:#cc7832;font-weight:bold;">var </span>that = <span style="color:#cc7832;font-weight:bold;">this</span><span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">    </span><span style="color:#cc7832;font-weight:bold;">var </span><span style="color:#ffc66d;">innerFn </span>= <span style="color:#cc7832;font-weight:bold;">function </span>() {<br/>        <span style="color:#808080;">// debugger;<br/></span><span style="color:#808080;">        </span>fn.<span style="color:#ffc66d;">apply</span>( that<span style="color:#cc7832;">, </span>arguments )<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">    </span>}<br/>    onOld.<span style="color:#ffc66d;">call</span>( that<span style="color:#cc7832;">, </span>ev<span style="color:#cc7832;">, </span><span style="color:#ffc66d;">innerFn </span>)<span style="color:#cc7832;">;<br/></span>}<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;"><br/></span><span style="color:#cc7832;font-weight:bold;">const </span>readable = fs.<span style="color:#ffc66d;">createReadStream</span>( filePath )<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;font-weight:bold;">const </span>writable = fs.<span style="color:#ffc66d;">createWriteStream</span>( outFilePath )<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;"><br/></span>readable.<span style="color:#ffc66d;">pipe</span>( writable )<span style="color:#cc7832;">;</span>
</pre></div><div>如上代码，最终走入 readable.pipe( writable ) 调用：</div><div><br/></div><div/><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">Readable.prototype.pipe = function(dest, pipeOpts) {</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  var src = this;</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // 获取 readableState</span><br/></font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  var state = this._readableState;</font></div><div style="color: rgb(51, 51, 51);"><span>  // 默认 state.pipesCount === 0 ，代表被“attach”的输出流个数</span><br/></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  switch (state.pipesCount) {</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">    case 0: // 代表第一个被 attach 的输出流</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">      state.pipes = dest; // 直接赋予 state.pipes 变量</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">      break;</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">    . . . // 多于一个，则按照数组来组织</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  }</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  state.pipesCount += 1; // 递增</font></div><div style="color: rgb(51, 51, 51);"><span>  . . .</span><br/></div><div style="color: rgb(51, 51, 51);"><span><span>  // 判断是不是要处理 end 事件</span><br/></span></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  var doEnd = (!pipeOpts || pipeOpts.end !== false) &amp;&amp;</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">              dest !== process.stdout &amp;&amp;</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">              dest !== process.stderr;</font></div><div style="color: rgb(51, 51, 51);"><span>  // 两个 end 函数</span><br/></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  var endFn = doEnd ? onend : cleanup;</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (state.endEmitted)</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">    process.nextTick(endFn);</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  else</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    // 绑定一个一次性 readable end 事件处理器</span><br/></font></div><div><font style="color: rgb(51, 51, 51); font-size: 12px;">    src.once('</font><font style="font-size: 12px;" color="#ff2600">end</font><font style="color: rgb(51, 51, 51); font-size: 12px;">', endFn);</font></div><div><font style="color: rgb(51, 51, 51); font-size: 12px;"><br/></font></div><div style="color: rgb(51, 51, 51);"><span>  // writable unpipe 事件处理器</span><br/></div><div><font style="color: rgb(51, 51, 51); font-size: 12px;">  dest.on('</font><font style="font-size: 12px;" color="#0433ff">unpipe</font><font style="color: rgb(51, 51, 51); font-size: 12px;">', onunpipe);</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  function onunpipe(readable) {</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">    . . .</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  }</font></div><div style="color: rgb(51, 51, 51);"><br/></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  function onend() {</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">    debug('onend');</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">    dest.end();</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  }</font></div><div style="color: rgb(51, 51, 51);"><br/></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  // when the dest drains, it reduces the awaitDrain counter</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  // on the source.  This would be more elegant with a .once()</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  // handler in flow(), but adding and removing repeatedly is</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  // too slow.</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // writable drain 事件处理器</span><br/></font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  var ondrain = pipeOnDrain(src);</font></div><div><font style="color: rgb(51, 51, 51); font-size: 12px;">  dest.on('</font><font style="font-size: 12px;" color="#0433ff">drain</font><font style="color: rgb(51, 51, 51); font-size: 12px;">', ondrain);</font></div><div style="color: rgb(51, 51, 51);"><br/></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  var cleanedUp = false;</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  function cleanup() {</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">    . . .</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  }</font></div><div style="color: rgb(51, 51, 51);"><br/></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  // If the user pushes more data while we're writing to dest then we'll end up</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  // in ondata again. However, we only want to increase awaitDrain once because</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  // dest will only emit one 'drain' event for the multiple writes.</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  // =&gt; Introduce a guard on increasing awaitDrain.</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  var increasedAwaitDrain = false;</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // readable data 事件绑定【readable 同时开始 flow 模式】</span><br/></font></div><div><font style="color: rgb(51, 51, 51); font-size: 12px;">  src.on('</font><font style="font-size: 12px;" color="#ff2600">data</font><font style="color: rgb(51, 51, 51); font-size: 12px;">', ondata);</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  function ondata(chunk) {</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">    . . .</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  }</font></div><div style="color: rgb(51, 51, 51);"><br/></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  // if the dest has an error, then stop piping into it.</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  // however, don't suppress the throwing behavior for this.</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  function onerror(er) {</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">    . . .</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  }</font></div><div style="color: rgb(51, 51, 51);"><br/></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  // Make sure our error handler is attached before userland ones.</font></div><div><font style="color: rgb(51, 51, 51); font-size: 12px;">  prependListener(dest, '</font><font style="font-size: 12px;" color="#0433ff">error</font><font style="color: rgb(51, 51, 51); font-size: 12px;">', onerror); // 只是确保 onerror 函数作为 error 事件监听器列表的第一个处理器函数</font></div><div style="color: rgb(51, 51, 51);"><br/></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  // Both close and finish should trigger unpipe, but only once.</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  function onclose() {</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">    . . .</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  }</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // close 事件处理器</span><br/></font></div><div><font style="color: rgb(51, 51, 51); font-size: 12px;">  dest.once('</font><font style="font-size: 12px;" color="#0433ff">close</font><font style="color: rgb(51, 51, 51); font-size: 12px;">', onclose);</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  function onfinish() {</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">    . . .</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  }</font></div><div><font style="color: rgb(51, 51, 51); font-size: 12px;">  dest.once('</font><font style="font-size: 12px;" color="#0433ff">finish</font><font style="color: rgb(51, 51, 51); font-size: 12px;">', onfinish);</font></div><div style="color: rgb(51, 51, 51);"><br/></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  function unpipe() {</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">    . . .</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  }</font></div><div style="color: rgb(51, 51, 51);"><br/></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  // tell the dest that it's being piped to</font></div><div><font style="color: rgb(51, 51, 51); font-size: 12px;">  dest.emit('</font><font style="font-size: 12px;" color="#941751">pipe</font><font style="color: rgb(51, 51, 51); font-size: 12px;">', src); // 触发 pipe 事件</font></div><div style="color: rgb(51, 51, 51);"><br/></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  // start the flow if it hasn't been started already.</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // 在 readable 绑定 data 事件的时候，一般情况下已经 state.flowing === true</span><br/></font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (!state.flowing) {</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">    debug('pipe resume');</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">    src.resume();</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  }</font></div><div style="color: rgb(51, 51, 51);"><span>  // 返回输出流</span><br/></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  return dest;</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">};</font><br/></div></div><div><br/></div><div>根据上述分析，主要是为 readable 绑定 data 和 end 事件（红字）；为 writable 绑定 unpipe/drain/error/close/finish 事件。然后在最后触发 writable 的 pipe 事件。</div><div><br/></div><div>根据之前几节的分析，在 readable 绑定 data 事件处理器的时候，readable 将会开启 flowing 模式自动开始获取数据，以启动整个流程：</div><div><br/></div><div>来看 data 事件的触发阶段：</div><div><br/></div><div/><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  function ondata(chunk) {</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">    debug('ondata');</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">    increasedAwaitDrain = false;</font></div><div><font style="font-size: 12px;"><font color="#333333">    </font><font color="#ff2600">// 直接把 readable 读入的 chunk 传入 writable<br/></font></font></div><div><font style="font-size: 12px;" color="#ff2600"><span><span>    // 但是现在就遇到问题了，根据断点信息：</span><br/></span></font></div><div><font style="font-size: 12px;" color="#ff2600"><span><span><span>    // <font style="font-size: 12px;">Uint8Array[59798] 这是 chunk 的大小【readable 的默认 <font style="font-size: 12px;">highWaterMark 为 64 * 1024 == 65536</font>】所以可以一次性读入全部文件的数据，长度为：59798</font></span><br/></span></span></font></div><div><font style="font-size: 12px;"><font style="font-size: 12px;"><font color="#ff2600">    // 但是根据前几节的分析，witable 的写入 highWaterMark 为 16 * 1024 == 16384 所以，所以 write 函数的返回值为 false</font><br/></font></font></div><div><font style="font-size: 12px;"><font style="font-size: 12px;"><font color="#ff2600"><span>    // 因为 writable.write 的返回值说明：是否当前 writable 中待写入的数据已经处于“高水位”（大于 highWaterMark）</span><br/></font></font></font></div><div><font style="font-size: 12px;"><font style="font-size: 12px;"><font color="#ff2600"><span><span>    // 如果不是，则直接返回 true；如果是（当前情况）则需要返回 false，则代表在此次写完数据之后，在 onwrite 处理的后续细节中</span><br/></span></font></font></font></div><div><font style="font-size: 12px;"><font style="font-size: 12px;"><font color="#ff2600"><span><span><span>    // 需要触发 drain 事件</span><br/></span></span></font></font></font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">    var ret = dest.write(chunk);</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">    if (false === ret &amp;&amp; !increasedAwaitDrain) {</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">      // If the user unpiped during `dest.write()`, it is possible</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">      // to get stuck in a permanently paused state if that write</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">      // also returned false.</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">      // =&gt; Check whether `dest` is still a piping destination.</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">      if (((state.pipesCount === 1 &amp;&amp; state.pipes === dest) ||</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">           (state.pipesCount &gt; 1 &amp;&amp; state.pipes.indexOf(dest) !== -1)) &amp;&amp;</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">          !cleanedUp) {</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">        debug('false write response, pause', src._readableState.awaitDrain);</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    <span>   <span> // 使得 readable._readableState.awaitDrain 递增，等待 drain 事件触发</span></span></span><br/></font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">        src._readableState.awaitDrain++;</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">        increasedAwaitDrain = true;</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">      }</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    <span>  // 使得 readable pause</span></span><br/></font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">      src.pause();</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">    }</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  }</font><br/></div></div><div><br/></div><div>最终，在 writable 的 state.onwrite 函数处理中，触发了 drain 事件：</div><div><br/></div><div><img src="stream%20%E6%A8%A1%E5%9D%97%E6%B7%B1%E7%A9%B6%20-%208%20-%20pipe%20%E5%87%BD%E6%95%B0.resources/868E942C-A971-4459-B3E8-A5FBC38D5914.png" height="auto" width="100%"/><br/></div><div><br/></div><div>那么，什么时候会导致 state.needDrain 为 true 呢，就是在 writable.write 函数被调用的时候： </div><div><br/></div><div><img src="stream%20%E6%A8%A1%E5%9D%97%E6%B7%B1%E7%A9%B6%20-%208%20-%20pipe%20%E5%87%BD%E6%95%B0.resources/52C7E18B-D000-4D4B-BAE9-30962074164E.png" height="auto" width="100%"/><br/></div><div><br/></div><div>紧接着走入 drain 事件处理器函数内部：</div><div><br/></div><div/><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">function pipeOnDrain(src) {</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  return function() {</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">    var state = src._readableState;</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">    debug('pipeOnDrain', state.awaitDrain);</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    // 之前已经递增过</span><br/></font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">    if (state.awaitDrain)</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">      state.awaitDrain—; // 这里要递减计数器</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">    if (state.awaitDrain === 0 &amp;&amp; EE.listenerCount(src, 'data')) {</font></div><div><font style="font-size: 12px;"><font color="#333333">      </font><font color="#ff2600">// 最终重新启动 readable 的 flowing 模式【见前几节的 readable 细节分析】</font><br/></font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">      state.flowing = true;</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">      flow(src); // 不再赘述</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">    }</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  };</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">}</font><br/></div></div><div><br/></div><div>于是乎，readable 重新启动流程。如果仍旧没有读完数据，则继续上述流程；如果已经读完数据，则会准备出发 readable 的 end 事件，在 readable 触发 end 事件的时候，会进入具体实现层的 end 事件处理器，我们分析的是 fs 模块：</div><div><br/></div><div><img src="stream%20%E6%A8%A1%E5%9D%97%E6%B7%B1%E7%A9%B6%20-%208%20-%20pipe%20%E5%87%BD%E6%95%B0.resources/87CAFE60-61E9-4430-ACC3-FE9F3B845740.png" height="auto" width="100%"/><br/></div><div><br/></div><div>紧接着，因为 readable 还绑定了一个 end 事件处理器（上面是第一个 end 事件监听回调）：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  var endFn = doEnd ? onend : cleanup;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (state.endEmitted)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    process.nextTick(endFn);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  else</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    src.once('end', endFn);</font><br/></div></div><div><br/></div><div>而 endFn 则指向 onend 函数（第二个 end 事件监听回调）：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  <font style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51);">// 最终 readable 的 end 事件监听处理函数之一的 onend 函数同样被调用</font></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  function onend() {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    debug('onend’);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    // readable 在 end 时候，要触发 writable 的 end 回调</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    dest.end(); // 细节不再赘述</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  }</font><br/></div></div><div><br/></div><div><hr/></div><div><br/></div><div>总结上述流程，readable 自动开启 flowing 模式，在 readable 的 data 事件处理回调函数中，调用 writable.write( chunk ) ，注意这里有个细节，<font color="#ff2600">chunk 为 Buffer 实例，所以在 writable.write 函数最底层，将调用 binding.writeBuffer 函数来写入输出目标</font>。</div><div><br/></div><div>因为 readable 的 highWaterMark(64kb) 要高于 writable 的 highWaterMark(16kb) ，所以很可能会导致 writable.write( chunk ) 返回 false，以使 writable 在此次 write 真正完成后的 state.onwrite   函数中触发 drain 事件（代表此次高负载的字节流写入已经完成），从而通过函数柯里化手段配合 writable 的 drain 监听器来通知 readable 重新开始进入 flowing 状态。</div><div><br/></div><div><hr/></div><div><br/></div><div>最终进入 writable 的 finish 事件触发环节：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  function onfinish() {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    debug('onfinish’);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    // 移除 close 事件监听</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    dest.removeListener('close', onclose);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    unpipe(); // 调用 readable.unpipe( writable )</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  }</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  dest.once('finish', onfinish);</font><br/></div></div><div><br/></div><div>unpipe 函数比较简单：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">Readable.prototype.unpipe = function(dest) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  var state = this._readableState;</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // if we're not piping anywhere, then do nothing.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (state.pipesCount === 0)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    return this;</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // just one destination.  most common case.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (state.pipesCount === 1) { // 只关心有一个 pipe dest 的情况</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    // passed in one, but it's not the right one.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    if (dest &amp;&amp; dest !== state.pipes)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      return this;</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    if (!dest)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      dest = state.pipes;</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    // got a match. // 各种清空</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    state.pipes = null;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    state.pipesCount = 0;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    state.flowing = false;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    if (dest) // 触发 writable 的 unpipe 事件</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      dest.emit('unpipe', this);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    return this;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  }</font><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">. . .</font></div></div><div><br/></div><div>最终还会调用一个 close 事件，调用细节比较简单，不再赘述。</div><div><br/></div><div>至此，stream 的分析告一段落，Transform／PassThrough／Duplex 就不再分析，尤其是 Duplex ，继承了 Readable 和 Writable 两者的实现，后续若有需求则继续分析。</div><div><br/></div><div><br/></div>

<hr class="tail-hr">
<div class="tail-licenses">
<p>版权声明：自由转载-非商用-非衍生-保持署名(<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">创意共享3.0许可证</a>)</p>
<p>文章作者：Pooky (<a href="mailto:guananddu@icloud.com">guananddu@icloud.com</a>)</p>
<p>更新日期：Wed Jan 11 2017 17:30:47 GMT+0800 (CST)</p>
</div></body></html>