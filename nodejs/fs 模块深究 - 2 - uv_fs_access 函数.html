<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 6.10 (454267)"/><meta name="altitude" content="56"/><meta name="author" content="管伟"/><meta name="created" content="2017-02-09 08:19:46 +0000"/><meta name="latitude" content="39.97078175825014"/><meta name="longitude" content="116.3233939046347"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2017-02-10 07:33:23 +0000"/><title>fs 模块深究 - 2 - uv_fs_access 函数</title></head><body><style>
    a { color: #43B0D6 !important; }
    a:visited { color: #7b7ed2 !important; }
    .title-p { font-size:12px; color:gray; }
    .title-hr { margin-bottom: 20px; }
    .tail-hr { margin-top: 20px; }
    .tail-licenses { border:1px dashed lightgray; margin:20px 0 20px 0; padding:20px; font-size:14px; }
</style>
<h2>fs 模块深究 - 2 - uv_fs_access 函数</h2>
<p class="title-p">版权声明：自由转载-非商用-非衍生-保持署名(<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">创意共享3.0许可证</a>)</p>
<p class="title-p">文章作者：Pooky (<a href="mailto:guananddu@icloud.com">guananddu@icloud.com</a>)</p>
<hr class="title-hr"><div>上一节分析完了 FSReqWrap 实例对象的构造，此节继续往下分析：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>// 下面的宏是这样传参的：</div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">ASYNC_CALL(access, args[2], UTF8, *path, mode);</font><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">#define ASYNC_DEST_CALL(func, req, dest, encoding, ...)                       \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  Environment* env = Environment::GetCurrent(args);                           \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // req 必须为 Object 类型</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  CHECK(req-&gt;IsObject());                                                     \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // 显式地调用构造函数，此句的分析见上一节</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  FSReqWrap* req_wrap = FSReqWrap::New(env, req.As&lt;Object&gt;(),                 \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">                                       #func, dest, encoding);                \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // 进入 lib_uv 函数：uv_fs_access</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  int err = uv_fs_ ## func(env-&gt;event_loop(),                                 \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">                           &amp;req_wrap-&gt;req_,                                   \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">                           __VA_ARGS__,                                       \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">                           After);                                            \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  req_wrap-&gt;Dispatched();                                                     \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (err &lt; 0) {                                                              \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    uv_fs_t* uv_req = &amp;req_wrap-&gt;req_;                                        \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    uv_req-&gt;result = err;                                                     \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    uv_req-&gt;path = nullptr;                                                   \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    After(uv_req);                                                            \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    req_wrap = nullptr;                                                       \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  } else {                                                                    \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    args.GetReturnValue().Set(req_wrap-&gt;persistent());                        \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  }</font></div></div><div><br/></div><div>🌟来看进入 uv_fs_access 函数的逻辑，uv_fs_access 函数已经是基于平台的实现层函数了</div><div><br/></div><div>先来熟悉下与 fs 相关的结构体定义和概念：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">/* Request types. */ 【lib_uv 内部概念中的 Request 对象类型定义】</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">typedef struct uv_req_s uv_req_t;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">. . .</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">typedef struct uv_fs_s uv_fs_t;</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">// 看看 lib_uv 针对 Handles 和 Requests 两者对象的区别解释：</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">libuv provides users with 2 abstractions to work with, in combination(结合) with the event loop: handles and requests.</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">Handles represent long-lived objects capable(能干的) of performing certain operations while active. Some examples: a prepare handle gets its callback called once every loop iteration(迭代) when active, and a TCP server handle get its connection callback called every time there is a new connection.</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">Requests represent (typically(代表性地)) short-lived(短暂的) operations. These operations can be performed over a handle: write requests are used to write data on a handle; or standalone(单独的): getaddrinfo requests don’t need a handle they run directly on the loop.</font></div><div><br/></div></div><div><br/></div><div>requests 抽象结构体定义：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">#define UV_REQ_FIELDS                                                         \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  /* public */                                                                \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  void* data;                                                                 \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  /* read-only */                                                             \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  uv_req_type type;                                                           \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  /* private */                                                               \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  void* active_queue[2];                                                      \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  void* reserved[4];                                                          \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  UV_REQ_PRIVATE_FIELDS                                                       \</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">/* Abstract base class of all requests. */</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">struct uv_req_s {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  UV_REQ_FIELDS</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">};</font><br/></div></div><div><br/></div><div>requests 中的 uv_fs_s 结构体类型定义：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">/* uv_fs_t is a subclass of uv_req_t. */</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">struct uv_fs_s {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  UV_REQ_FIELDS // 所谓的“继承” uv_req_t</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  uv_fs_type fs_type; // 枚举类型 操作类型</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  uv_loop_t* loop; // 对应的 loop 循环</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  uv_fs_cb cb; // 回调函数指针 <font style="font-size: 12px; color: rgb(51, 51, 51);">typedef void (*uv_fs_cb)(uv_fs_t* req);</font></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  ssize_t result;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  void* ptr;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  const char* path;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  uv_stat_t statbuf;  /* Stores the result of uv_fs_stat() and uv_fs_fstat(). */</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  UV_FS_PRIVATE_FIELDS // 自己的私有类型见下</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">};</font><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">#define UV_FS_PRIVATE_FIELDS                                                  \</font></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  const char *new_path;                                                       \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  uv_file file;                                                               \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  int flags;                                                                  \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  mode_t mode;                                                                \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  unsigned int nbufs;                                                         \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  uv_buf_t* bufs;                                                             \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  off_t off;                                                                  \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  uv_uid_t uid;                                                               \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  uv_gid_t gid;                                                               \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  double atime;                                                               \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  double mtime;                                                               \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  struct uv__work work_req;                                                   \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  uv_buf_t bufsml[4];                                                         \</font><font style="font-size: 12px; color: rgb(51, 51, 51);"><br/></font></div></div><div><br/></div><div>进入 uv_fs_access 函数的执行，可以看到需要执行三个宏展开的逻辑，INIT／PATH/POST：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">int uv_fs_access(uv_loop_t* loop,</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">                 uv_fs_t* req,</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">                 const char* path,</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">                 int flags,</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">                 uv_fs_cb cb) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // <font style="font-size: 12px; color: rgb(51, 51, 51);">loop     uv_loop_t *     0x101b0bf40     0x0000000101b0bf40 【当前 loop】</font></span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // <font style="font-size: 12px; color: rgb(51, 51, 51);">req     uv_fs_t *     0x103604028     0x0000000103604028 【未被初始化的当前 FSReqWrap 的底层 uv_fs_t 结构体指针】</font></span></font></span></font></div><div><span>  // <font style="font-size: 12px; color: rgb(51, 51, 51);">path    const char *    "/Users/mrguan/work/git/happy/test-nodejs/fs/myfile.txt"    0x00007fff5fbfe098
</font></span><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // <font style="font-size: 12px; color: rgb(51, 51, 51);">flags     int     6</font></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // <font style="font-size: 12px; color: rgb(51, 51, 51);">cb     uv_fs_cb     (node`node::After(uv_fs_s*) at node_file.cc:138)     0x0000000100063280 【回调函数】</font></span><br/></font></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  INIT(ACCESS);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  PATH;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // 设置 flags 即二进制 110</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  req-&gt;flags = flags;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  POST;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">}</font><br/></div></div><div><br/></div><div>🌟 INIT(ACCESS) 的展开逻辑，通过其展开逻辑可以发现，其主要针对 req_wrap-&gt;req_ 此 uv_fs_t 类型的结构体进行初始化操作：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">#define INIT(subtype)                                                         \</font></div><div>// 上面 subtype 即为 ACCESS</div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  do {                                                                        \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    // 这个 uv_fs_t 字段为继承 uv_req_t 的通用字段，标记自己的类型</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    req-&gt;type = UV_FS;                                                        \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    // 确实不为 NULL</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    if (cb != NULL)                                                           \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      uv__req_init(loop, req, UV_FS);                                         \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    // 标记此 uv_fs_t 的子类型，即：UV_FS_ACCESS</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    req-&gt;fs_type = UV_FS_ ## subtype;                                         \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    req-&gt;result = 0;                                                          \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    req-&gt;ptr = NULL;                                                          \</font></div><div><span>    // 设置自己的 loop 指针</span><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    req-&gt;loop = loop;                                                         \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    req-&gt;path = NULL;                                                         \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    req-&gt;new_path = NULL;                                                     \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    // 设置自己的 cb 回调函数</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    req-&gt;cb = cb;                                                             \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  }                                                                           \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  while (0)</font><br/></div></div><div><br/></div><div>INIT(ACCESS) 中在 cb 正常的情况下，会调用：uv__req_init 中的逻辑，这也是个宏：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">UV_UNUSED(static void uv__req_init(uv_loop_t* loop,</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">                                   uv_req_t* req,</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">                                   uv_req_type type)) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // 走入此函数</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  req-&gt;type = type;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // 在当前 loop 中“注册”此次的 uv_req_t( uv_fs_t )</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  uv__req_register(loop, req); // 看下面的宏定义</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">}</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">#define uv__req_init(loop, req, type) \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  uv__req_init((loop), (uv_req_t*)(req), (type))</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">#define uv__req_register(loop, req)                                           \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  do {                                                                        \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    // 即将 uv_fs_t 之 req “节点”插入 loop 的 active_reqs 双向链表中去【末尾】</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    QUEUE_INSERT_TAIL(&amp;(loop)-&gt;active_reqs, &amp;(req)-&gt;active_queue);            \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  }                                                                           \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  while (0)</font><br/></div></div><div><br/></div><div>也就是说，INIT 宏中的展开逻辑执行完毕之后，uv_req_t* req 会被初始化外币，而且会将此 req 节点插入 loop 的 active_reqs 双向链表的末尾中。</div><div><br/></div><div>🌟 PATH 宏：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">#define PATH                                                                  \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  do {                                                                        \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    // 对 uv_fs_access 传入的 path 参数进行判断</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    assert(path != NULL);                                                     \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    // 显然 cb 不为 NULL</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    if (cb == NULL) {                                                         \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      req-&gt;path = path;                                                       \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    } else {                                                                  \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    <span>  // uv__strdup 用来复制一个 path 字符数组，防止修改原始 path 指针</span></span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      req-&gt;path = uv__strdup(path);                                           \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      if (req-&gt;path == NULL) {                                                \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">        uv__req_unregister(loop, req);                                        \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">        return -ENOMEM;                                                       \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      }                                                                       \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    }                                                                         \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  }                                                                           \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  while (0)</font><br/></div></div><div><br/></div><div>从上可以看出，PATH 宏主要的工作就是判断用户传入的 path 参数是不是合法，如果合法则复制，否则 return -ENOMEM；</div><div><br/></div><div>🌟 POST 宏：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">#define POST                                                                  \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  do {                                                                        \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    // 有回调函数【异步】</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    if (cb != NULL) {                                                         \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    <span>  // 着重观察</span></span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      uv__work_submit(loop, &amp;req-&gt;work_req, uv__fs_work, uv__fs_done);        \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      return 0;                                                               \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    }                                                                         \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    // 无回调函数【同步】，直接调用 uv__fs_work</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    else {                                                                    \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      uv__fs_work(&amp;req-&gt;work_req);                                            \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      return req-&gt;result;                                                     \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    }                                                                         \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  }                                                                           \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  while (0)</font><br/></div></div><div><br/></div><div>先来看下 uv__work_submit 函数中参数的类型或者定义，先看 req-&gt;work_req ，work_req 字段属于结构体 uv_fs_s 中的 UV_FS_PRIVATE_FIELDS 中的 fs 私有字段：struct uv__work work_req ，其也是一个结构体：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">struct uv__work {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // 函数指针 work，函数以 uv__work 类型的结构体指针为参数。下同 done</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  void (*work)(struct uv__work *w);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  void (*done)(struct uv__work *w, int status);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // 与之关联的 uv_loop_s loop 循环</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  struct uv_loop_s* loop;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // 链表节点标识</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  void* wq[2];</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">};</font><br/></div></div><div><br/></div><div>而 uv__work_submit 的后两个参数是两个回调函数指针：uv__fs_work, uv__fs_done，函数体先不列举，先来看 uv__work_submit 函数体：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">void uv__work_submit(uv_loop_t* loop,</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">                     struct uv__work* w,</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">                     void (*work)(struct uv__work* w),</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">                     void (*done)(struct uv__work* w, int status)) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  uv_once(&amp;once, init_once); // 此处分析见下</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // 因为 w 按照 <font style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51);">&amp;req-&gt;work_req 形式作为参数，故将此次的 req-&gt;work_req 直接作修改【初始化】</font></span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  w-&gt;loop = loop; // 设置关联 loop</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  w-&gt;work = work; // 设置 work 回调函数指针
</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  w-&gt;done = done; // 设置 done 回调函数指针</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  post(&amp;w-&gt;wq);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">}</font><br/></div></div><div><br/></div><div>关于 uv_once 函数见下，函数体很简短，但是涉及到一个重要的平台相关函数，pthread_once（unix）：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">void uv_once(uv_once_t* guard, void (*callback)(void)) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (pthread_once(guard, callback))</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    abort();</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">}</font><br/></div></div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">int pthread_once(pthread_once_t *once_control, void (*init_routine) (void))；</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">本函数使用初值为PTHREAD_ONCE_INIT的once_control变量保证init_routine()函数在本进程执行序列中仅执行一次。</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">在多线程编程环境下，尽管pthread_once()调用会出现在多个线程中，init_routine()函数仅执行一次，究竟在哪个线程中执行是不定的，是由内核调度来决定。</font><br/></div></div><div><br/></div><div>深层次的细节不再追究，但是需要知道的是，为了保证 init_once 函数在多线程环境中只执行一次，才有了这个函数调用。关于 pthread_once 函数的细节参见：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><a style="text-decoration: underline; color: rgb(0, 0, 238);" href="http://blog.csdn.net/sjin_1314/article/details/10934239">http://blog.csdn.net/sjin_1314/article/details/10934239</a><br/></div><div><a href="http://pubs.opengroup.org/onlinepubs/009695399/functions/pthread_once.html">http://pubs.opengroup.org/onlinepubs/009695399/functions/pthread_once.html</a><br/></div></div><div><br/></div><div>来看下调用栈截图：</div><div><br/></div><div><img src="fs%20%E6%A8%A1%E5%9D%97%E6%B7%B1%E7%A9%B6%20-%202%20-%20uv_fs_access%20%E5%87%BD%E6%95%B0.resources/9AAB2C27-326F-4F18-8EC0-683C1C4FB8D1.png" height="auto" width="100%"/><br/></div><div><br/></div><div>最终首先进入 init_once 函数进行初始化操作，探究一下其具体逻辑，就会明白为什么要保证多线程环境的仅一次执行 init_once。</div><div><br/></div><div>下一节继续分析。</div><div><br/></div><div><br/></div>

<hr class="tail-hr">
<div class="tail-licenses">
<p>版权声明：自由转载-非商用-非衍生-保持署名(<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">创意共享3.0许可证</a>)</p>
<p>文章作者：Pooky (<a href="mailto:guananddu@icloud.com">guananddu@icloud.com</a>)</p>
<p>更新日期：Fri Feb 10 2017 15:35:25 GMT+0800 (CST)</p>
</div></body></html>