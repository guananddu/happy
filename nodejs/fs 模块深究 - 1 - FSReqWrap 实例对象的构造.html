<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 6.10 (454267)"/><meta name="altitude" content="56"/><meta name="author" content="管伟"/><meta name="created" content="2017-01-13 07:49:44 +0000"/><meta name="latitude" content="39.97077903456425"/><meta name="longitude" content="116.3234090161813"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2017-02-09 07:43:57 +0000"/><title>fs 模块深究 - 1 - FSReqWrap 实例对象的构造</title></head><body><style>
    a { color: #43B0D6 !important; }
    a:visited { color: #7b7ed2 !important; }
    .title-p { font-size:12px; color:gray; }
    .title-hr { margin-bottom: 20px; }
    .tail-hr { margin-top: 20px; }
    .tail-licenses { border:1px dashed lightgray; margin:20px 0 20px 0; padding:20px; font-size:14px; }
</style>
<h2>fs 模块深究 - 1 - FSReqWrap 实例对象的构造</h2>
<p class="title-p">版权声明：自由转载-非商用-非衍生-保持署名(<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">创意共享3.0许可证</a>)</p>
<p class="title-p">文章作者：Pooky (<a href="mailto:guananddu@icloud.com">guananddu@icloud.com</a>)</p>
<hr class="title-hr"><div>从本节开始学习 fs 模块的内部原理，官方文档对 fs 模块的开始概览：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">File I/O is provided by simple wrappers around standard POSIX functions. To use this module do require('fs'). All the methods have asynchronous and synchronous forms.</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">The asynchronous form always takes a completion callback as its last argument. The arguments passed to the completion callback depend on the method, but the first argument is always reserved for an exception. If the operation was completed successfully, then the first argument will be null or undefined.</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">When using the synchronous form any exceptions are immediately thrown. You can use try/catch to handle exceptions or allow them to bubble up.</font><br/></div></div><div><br/></div><div>来看调试代码：</div><div><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'Menlo';font-size:13.5pt;"><span style="color:#cc7832;font-weight:bold;">const </span>fs = require( <span style="color:#6a8759;">'fs' </span>)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;font-weight:bold;">const </span>path = require( <span style="color:#6a8759;">'path' </span>)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;"><br/></span><span style="color:#cc7832;font-weight:bold;">const </span>file = path.<span style="color:#ffc66d;">resolve</span>( __dirname<span style="color:#cc7832;">, </span><span style="color:#6a8759;">'myfile.txt' </span>)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;"><br/></span>fs.access( file<span style="color:#cc7832;">, </span>fs.<span style="color:#9876aa;">constants</span>.R_OK | fs.<span style="color:#9876aa;">constants</span>.W_OK<span style="color:#cc7832;">, </span>( err ) =&gt; {<br/>    <span style="color:#9876aa;">console</span>.<span style="color:#ffc66d;">log</span>( err ? <span style="color:#6a8759;">'no access!' </span>: <span style="color:#6a8759;">'can read/write' </span>)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">    </span><span style="color:#ffc66d;">readFile</span>( file )<span style="color:#cc7832;">;<br/></span>} )<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;"><br/></span><span style="color:#cc7832;font-weight:bold;">function </span><span style="color:#ffc66d;">readFile</span>( file ) {<br/>    fs.<span style="color:#ffc66d;">readFile</span>( file<span style="color:#cc7832;">, </span>( err<span style="color:#cc7832;">, </span>data ) =&gt; {<br/>        <span style="color:#cc7832;font-weight:bold;">if </span>( err ) <span style="color:#cc7832;font-weight:bold;">throw </span>err<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">        </span><span style="color:#9876aa;">console</span>.<span style="color:#ffc66d;">log</span>( <span style="color:#6a8759;">`</span>${data.<span style="color:#ffc66d;">toString</span>().<span style="color:#ffc66d;">substring</span>( <span style="color:#6897bb;">0</span><span style="color:#cc7832;">, </span><span style="color:#6897bb;">20 </span>)}<span style="color:#6a8759;">....` </span>)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">        </span><span style="color:#ffc66d;">appendFile</span>( file )<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">    </span>} )<span style="color:#cc7832;">;<br/></span>}<br/><br/><span style="color:#cc7832;font-weight:bold;">function </span><span style="color:#ffc66d;">appendFile</span>( file ) {<br/>    fs.<span style="color:#ffc66d;">appendFile</span>( file<span style="color:#cc7832;">, </span><span style="color:#6a8759;">`</span><span style="color:#cc7832;">\n</span><span style="color:#6a8759;">data to append: </span>${<span style="color:#cc7832;font-weight:bold;">new </span>Date().<span style="color:#ffc66d;">getTime</span>()}<span style="color:#6a8759;">`</span><span style="color:#cc7832;">, </span>( err ) =&gt; {<br/>        <span style="color:#cc7832;font-weight:bold;">if </span>( err ) <span style="color:#cc7832;font-weight:bold;">throw </span>err<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">        </span><span style="color:#9876aa;">console</span>.<span style="color:#ffc66d;">log</span>( <span style="color:#6a8759;">'The "data to append" was appended to file!' </span>)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">    </span>} )<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">    </span>fs.<span style="color:#9876aa;">stat</span>( file<span style="color:#cc7832;">, </span>( err<span style="color:#cc7832;">, </span>stats ) =&gt; {<br/>        <span style="color:#9876aa;">console</span>.<span style="color:#ffc66d;">log</span>( err<span style="color:#cc7832;">, </span><span style="color:#9876aa;">JSON</span>.<span style="color:#ffc66d;">stringify</span>( stats ) )<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">    </span>} )<span style="color:#cc7832;">;<br/></span>}
</pre></div><div>从 fs.access/fs.readFile/fs.appendFile/fs.stat 这几个函数，来了解 fs 的内部原理。nodejs 的 event loop 基于 libuv，根据之前对 libuv 的初步介绍，libuv 在底层实现 File I/O 采用了线程池的机制：<a href="http://docs.libuv.org/en/v1.x/design.html">http://docs.libuv.org/en/v1.x/design.html</a>：</div><div><br/></div><div/><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">Unlike network I/O, there are no platform-specific file I/O primitives libuv could rely on, so the current approach is to run blocking file I/O operations in a thread pool.</font></div><div style="color: rgb(51, 51, 51);"><br/></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">For a thorough explanation of the cross-platform file I/O landscape, checkout this post(<a href="http://blog.libtorrent.org/2012/10/asynchronous-disk-io/"><font style="font-size: 12px; color: rgb(51, 51, 51);">http://blog.libtorrent.org/2012/10/asynchronous-disk-io/</font></a>).</font></div><div style="color: rgb(51, 51, 51);"><br/></div><div><font style="color: rgb(51, 51, 51); font-size: 12px;">libuv currently uses </font><font style="font-size: 12px;" color="#ff2600">a global thread pool</font><font style="color: rgb(51, 51, 51); font-size: 12px;"> on which all loops can queue work on. 3 types of operations are currently run on this pool:</font></div><div style="color: rgb(51, 51, 51);"><br/></div><div><font style="font-size: 12px;" color="#0433ff">Filesystem operations</font></div><div><font style="font-size: 12px;" color="#0433ff">DNS functions (getaddrinfo and getnameinfo)</font></div><div><font style="font-size: 12px;" color="#0433ff">User specified code via uv_queue_work()</font><br/></div></div><div><br/></div><div/><div>探究例子代码之前，需要了解一个来自官网细节，以上的测试代码不是最优的，仅仅用来作为切入点：</div><div><br/></div><div/><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><font style="color: rgb(51, 51, 51); font-size: 12px;">Using fs.access() to check for the accessibility of a file before calling fs.open(), fs.readFile() or fs.writeFile() is </font><font style="font-size: 12px;" color="#ff2600">not recommended</font><font style="color: rgb(51, 51, 51); font-size: 12px;">. Doing so introduces a race condition, since other processes may change the file's state between the two calls. Instead, user code should open/read/write the file directly and handle the error raised if the file is not accessible.</font><br/></div></div><div><br/></div><div><hr/></div><div><br/></div><div>来看进入 fs.access 的过程，默认的测试代码调用都是异步模式，但是同步模式也很好理解，重点分析异步模式，最终进入 fs.js 模块中的：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">// 默认的异步函数</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">fs.access = function(path, mode, callback) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  . . . // 回调函数类型判断／默认模式处理</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  mode = mode | 0; // 转整</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  var req = new FSReqWrap(); // 创建请求对象</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  req.oncomplete = makeCallback(callback); // 设置请求对象的 oncomplete 回调属性</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // 调用底层 access 方法，注意是三个参数：path, mode, req</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  binding.access(pathModule._makeLong(path), mode, req); </font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">};</font></div><div><br/></div><div>// 同步函数</div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">fs.accessSync = function(path, mode) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  . . . // 回调函数类型判断／默认模式处理</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // 直接采用 path, mode 两个参数调用 binding.access 函数</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  binding.access(pathModule._makeLong(path), mode);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">};</font><br/></div></div><div><br/></div><div><hr/></div><div><br/></div><div>上述代码中的 FSReqWrap 对象即为：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">const binding = process.binding('fs');</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">. . .</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">const FSReqWrap = binding.FSReqWrap;</font><br/></div></div><div><br/></div><div>FSReqWrap 是一个映射到 c++ 层次的构造函数，在 c++ 层次的 fs 模块中被定义，在 node/Source/src/node_file.cc 源码文件中，定义了 binding.fs 对象的各个属性和方法，其中对 FSReqWrap 构造函数的定义是：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>. . . // line 1490</div><div><span>  // 下面是通用的，对 js 层级对象暴露 c++ 类构造函数的初始化方法</span><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // Create FunctionTemplate for FSReqWrap 创建构造函数模板，指向 <font style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51);">NewFSReqWrap c++ 函数</font></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  Local&lt;FunctionTemplate&gt; fst =</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      FunctionTemplate::New(env-&gt;isolate(), NewFSReqWrap);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  fst-&gt;InstanceTemplate()-&gt;SetInternalFieldCount(1); // 设置 internal 指针字段数量【与 v8 调用中的 Wrap 函数相关，见后续分析】</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  fst-&gt;SetClassName(FIXED_ONE_BYTE_STRING(env-&gt;isolate(), "FSReqWrap")); // 类名称</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  target-&gt;Set(FIXED_ONE_BYTE_STRING(env-&gt;isolate(), "FSReqWrap"),</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">              fst-&gt;GetFunction()); // 给 target （即 fs 对象）暴露出 FSReqWrap 构造函数，以便 binding.<font style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51);">FSReqWrap 访问</font></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">}</font><br/></div></div><div><br/></div><div>在后面的各个 fs 相关函数的异步调用时，都会出现 FSReqWrap 对象的身影：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">var req = new FSReqWrap(); // 创建请求对象</font><br/></div></div><div><br/></div><div>在上述 js 代码执行时，对应的 c++ 层次的函数被执行：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">static void NewFSReqWrap(const FunctionCallbackInfo&lt;Value&gt;&amp; args) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  CHECK(args.IsConstructCall()); // 此函数并没有太多附属的初始化，这个检查只用来判断是不是通过 new 来初始化 FSReqWrap 实例对象</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">}</font><br/></div></div><div><br/></div><div>当 js 层级的 fs.access 继续往下执行，为 req(FSReqWrap 实例对象) 设置了 oncomplete 属性，最终调用进入 binding.access 底层函数，来看下此时的运行截图：</div><div><br/></div><div><img src="fs%20%E6%A8%A1%E5%9D%97%E6%B7%B1%E7%A9%B6%20-%201%20-%20FSReqWrap%20%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9E%84%E9%80%A0.resources/96F862EA-87CA-432D-ACEF-CAF68D1E6DC5.png" height="auto" width="100%"/><br/></div><div><br/></div><div><hr/></div><div><br/></div><div>关于 binding.access 底层函数的调用，首先注意传入其的三个参数：path／mode／req：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">static void Access(const FunctionCallbackInfo&lt;Value&gt;&amp; args) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  . . . // env 及 scope 初始化</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  . . . // 参数类型判断</font></div><div><br/></div><div><span>  <font style="font-size: 12px; color: rgb(51, 51, 51);">// Slightly different take on Utf8Value. If value is a String,</font></span></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // it will return a Utf8 encoded string. If value is a Buffer,</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // it will copy the data out of the Buffer as is.</font><span/><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  BufferValue path(env-&gt;isolate(), args[0]);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  <font style="font-size: 12px; color: rgb(51, 51, 51);">ASSERT_PATH(path) // 判断 path 是否合法，经常会用到：</font></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  [[ 其定义见：</span></font></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><span>    <font style="font-size: 12px; color: rgb(51, 51, 51);">#define ASSERT_PATH(path)                                                   \</font></span></span></font></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      if (*path == nullptr)                                                     \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">         return TYPE_ERROR( #path " must be a string or Buffer");</font><font style="font-size: 12px; color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><span/><br/></span></font></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><span>  </span>]]</span><br/></font></font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  int mode = static_cast&lt;int&gt;(args[1]-&gt;Int32Value()); // <font style="font-size: 12px; color: rgb(51, 51, 51);">mode     int     6</font></font></div><div><span>  // 通过第三个参数是否传入且是否为 Object 来确定异步或者同步模式</span><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (args[2]-&gt;IsObject()) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    ASYNC_CALL(access, args[2], UTF8, *path, mode);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  } else {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    SYNC_CALL(access, *path, *path, mode);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  }</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">}</font><br/></div></div><div><br/></div><div><hr/></div><div><br/></div><div>关于：ASYNC_CALL(access, args[2], UTF8, *path, mode) 的含义：</div><div><br/></div><div>其中第一个 “access” 参数指代底层 c++ 函数：access：参见解释：（<a href="https://linux.die.net/man/2/access">https://linux.die.net/man/2/access</a>）摘要：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">Name</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">access - check real user's permissions for a file</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">Synopsis</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">#include &lt;unistd.h&gt;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">int access(const char *pathname, int mode);</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">Description</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"> access() checks whether the calling process can access the file pathname. If pathname is a symbolic link, it is dereferenced.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">The mode specifies the accessibility check(s) to be performed, and is either the value F_OK, or a mask consisting of the bitwise OR of one or more of R_OK, W_OK, and X_OK. F_OK tests for the existence of the file. R_OK, W_OK, and X_OK test whether the file exists and grants read, write, and execute permissions, respectively.</font><br/></div></div><div><br/></div><div>第二个参数 args[2] 为 FSReqWrap 实例对象；第三个参数 utf8 枚举类型；第四个参数 *path 将 path 指针解引用，获取其值；第五个参数为 mode 即测试类型。</div><div><br/></div><div>来看 ASYNC_CALL 宏展开：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">#define ASYNC_CALL(func, req, encoding, ...)                                  \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  ASYNC_DEST_CALL(func, req, nullptr, encoding, __VA_ARGS__)                  \</font><br/></div><div><br/></div><div>__VA_ARGS__ 代表 … 部分的参数列表</div></div><div><br/></div><div>继续展开 ASYNC_DEST_CALL ：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">#define ASYNC_DEST_CALL(func, req, dest, encoding, ...)                       \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  Environment* env = Environment::GetCurrent(args);                           \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // req 必须为 Object 类型</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  CHECK(req-&gt;IsObject());                                                     \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // 显式地调用构造函数，此句的分析见下</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  FSReqWrap* req_wrap = FSReqWrap::New(env, req.As&lt;Object&gt;(),                 \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">                                       #func, dest, encoding);                \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  int err = uv_fs_ ## func(env-&gt;event_loop(),                                 \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">                           &amp;req_wrap-&gt;req_,                                   \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">                           __VA_ARGS__,                                       \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">                           After);                                            \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  req_wrap-&gt;Dispatched();                                                     \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (err &lt; 0) {                                                              \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    uv_fs_t* uv_req = &amp;req_wrap-&gt;req_;                                        \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    uv_req-&gt;result = err;                                                     \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    uv_req-&gt;path = nullptr;                                                   \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    After(uv_req);                                                            \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    req_wrap = nullptr;                                                       \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  } else {                                                                    \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    args.GetReturnValue().Set(req_wrap-&gt;persistent());                        \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  }</font><br/></div></div><div><br/></div><div>关于 FSReqWrap::New 的调用：</div><div><br/></div><div/><div style="box-sizing: border-box; padding: 8px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">FSReqWrap* FSReqWrap::New(Environment* env,</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">                          Local&lt;Object&gt; req,</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">                          const char* syscall,</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">                          const char* data,</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">                          enum encoding encoding,</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">                          Ownership ownership) {</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // <font style="font-size: 12px; color: rgb(51, 51, 51);">env     node::Environment *     0x105000000     0x0000000105000000</font></span><br/></font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // <font style="font-size: 12px; color: rgb(51, 51, 51);">req     v8::Local&lt;v8::Object&gt;</font></span><br/></font></span></font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // <span>    <font style="font-size: 12px; color: rgb(51, 51, 51);">val_     v8::Object *     0x7fff5fbfe920     0x00007fff5fbfe920</font></span></span><br/></font></span></font></span></font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // <font style="font-size: 12px; color: rgb(51, 51, 51);">syscall     const char *     "access”     0x00000001011156e3 【系统调用函数的名称】</font></span><br/></font></span></font></span></font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // <font style="font-size: 12px; color: rgb(51, 51, 51);">data     const char *     NULL     0x0000000000000000 【空指针】</font></span><br/></font></span></font></span></font></span></font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><font style="font-size: 12px; color: rgb(51, 51, 51);"><span> <span> // <font style="font-size: 12px; color: rgb(51, 51, 51);">encoding     node::encoding     UTF8 【编码】</font></span></span><br/></font></span></font></span></font></span></font></span></font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><span>  // <font style="font-size: 12px; color: rgb(51, 51, 51);">ownership     node::FSReqWrap::Ownership     COPY 【所有权？】</font></span><br/></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">  const bool copy = (data != nullptr &amp;&amp; ownership == COPY); // <font style="font-size: 12px; color: rgb(51, 51, 51);">copy     const bool     false</font><br/></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">  const size_t size = copy ? 1 + strlen(data) : 0; // <font style="font-size: 12px; color: rgb(51, 51, 51);">size     size_t     0</font></font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">  FSReqWrap* that; // 初始化指针</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // 计算 FSReqWrap 对象大小，并且开辟空间，注意 storage 类型为数组【指针类型】</span></font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font face="Monaco, Menlo, Consolas, Courier New, monospace" color="#333333"><span>  </span>// </font><font face="Monaco, Menlo, Consolas, Courier New, monospace" color="#333333">storage     char *const     "”     0x0000000105800010</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font face="Monaco, Menlo, Consolas, Courier New, monospace" color="#333333"><span>  // <font style="font-size: 12px; color: rgb(51, 51, 51);">(lldb) print storage[0]</font></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // (char) $18 = '\0'</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // (lldb) print storage[1]</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">  // (char) $19 = ‘\0'</font><font face="Monaco, Menlo, Consolas, Courier New, monospace" color="#333333"><span/><br/></font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">  char* const storage = new char[sizeof(*that) + size];</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // 开始在上面开辟的空间内初始化 FSReqWrap 实例</span><br/></font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">  that = new(storage) FSReqWrap(env, req, syscall, data, encoding);</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">  . . .</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // 最终返回创建的对象</span><br/></font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">  return that;</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">}</font><br/></div></div><div><br/></div><div>来看 FSReqWrap 的 c++ 构造函数被调用的时候，因为 FSReqWrap 类的继承结构比较深，一步一步来看：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">#5     0x0000000100063229 in node::FSReqWrap::New(node::Environment*, v8::Local&lt;v8::Object&gt;, char const*, char const*, node::encoding, node::FSReqWrap::Ownership) at /Users/mrguan/work/build/node/node-6.6.0/src/node_file.cc:116</font></div><div><br/>// 这里是调用处
</div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">that = new(storage) FSReqWrap(env, req, syscall, data, encoding);</font><br/></div><div>// 具体的参数信息见上一个代码块中的注释</div></div><div><br/></div><div>在构造 FSReqWrap 实例对象时，会从最顶层的 super 类构造函数一层一层往下调用：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">#4     0x0000000100063e2d in node::FSReqWrap::FSReqWrap(node::Environment*, v8::Local&lt;v8::Object&gt;, char const*, char const*, node::encoding) at /Users/mrguan/work/build/node/node-6.6.0/src/node_file.cc:86</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">#3     0x0000000100063eb2 in node::FSReqWrap::FSReqWrap(node::Environment*, v8::Local&lt;v8::Object&gt;, char const*, char const*, node::encoding) at /Users/mrguan/work/build/node/node-6.6.0/src/node_file.cc:83</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">#2     0x0000000100063f5d in node::ReqWrap&lt;uv_fs_s&gt;::ReqWrap(node::Environment*, v8::Local&lt;v8::Object&gt;, node::AsyncWrap::ProviderType) at /Users/mrguan/work/build/node/node-6.6.0/src/req-wrap-inl.h:20</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">#1     0x0000000100010fb0 in node::AsyncWrap::AsyncWrap(node::Environment*, v8::Local&lt;v8::Object&gt;, node::AsyncWrap::ProviderType, node::AsyncWrap*) at /Users/mrguan/work/build/node/node-6.6.0/src/async-wrap-inl.h:22</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">#0     0x0000000100011516 in node::BaseObject::BaseObject(node::Environment*, v8::Local&lt;v8::Object&gt;) at /Users/mrguan/work/build/node/node-6.6.0/src/base-object-inl.h:18</font></div></div><div><br/></div><div>构造函数调用顺序：0 -&gt; 4，调用栈截图见：</div><div><br/></div><div><img src="fs%20%E6%A8%A1%E5%9D%97%E6%B7%B1%E7%A9%B6%20-%201%20-%20FSReqWrap%20%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9E%84%E9%80%A0.resources/85E60878-4DE0-43EA-983C-483552631A6E.png" height="auto" width="100%"/><br/></div><div><br/></div><div>0 -&gt; node::BaseObject::BaseObject 的调用：<br/></div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">inline BaseObject::BaseObject(Environment* env, v8::Local&lt;v8::Object&gt; handle)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    // 🌟<font style="font-size: 12px; color: rgb(51, 51, 51);">v8::Persistent&lt;v8::Object&gt; persistent_handle_</font></span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    // 🌟<font style="font-size: 12px; color: rgb(51, 51, 51);">注意这里的 <font style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51);">persistent_handle_ ，是将原始 js 层级的 req 对象在 c++ 层次的映射 Local 对象转化为一个“持久化”的 Handle 对象</font></font></span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><font style="font-size: 12px; color: rgb(51, 51, 51);"><font style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51);"><span>    // 🌟在最外层的构造函数调用 object() 函数时，将返回此 <font style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51);">persistent_handle_ 对象【即为 req 对象的持久化映射对象】重新转化为</font></span><br/></font></font></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><font style="font-size: 12px; color: rgb(51, 51, 51);"><font style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51);"><span><font style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51);"><span>   <span> // 🌟Local 类型对象</span></span><br/></font></span></font></font></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    : persistent_handle_(env-&gt;isolate(), handle), <font style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51);"/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      env_(env) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // 注意这里的 handle 对象即为之前传入的 req 对象</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><span>  // <font style="font-size: 12px; color: rgb(51, 51, 51);">handle     v8::Local&lt;v8::Object&gt;  <font style="font-size: 12px; color: rgb(51, 51, 51);">val_     v8::Object *     0x7fff5fbfe920     0x00007fff5fbfe920</font></font></span><br/></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  CHECK_EQ(false, handle.IsEmpty()); // 先判断 req 异步请求对象是正常的</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // The zero field holds a pointer to the handle. Immediately set it to</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // nullptr in case it's accessed by the user before construction is complete.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // 因为 js 层级的 binding.<font style="font-size: 12px; color: rgb(51, 51, 51);">FSReqWrap 构造函数映射到 c++ 层次，且在其初始化时有 <font style="font-size: 12px; color: rgb(51, 51, 51);">SetInternalFieldCount(1) 调用（见上述分析）</font></font></span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><font style="font-size: 12px; color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // <font style="font-size: 12px; color: rgb(51, 51, 51);">(lldb) print handle-&gt;InternalFieldCount()</font></span></font></font></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // (int) $0 = 1</font><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><font style="font-size: 12px; color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);"><br/></font></font></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (handle-&gt;InternalFieldCount() &gt; 0)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    // 会进入分支执行</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    handle-&gt;SetAlignedPointerInInternalField(0, nullptr);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // 【具体含义是什么有待缕清】</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">}</font><br/></div></div><div><br/></div><div>1 -&gt; node::AsyncWrap::AsyncWrap 的调用：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">inline AsyncWrap::AsyncWrap(Environment* env,</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">                            v8::Local&lt;v8::Object&gt; object,</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">                            ProviderType provider,</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">                            AsyncWrap* parent)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    : BaseObject(env, object), bits_(static_cast&lt;uint32_t&gt;(provider) &lt;&lt; 1),</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      uid_(env-&gt;get_async_wrap_uid()) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // <font style="font-size: 12px; color: rgb(51, 51, 51);">this     node::AsyncWrap *     0x103603ff0     0x0000000103603ff0</font></span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // <span>    <font style="font-size: 12px; color: rgb(51, 51, 51);">node::BaseObject     node::BaseObject     </font></span></span><br/></font></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><span><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  //<span>     <font style="font-size: 12px; color: rgb(51, 51, 51);">bits_     uint32_t     6</font></span></span><br/></font></span></span></font></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><span><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><span><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  //<span>     <font style="font-size: 12px; color: rgb(51, 51, 51);">uid_     int64_t     1</font></span></span><br/></font></span></span></font></span></span></font></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  CHECK_NE(provider, PROVIDER_NONE);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  CHECK_GE(object-&gt;InternalFieldCount(), 1); // <font style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51);">object-&gt;InternalFieldCount() == 1 判断是不是 &gt;= 1</font></font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // Shift provider value over to prevent id collision.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  persistent().SetWrapperClassId(NODE_ASYNC_ID_OFFSET + provider);</font></div><div><span>  // 【TODO】<font style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51);">env-&gt;async_hooks_init_function 是用来做什么的？</font></span><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  v8::Local&lt;v8::Function&gt; init_fn = env-&gt;async_hooks_init_function();</font></div><div><span>  // <font style="font-size: 12px; color: rgb(51, 51, 51);">init_fn     v8::Local&lt;v8::Function&gt;     <font style="font-size: 12px; color: rgb(51, 51, 51);">val_     v8::Function *     NULL     0x0000000000000000</font></font></span><br/></div><div><span><font style="font-size: 12px; color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // 从这个分支跳出</span><br/></font></font></span></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // No init callback exists, no reason to go on.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (init_fn.IsEmpty())</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    return;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">. . .</font><br/></div></div><div><br/></div><div>2 -&gt; node::ReqWrap&lt;uv_fs_s&gt;::ReqWrap 的调用：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">template &lt;typename T&gt;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">ReqWrap&lt;T&gt;::ReqWrap(Environment* env,</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">                    v8::Local&lt;v8::Object&gt; object,</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">                    AsyncWrap::ProviderType provider)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    : AsyncWrap(env, object, provider) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  . . .</font></div><div><span>  // <font style="font-size: 12px; color: rgb(51, 51, 51);">this     node::ReqWrap&lt;uv_fs_s&gt; *     0x103603ff0     0x0000000103603ff0</font></span><br/></div><div><span><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // <span>    <font style="font-size: 12px; color: rgb(51, 51, 51);">node::AsyncWrap     node::AsyncWrap     </font></span></span><br/></font></span></div><div><span><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><span><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // <span>    <font style="font-size: 12px; color: rgb(51, 51, 51);">req_wrap_queue_     node::ListNode&lt;node::ReqWrap&lt;uv_fs_s&gt; &gt;     </font></span></span><br/></font></span></span></font></span></div><div><span><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><span><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><span><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  //<span>     <font style="font-size: 12px; color: rgb(51, 51, 51);">req_     uv_fs_s     </font></span></span><br/></font></span></span></font></span></span></font></span></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // FIXME(bnoordhuis) The fact that a reinterpret_cast is needed is</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // arguably a good indicator that there should be more than one queue.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // 🌟🌟🌟将这次的请求 ReqWrap&lt;uv_req_t&gt; 推入队列 <font style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51);">env-&gt;</font><font style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51);">req_wrap_queue<font style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51);">🌟🌟🌟</font></font></span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  env-&gt;req_wrap_queue()-&gt;PushBack(reinterpret_cast&lt;ReqWrap&lt;uv_req_t&gt;*&gt;(this));</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">}</font><br/></div></div><div><br/></div><div>3/4 -&gt; node::FSReqWrap::FSReqWrap 执行流程：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>. . .</div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"> private: // FSReqWrap 构造函数为私有，被 <font style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51);">FSReqWrap::New 所调用和构建</font></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  FSReqWrap(Environment* env,</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">            Local&lt;Object&gt; req,</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">            const char* syscall,</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">            const char* data,</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">            enum encoding encoding)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      : ReqWrap(env, req, AsyncWrap::PROVIDER_FSREQWRAP),</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">        encoding_(encoding),</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">        syscall_(syscall),</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">        data_(data) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    // object() 函数将一个 v8 中的“持久化 Handle 对象”转化成 Local 类型对象【与原始的 req 相对应】</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><span>    // <font style="font-size: 12px; color: rgb(51, 51, 51);">return PersistentToLocal(env_-&gt;isolate(), persistent_handle_);</font></span></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    // 注意这里的 Wrap 函数</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><span>    [[</span></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><span><font style="font-size: 12px; color: rgb(51, 51, 51);">        template &lt;typename TypeName&gt;</font></span></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">        void Wrap(v8::Local&lt;v8::Object&gt; object, TypeName* pointer) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">          CHECK_EQ(false, object.IsEmpty());</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">          CHECK_GT(object-&gt;InternalFieldCount(), 0); </font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    <span>    <span>  // <font style="font-size: 12px; color: rgb(51, 51, 51);">(lldb) print object-&gt;InternalFieldCount()</font></span></span></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    <span>    <span>  // </span></span></span>(int) $18 = 1</font><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><span><span/></span></span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    <span>    <span>  // 将此 v8::Local&lt;<font style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51);">v8::</font>Object&gt; 对象（与 js 层级的 object 对应）中设置指向对应 c++ 映射对象的指针</span></span></span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">          object-&gt;SetAlignedPointerInInternalField(0, pointer);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">        }</font><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><span>    </span></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><span>    ]]</span><br/></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><span><span>    // 这是一种常见的将 js 对象和 c++ 对象“粘合”的方式</span><br/></span></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    Wrap(object(), this);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  }</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  . . .</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">};</font><br/></div></div><div><br/></div><div>到此，FSReqWrap 对象构建完毕，过程比较复杂，一系列 super 及其自身构造函数完成执行后，也把自身推入了 env-&gt;req_wrap_queue() 的双向 req_wrap 请求队列中，并且最重要的是要了解 js 对象和 c++ 对象是怎么“粘合”在一起的(Wrap(object(), this))。最终的继承结构截图：</div><div><br/></div><div><img src="fs%20%E6%A8%A1%E5%9D%97%E6%B7%B1%E7%A9%B6%20-%201%20-%20FSReqWrap%20%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9E%84%E9%80%A0.resources/ED5168C5-AFAE-4250-8636-730C9B6B9328.png" height="auto" width="100%"/><br/></div><div><br/></div><div>下一节继续分析。</div><div><br/></div><div><hr/></div><div><br/></div><div>附录</div><div><br/></div><div>env-&gt;req_wrap_queue() 链表相关初始化和操作：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>// 链表 append</div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">env-&gt;req_wrap_queue()-&gt;PushBack(reinterpret_cast&lt;ReqWrap&lt;uv_req_t&gt;*&gt;(this));</font><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><br/></font></div><div>// req_wrap_queue 定义：</div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">typedef ListHead&lt;ReqWrap&lt;uv_req_t&gt;, &amp;ReqWrap&lt;uv_req_t&gt;::req_wrap_queue_&gt;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      ReqWrapQueue;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">inline ReqWrapQueue* req_wrap_queue() { return &amp;req_wrap_queue_; }</font><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><br/></font></div><div>// 如何 PushBack</div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">template &lt;typename T, ListNodeMember(T) M&gt;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">void ListHead&lt;T, M&gt;::PushBack(T* element) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  ListNode&lt;T&gt;* that = &amp;(element-&gt;*M);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  head_.prev_-&gt;next_ = that;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  that-&gt;prev_ = head_.prev_;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  that-&gt;next_ = &amp;head_;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  head_.prev_ = that;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">}</font><br/></div></div><div><br/></div><div><br/></div>

<hr class="tail-hr">
<div class="tail-licenses">
<p>版权声明：自由转载-非商用-非衍生-保持署名(<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">创意共享3.0许可证</a>)</p>
<p>文章作者：Pooky (<a href="mailto:guananddu@icloud.com">guananddu@icloud.com</a>)</p>
<p>更新日期：Thu Feb 09 2017 15:48:32 GMT+0800 (CST)</p>
</div></body></html>