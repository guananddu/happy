<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 6.10 (454267)"/><meta name="author" content="管伟"/><meta name="created" content="2017-01-09 09:09:06 +0000"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2017-01-10 12:44:38 +0000"/><title>stream 模块深究 - 7 - Writable state.onwrite</title></head><body><style>
    a { color: #43B0D6 !important; }
    a:visited { color: #7b7ed2 !important; }
    .title-p { font-size:12px; color:gray; }
    .title-hr { margin-bottom: 20px; }
    .tail-hr { margin-top: 20px; }
    .tail-licenses { border:1px dashed lightgray; margin:20px 0 20px 0; padding:20px; font-size:14px; }
</style>
<h2>stream 模块深究 - 7 - Writable state.onwrite</h2>
<p class="title-p">版权声明：自由转载-非商用-非衍生-保持署名(<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">创意共享3.0许可证</a>)</p>
<p class="title-p">文章作者：Pooky (<a href="mailto:guananddu@icloud.com">guananddu@icloud.com</a>)</p>
<hr class="title-hr"><div>本节承接前一节的内容，从 state.onwrite 函数执行流程开始追踪。但是为了追踪这个函数被调用的时机，需要想办法把 fs.write 函数传入的异步回调函数给断点住，怎么才能做到呢？看下面的测试代码：</div><div><br/></div><div/><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">const fs = require( 'fs' );</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">const path = require( 'path' );</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">const stream = require( 'stream' );</font></div><div style="color: rgb(51, 51, 51);"><br/></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">const filePath = path.resolve( __dirname, 'output.txt' );</font></div><div style="color: rgb(51, 51, 51);"><br/></div><div><font style="font-size: 12px;" color="#0433ff">// 为了 debug，使得断点可以进入 fs.write 的回调函数</font></div><div><font style="font-size: 12px;" color="#0433ff">const oldFsWrite = fs.write;</font></div><div><font style="font-size: 12px;" color="#0433ff">// 复写 fs.write 函数</font></div><div><font style="font-size: 12px;" color="#0433ff">fs.write = function () {</font></div><div><font style="font-size: 12px;" color="#0433ff">    var cb = arguments[ 5 ];</font></div><div><font style="font-size: 12px;" color="#0433ff"><span>    // 修改回调函数</span><br/></font></div><div><font style="font-size: 12px;" color="#0433ff">    arguments[ 5 ] = function ( er, bytes ) {</font></div><div><font style="font-size: 12px;" color="#0433ff">        debugger;</font></div><div><font style="font-size: 12px;" color="#0433ff">        cb( er, bytes );</font></div><div><font style="font-size: 12px;" color="#0433ff">    };</font></div><div><font style="font-size: 12px;" color="#0433ff"><span>    // 调用原始 fs.write 函数</span><br/></font></div><div><font style="font-size: 12px;" color="#0433ff">    oldFsWrite.apply( fs, arguments );</font></div><div><font style="font-size: 12px;" color="#0433ff">};</font></div><div style="color: rgb(51, 51, 51);"><br/></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">const writeable = fs.createWriteStream( filePath, {</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">    defaultEncoding: 'utf8'</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">} );</font></div><div style="color: rgb(51, 51, 51);"><br/></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">writeable.on( 'open', o =&gt; {</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">    console.log( 'open event!', o );</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">} );</font></div><div style="color: rgb(51, 51, 51);"><br/></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">writeable.on( 'close', o =&gt; {</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">    console.log( 'close event!', o );</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">} );</font></div><div style="color: rgb(51, 51, 51);"><br/></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">writeable.on( 'finish', o =&gt; {</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">    console.log( 'finish event!', o );</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">} );</font></div><div style="color: rgb(51, 51, 51);"><br/></div><div style="color: rgb(51, 51, 51);">. . .</div><div style="color: rgb(51, 51, 51);"><br/></div></div><div><br/></div><div>如上代码中，蓝色代码部分即为实现。进入断点的时机见下面代码：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">WriteStream.prototype._write = function(data, encoding, cb) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  . . .</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // 当进入到 _write 此函数内部的时候，很可能 WriteStream.prototype.open 函数中的 fs.open 函数的回调函数还没有执行完毕</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // 当 fs.open 的回调函数执行完毕的时候，this.fd 才被赋值</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (typeof this.fd !== 'number’)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    // 所以此时只需要结束 _write 的执行，并且等待 fs.open 回调函数中的 this.emit( ‘open’, fs ) 事件被触发</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    // 然后再次调用 this._write 函数来继续执行后续逻辑</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    return this.once('open', function() {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      this._write(data, encoding, cb);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    });</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // 真正进入后面的逻辑我们后续继续分析</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  . . .</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">};</font></div></div><div><br/></div><div>如上代码，在 writeable.write( ‘abc\n’ ) 第一次调用 write 时，最终进入 fs writestream 实现层的 _write 函数，发现此时的 this.fd 还没有被赋值，因为 this.open 的回调函数还没有被执行，open 事件还没有被触发：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">WriteStream.prototype.open = function() {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  fs.open(this.path, this.flags, this.mode, function(er, fd) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    if (er) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      . . .</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      return;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    }</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    // 记录文件描述符</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    this.fd = fd;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    // 这个时候才会触发 open 事件，进而执行 this._write 函数</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    this.emit('open', fd); // 触发 open 事件</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  }.bind(this));</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">};</font><br/></div></div><div><br/></div><div><hr/></div><div><br/></div><div>接下来看断点细节，下面的截图是进入 fs.write 回调时的断点，说明 open 事件已经被触发之后的回调：</div><div><br/></div><div><img src="stream%20%E6%A8%A1%E5%9D%97%E6%B7%B1%E7%A9%B6%20-%207%20-%20Writable%20state.onwrite.resources/CD8879DA-8A43-4D31-B7D8-D9F48330AFFB.png" height="auto" width="100%"/><br/></div><div><br/></div><div>注意右下角的 Local 变量 bytes == 4 说明，此时写入的正是 ‘abc\n’ 四个字节的内容，再从 output.txt 里面的内容确定一下，确实只有 abc 以及换行内容。继续往下走进入 cb 函数，这个 cb 函数即为原始 fs.write 函数的回调函数：</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  . . .</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  </span>var self = this;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  fs.write(this.fd, data, 0, data.length, this.pos, function(er, bytes) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    // 进入这里面 er == null</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><span>    // bytes == 4</span><br/></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    if (er) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      . . .</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    }</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    // <font style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51);">self.bytesWritten 增加此次调用的 fs.write 成功写入的 字节数</font></span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><font style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51);"><span>    // 4</span><br/></font></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    self.bytesWritten += bytes;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    cb(); // 进入 state.onwrite 回调函数</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  });</font><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  . . .</span><br/></font></div></div><div> <br/></div><div>接下来看进入 state.onwrite 函数后续的执行流程，this.onwrite 函数最终调用 _stream_writable.js 中的私有函数 onwrite：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">function onwrite(stream, er) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // 获取 state</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  var state = stream._writableState;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // 在之前 doWrite 函数被触发的时候，会标记几个变量</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><span>  [[ 这是 doWrite 函数中的调用</span></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><span><span>  <span>    <font style="font-size: 12px; color: rgb(51, 51, 51);">function doWrite(stream, state, writev, len, chunk, encoding, cb) {</font></span></span></span></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">         state.writelen = len;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  <font style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51);">       </font>state.writecb = cb;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  <font style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51);">       </font>state.writing = true;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    <span>    <span> . . . // 调用 stream._write/<font style="font-size: 12px; color: rgb(51, 51, 51);">_writev</font></span></span></span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  <font style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51);">       </font>state.sync = false;</font><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><span><span><span/></span><br/></span></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    <font style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51);">     . . .</font></span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><span><span>  </span>]]</span><br/></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  var sync = state.sync;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  var cb = state.writecb; // 用户不传的话就是 <font style="font-size: 12px; color: rgb(51, 51, 51);">function nop() {}</font></font></div><div><span> </span><br/></div><div><span><span>  [[ 来看 onwriteStateUpdate(state) 的调用细节</span></span></div><div><span><span><span>    <font style="font-size: 12px; color: rgb(51, 51, 51);">function onwriteStateUpdate(state) {</font></span></span></span></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">       state.writing = false; // state.writing 标记为 false</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  <font style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51);">     </font>state.writecb = null; // 置空 writecb</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  <font style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51);">     </font>state.length -= state.writelen; </font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    <span>   </span></span>// state.length 代表目前总共“待写入”的字节长；</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    <span>   // </span></span>state.writelen 代表此次已经写入的字节长度，所以要减去已写入的字节长；</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  <font style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51);">     </font>state.writelen = 0; // 归零</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><font style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51);">    </font>}</font><span><span><span/><br/></span></span></div><div><span><span>  ]]</span><br/></span></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  onwriteStateUpdate(state);</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (er) // 检查是不是有错误</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    onwriteError(stream, state, sync, er, cb);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  else {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    // Check if we're actually ready to finish, but don't emit yet</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    [[ needFinishing 的条件</span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><span>    <span>    <font style="font-size: 12px; color: rgb(51, 51, 51);">(state.ending &amp;&amp;</font></span></span></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">           state.length === 0 &amp;&amp; // 这个条件肯定不满足，因为 state.length 只减去了第一次的 abc\n 的长度</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    <font style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51);">       </font>state.bufferedRequest === null &amp;&amp; // 而且 state.bufferedRequest 中还有三个待写入的节点</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    <font style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51);">       </font>!state.finished &amp;&amp;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    <font style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51);">       </font>!state.writing)</font><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><span><span/></span><br/></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    ]]</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    var finished = needFinish(state);</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    if (!finished &amp;&amp; // finished === false</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">        !state.corked &amp;&amp; // state.corked === 0</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">        !state.bufferProcessing &amp;&amp; // false</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">        state.bufferedRequest) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    <span>  // 因为还没有到 finish 这个缓解，最终走入 clearBuffer，因为 Buffer 中还有内容，见下分析</span></span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      clearBuffer(stream, state);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    }</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    if (sync) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      process.nextTick(afterWrite, stream, state, finished, cb);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    } else {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    <span>  // 进入 afterWrite 见下分析</span></span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      afterWrite(stream, state, finished, cb);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    }</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  }</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">}</font><br/></div></div><div><br/></div><div>来看 clearBuffer 的执行，此函数比较长，但是很重要：</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><font style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">// if there's something in the buffer waiting, then process it</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">function clearBuffer(stream, state) {</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">  state.bufferProcessing = true; // 首先标记，当前开始 bufferProcessing </font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">  var entry = state.bufferedRequest; // 获取到 buffer 链表</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><span>  // 注意这里，因为实现层是 fs 模块的 WriteStream ，而 fs 中的 WriteStream 原型对象中存在 <font style="font-size: 12px; color: rgb(51, 51, 51);">_writev 函数，故这里进入第一分支</font></span><br/></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><span><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // 根据官方文档，_writev 可以一次处理多个 chunks，而 _write 一次只能处理一个 chunk，所以前者更快</span><br/></font></span></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (stream._writev &amp;&amp; entry &amp;&amp; entry.next) {</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">    // Fast case, write everything using _writev()</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">    var l = state.bufferedRequestCount; // 目前待写入的 chunk 节点数量</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">    var buffer = new Array(l);</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    // 现将其赋给 holder 本地变量</span><br/></font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">    var holder = state.corkedRequestsFree; // 在最初 stream 被初始化的时候创建</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">    holder.entry = entry; // 将第一个 chunk 节点 赋予 holder.entry</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><br/></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">    var count = 0;</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">    while (entry) {</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">      buffer[count] = entry;</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">      entry = entry.next;</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">      count += 1;</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">    }</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    // 执行完毕上面的 while 循环，就将链表中的 WriteReq 即 chunk 包装 节点放到了同等大小的 Array 当中去</span><br/></font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><span>    // 在此进入 doWrite 函数，具体执行细节，见后面的分析</span><br/></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><span><span>    // holder.finish 回调最终处理 bufferedRequest 中的用户回调函数，详见后面的分析</span><br/></span></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">    doWrite(stream, state, true, state.length, buffer, '', holder.finish);</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><br/></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">    // doWrite is almost always async, defer these to save a bit of time</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">    // as the hot path ends with doWrite</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">    state.pendingcb++; // 每次调用一次 write 函数，都回 state.pendingcb ++ ； 4 -&gt; 5</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">    state.lastBufferedRequest = null; // 清空</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">    if (holder.next) { // null</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">      state.corkedRequestsFree = holder.next;</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">      holder.next = null;</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">    } else {</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    <span>  // 已经把之前的 corkedRequestsFree 对象赋给了 holder 变量</span></span><br/></font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><span><span>    <span>  // 将 state.corkedRequestsFree 恢复为初始化的状态</span></span><br/></span></span></font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">      state.corkedRequestsFree = new CorkedRequest(state);</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">    }</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">  } else {</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">    // Slow case, write chunks one-by-one 【比较慢的实现】</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">    . . .</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">  }</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><br/></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">  state.bufferedRequestCount = 0; // 恢复</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">  state.bufferedRequest = entry; // 因为有 while 循环，所以最后 entry 变为 null</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">  state.bufferProcessing = false; // 状态恢复</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">}</font><br/></div></div><div><br/></div><div>clearBuffer 中 _writev 分支中的 doWrite 执行细节截图：</div><div><br/></div><div><img src="stream%20%E6%A8%A1%E5%9D%97%E6%B7%B1%E7%A9%B6%20-%207%20-%20Writable%20state.onwrite.resources/A80842AA-6AD0-4904-A59B-3C7FA66D5BF1.png" height="auto" width="100%"/><br/></div><div><br/></div><div>最终调用进入 fs 实现层的 stream._writev 函数：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">WriteStream.prototype._writev = function(data, cb) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  . . .</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  const self = this;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  const len = data.length;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  const chunks = new Array(len); // 新建数组</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  var size = 0;</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  for (var i = 0; i &lt; len; i++) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    . . . // 直接拿出 WriteReq 节点中的 chunk 对象 <font style="font-size: 12px; color: rgb(51, 51, 51);">Uint8Array[13]</font></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  } // 重新赋值 + 计算总长</font></div><div><span>  // 此时的 chunks 是一个有 3 个 Uint8Array 对象的 Array</span><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  writev(this.fd, chunks, this.pos, function(er, bytes) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    if (er) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      self.destroy();</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      return cb(er);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    }</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    self.bytesWritten += bytes;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    cb();</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  });</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (this.pos !== undefined)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    this.pos += size;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">};</font><br/></div></div><div><br/></div><div>再次进入 writev 内部函数，看下截图：</div><div><br/></div><div><img src="stream%20%E6%A8%A1%E5%9D%97%E6%B7%B1%E7%A9%B6%20-%207%20-%20Writable%20state.onwrite.resources/3EBD75D5-5D32-43C5-B064-7DA6CE294995.png" height="auto" width="100%"/><br/></div><div><br/></div><div>writev 实现的内部，调用了 C++ 底层的 binding.writeBuffers 函数，此函数属于 C++ 的实现，暂不深究，此函数的回调函数，根据上面的分析，仍旧是 state.onwrite 函数。</div><div><br/></div><div><hr/></div><div><br/></div><div>继续看 afterWrite(stream, state, finished, cb) 的执行细节：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">function afterWrite(stream, state, finished, cb) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (!finished) // finished false</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    onwriteDrain(stream, state); // 走入这里</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  state.pendingcb—; // 完成一次 --</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  cb(); // nop</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  finishMaybe(stream, state); // 同样，因为此时 state.length 只是减去了一个 abc\n 的长度，仍旧没有变为 0；此函数不会执行什么逻辑</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">}</font><br/></div></div><div><br/></div><div>关于 onwriteDrain 函数：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">// Must force callback to be called on nextTick, so that we don't</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">// emit 'drain' before the write() consumer gets the 'false' return</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">// value, and has a chance to attach a 'drain' listener.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">function onwriteDrain(stream, state) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // 只有在 state.length === 0 且 state.needDrain 的情况下才会触发 drain 事件</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (state.length === 0 &amp;&amp; state.needDrain) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    state.needDrain = false;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    stream.emit('drain');</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  }</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">}</font><br/></div></div><div><br/></div><div><hr/></div><div><br/></div><div>总结：上面的一大段分析，都是第一次 state.onwrite 函数被触发时得调用逻辑，表明 “abc\n” 被顺利写入文件，且在 writeReq buffer 链表中，仍旧存在 3 个待写入的 chunk 节点，所以继续触发了 clearBuffer 函数的后续执行。clearBuffer 之后在改变了一系列状态之后，调用 fs 的底层实现 js 层级的 _writev 函数，在深入至 binding.writeBuffers 函数，最终一次性将剩余的 3 个 chunk 写入文件。并且之后等待回调函数被执行。根据分析可知，此回调函数仍旧是 state.onwrite。</div><div><br/></div><div>那么，为了继续追踪 fs.WriteStream.prototype._writev 函数，增加测试代码：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">// 为了跟踪 _writev 函数</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">var _writevOld = fs.WriteStream.prototype._writev;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">fs.WriteStream.prototype._writev = function () {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    var that = this;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    var cb = arguments[ 1 ];</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    arguments[ 1 ] = function ( er, bytes ) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">        debugger; // 让其在这里断住</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">        cb( er, bytes );</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    };</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    _writevOld.apply( that, arguments );</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">};</font><br/></div></div><div><br/></div><div>此时真正进入 _writev 的回调函数：</div><div><br/></div><div><img src="stream%20%E6%A8%A1%E5%9D%97%E6%B7%B1%E7%A9%B6%20-%207%20-%20Writable%20state.onwrite.resources/766186C5-FCDF-4D1B-A260-C831DF0C8CDB.png" height="auto" width="100%"/><br/></div><div><br/></div><div>如上图中的 cb 函数，即为 state.onwrite 函数，需要注意的是，此时进入当前回调函数，output.txt 中的内容已经是：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">abc</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">测试输出</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">from buffer</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">the end</font><br/></div></div><div><br/></div><div>即，全部已经写入文件了。在此次的 onwrite 函数执行中，内部的 onwriteStateUpdate(state) 函数将更新一些状态：</div><div><br/></div><div><img src="stream%20%E6%A8%A1%E5%9D%97%E6%B7%B1%E7%A9%B6%20-%207%20-%20Writable%20state.onwrite.resources/52B02103-DD82-44EE-A4D7-DDD8C5FB9BCF.png" height="auto" width="100%"/><br/></div><div><br/></div><div>可以看到：state.length 此时已经变成了 0；而且 state.onwrite 中的 needFinish(state) 将返回 true ，因此不会再次触发 clearBuffer 函数。最终在 state.onwrite 的最后阶段调用 afterWrite 函数：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">function afterWrite(stream, state, finished, cb) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  . . .</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  state.pendingcb--;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  cb(); // 注意这个 cb 为 state.writecb 也即 <font style="font-size: 12px; color: rgb(51, 51, 51);">CorkedRequest.finish(), _stream_writable.js:522 函数</font></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  finishMaybe(stream, state);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">}</font><br/></div></div><div><br/></div><div>来看 CorkedRequest.finish() 函数的调用：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>. . .</div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  this.finish = (err) =&gt; {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    // this 即为被赋予 holder 的 CorkedRequest 实例对象</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><span>    // this.entry 指向 bufferedRequest 中的第一个 chunk 节点</span><br/></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    var entry = this.entry;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    this.entry = null; // 置空，同时也会置空 state.bufferedRequest 为 null</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    while (entry) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      var cb = entry.callback;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      state.pendingcb--; // 逐减</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      cb(err); // 并且调用用户回调函数，不传的话就是 nop</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      entry = entry.next;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    }</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    // 走入第一个分支，此时的 state.corkedRequestsFree 已经被复原为初始值</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    if (state.corkedRequestsFree) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    <span>  // next 指向当前实例对象</span></span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      state.corkedRequestsFree.next = this;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    } else {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      state.corkedRequestsFree = this;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    }</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  };</font><br/></div><div>. . .</div></div><div><br/></div><div>在此进入 afterWrite 中的 finishMayBe 时，里面的 needFinish(state) 最终返回 true，表明这次是真的结束了：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">function finishMaybe(stream, state) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  var need = needFinish(state); // 最终返回 true</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (need) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    // 且，在 CorkedRequest.finish() 函数执行时，while 循环使得 state.pendingcb 递减最终归零</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    if (state.pendingcb === 0) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      prefinish(stream, state); // 触发一个 prefinish 事件 ==&gt; state.prefinished == true</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      state.finished = true; // 标记为 finished</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      stream.emit('finish’); // 触发 finish 事件</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    } else {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      prefinish(stream, state);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    }</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  }</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  return need;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">}</font><br/></div></div><div><br/></div><div>由上可见，finish 事件最终在 finishMaybe 中，被触发。</div><div><br/></div><div>关于 close 事件在什么时候被触发的？在 fs.WriteStream 实例对象被创建的时候，构造函数中有：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // dispose on finish.【上面已经说了在什么时候触发 finish 事件】</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  this.once('finish', function() {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    if (this.autoClose) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      this.close(); // 在这里 close</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    }</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  });</font><br/></div></div><div><br/></div><div>且，在 fs 模块代码中可以发现：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">WriteStream.prototype.destroy = ReadStream.prototype.destroy;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">WriteStream.prototype.close = ReadStream.prototype.close;</font><br/></div></div><div><br/></div><div>ReadStream.prototype.close 底层调用 fs.close 函数来处理文件的 close 操作，最终在 fs.close 的回调函数中触发了 close 事件，因此，close 的监听函数得以调用。</div><div><br/></div><div><br/></div><div><br/></div>

<hr class="tail-hr">
<div class="tail-licenses">
<p>版权声明：自由转载-非商用-非衍生-保持署名(<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">创意共享3.0许可证</a>)</p>
<p>文章作者：Pooky (<a href="mailto:guananddu@icloud.com">guananddu@icloud.com</a>)</p>
<p>更新日期：Tue Jan 10 2017 20:45:17 GMT+0800 (CST)</p>
</div></body></html>