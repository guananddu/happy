<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 6.10 (454267)"/><meta name="author" content="管伟"/><meta name="created" content="2016-12-01 09:22:24 +0000"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2016-12-24 10:21:53 +0000"/><title>timer 相关函数细节解析 - process.nextTick - 1</title></head><body><style>
    a { color: #43B0D6 !important; }
    a:visited { color: #7b7ed2 !important; }
    .title-p { font-size:12px; color:gray; }
    .title-hr { margin-bottom: 20px; }
    .tail-hr { margin-top: 20px; }
    .tail-licenses { border:1px dashed lightgray; margin:20px 0 20px 0; padding:20px; font-size:14px; }
</style>
<h2>timer 相关函数细节解析 - process.nextTick - 1</h2>
<p class="title-p">版权声明：自由转载-非商用-非衍生-保持署名(<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">创意共享3.0许可证</a>)</p>
<p class="title-p">文章作者：Pooky (<a href="mailto:guananddu@icloud.com">guananddu@icloud.com</a>)</p>
<hr class="title-hr"><div>严格意义上说，process.nextTick 不算和 timer 相关的函数；但是其用法和作用则和 setTimeout( func, 0 ) 类似，故此大节来分析其应用。</div><div><br/></div><div>process.nextTick 函数在 bootsrap_node.js 启动文件中被加载：<br/></div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-family: Monaco; font-size: 12px; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51);">NativeModule.require('internal/process/next_tick').setup();</font><br/></div></div><div><br/></div><div>此处的 setup 函数调用，主要是初始化／挂载各种钩子函数，看下整体调用流程：</div><div><br/></div><div><img src="timer%20%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E7%BB%86%E8%8A%82%E8%A7%A3%E6%9E%90%20-%20process.nextTick%20-%201.resources/9F77627A-F4F4-4C10-AD6A-60CB8D3DB0BA.png" height="auto" width="100%"/><br/></div><div><br/></div><div>比较重要的变量声明：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">var nextTickQueue = []; // nextTick 队列</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">var _runMicrotasks = {};</font></div></div><div><br/></div><div>之后挂载了 process.nextTick 及其两个私有函数。先来看一下启动过程中对：process._setupNextTick 函数的调用：</div><div><br/></div><div>其两个参数类型：_tickCallback 为回调函数类型；_runMicrotasks 为普通的空 {} 类型。</div><div><br/></div><div/><div style="box-sizing: border-box; padding: 8px; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">#0     0x000000010001e66f in node::SetupNextTick(v8::FunctionCallbackInfo&lt;v8::Value&gt; const&amp;) at /Users/mrguan/work/build/node/node-6.6.0/src/node.cc:1152</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><br/></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">void SetupNextTick(const FunctionCallbackInfo&lt;Value&gt;&amp; args) {</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  Environment* env = Environment::GetCurrent(args);</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span>  // 检查类型，第一个为函数；第二个为对象类型</span><br/></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  CHECK(args[0]-&gt;IsFunction());</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  CHECK(args[1]-&gt;IsObject());</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span>  // 为 env 设置属性：tick_callback_function 指向第一个参数</span><br/></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  env-&gt;set_tick_callback_function(args[0].As&lt;Function&gt;());</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span>  // 为 js 层级的第二个参数（即：_runMicrotasks ）设置一个 runMicrotasks 的属性指向一个 c++ 层次的函数</span><br/></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  env-&gt;SetMethod(args[1].As&lt;Object&gt;(), "runMicrotasks", RunMicrotasks);</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span>  // 在调用完毕 process._setupNextTick 函数之后删除此函数，放置重复调用</span><br/></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  // Do a little housekeeping.</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  env-&gt;process_object()-&gt;Delete(</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">      env-&gt;context(),</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">      FIXED_ONE_BYTE_STRING(args.GetIsolate(), "_setupNextTick")).FromJust();</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><br/></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  // Values use to cross communicate with processNextTick.</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  uint32_t* const fields = env-&gt;tick_info()-&gt;fields();</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  uint32_t const fields_count = env-&gt;tick_info()-&gt;fields_count();</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span>  // <font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">*fields     uint32_t     0</font></span><br/></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>  // <font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">fields_count     uint32_t     2</font></span><br/></font></span></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>  // 创建一个有两个字段大小，每个字段大小为32位（4字节），共8字节大小的 ArrayBuffer</span><br/></font></span></font></span></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  Local&lt;ArrayBuffer&gt; array_buffer =</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">      ArrayBuffer::New(env-&gt;isolate(), fields, sizeof(*fields) * fields_count);</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span>  // 最终返回到 js 层级的 Uint32Array 类型的 typedArray【注意看上方代码截图中 const tickInfo 的代码注释部分】</span><br/></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span><span>  // 此 Uint32Array 是用来 c++ &lt;==&gt; js 之间的通信用途</span><br/></span></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  args.GetReturnValue().Set(Uint32Array::New(array_buffer, 0, fields_count));</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">}</font><br/></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><br/></font></div><div><font face="Monaco">==</font></div><div><font face="Monaco"/></div><div><font face="Monaco">摘录：</font></div><div><font face="Monaco"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">enum Fields {</font></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  kIndex, 0</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  kLength, 1</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  kFieldsCount 2</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">};</font><font face="Monaco"><br/></font></div></div><div><br/></div><div>最终走完 setup() 流程，接下来从 process.nextTick 来解析调用细节。</div><div><br/></div><div><hr/></div><div><br/></div><div>process.nextTick 最终走入：internal/process/next_tick.js 中的：</div><div><br/></div><div/><div style="box-sizing: border-box; padding: 8px; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  function nextTick(callback) {</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    if (typeof callback !== 'function')</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">      throw new TypeError('callback is not a function');</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    // on the way out, don't bother. it won't get fired anyway.</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    if (process._exiting)</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">      return;</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><br/></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    var args; // 将多余参数放入另外的Array中去</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    if (arguments.length &gt; 1) {</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">      args = new Array(arguments.length - 1);</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">      for (var i = 1; i &lt; arguments.length; i++)</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">        args[i - 1] = arguments[i];</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    }</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span>    // 最终将新创建的 TickObject 对象 push 入队列</span><br/></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    nextTickQueue.push(new TickObject(callback, args));</font></div><div><font face="Monaco, Menlo, Consolas, Courier New, monospace">    // 注意这里 </font><font face="Monaco">kLength === <font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">1</font></font><br/></div><div><font face="Monaco"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>    // tickInfo 的 tickInfo[ 1 ] 这个值用来记录 nextTickQueue 中 TickObject 的数量</span><br/></font></font></div><div><font face="Monaco"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span><span>    // 也不全是，见下面截图表述</span><br/></span></font></font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    tickInfo[kLength]++;</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  }</font><br/></div><div><font face="Monaco">// tickInfo 的作用</font></div><div><font face="Monaco"><br/></font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><img src="timer%20%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E7%BB%86%E8%8A%82%E8%A7%A3%E6%9E%90%20-%20process.nextTick%20-%201.resources/FB41E7A9-CD5C-40AD-9EB0-92EA166ADA6B.png" height="auto" width="100%"/><br/></font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><br/></font></div><div><font face="Monaco">// tickInfo 只记录了两个元素【用户自主添加的 TickObject】，但是 nextTickQueue 却有 4 个元素</font></div><div><font face="Monaco"><br/></font></div><div><font face="Monaco"><img src="timer%20%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E7%BB%86%E8%8A%82%E8%A7%A3%E6%9E%90%20-%20process.nextTick%20-%201.resources/2EFF7FBD-ACB0-4B3A-B8CB-8BB9B0AC76C0.png" height="auto" width="100%"/><br/></font></div><div><font face="Monaco"><br/></font></div></div><div><br/></div><div>TickObject 的初始化，比较简单：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  function TickObject(c, args) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>    // c 即为回调函数引用，被设置为 this.callback 属性</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    this.callback = c;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    this.domain = process.domain || null;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    this.args = args;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  }</font><br/></div></div><div><br/></div><div><hr/></div><div><br/></div><div>插曲，因为是调试模式下，所以，第一个 tick 下插入的 process.nextTick 回调的执行比较特殊，直接是在 js 层次来触发的，再次细细查看 bootstrap_node.js 启动文件可知其执行流，进入流程：</div><div><br/></div><div/><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>. . .</div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    } else {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>    <span>  // 常规情况下，用户的业务代码会进入此处的分支逻辑来执行</span></span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">      // There is user code to be run</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">      . . .</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">      if (process._eval != null &amp;&amp; !process._forceRepl) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">        // User passed '-e' or '--eval' arguments to Node without '-i' or</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">        // '--interactive'</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">        . . .</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">      } else if (process.argv[1]) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>    <span>    // 最终走入这里，process.argv[ 1 ] 参数即为 node 的用户启动文件</span></span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">        // make process.argv[1] into a full path</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">        var path = NativeModule.require('path’);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>    <span>    // 修正化最终的启动文件的位置信息</span></span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">        process.argv[1] = path.resolve(process.argv[1]);</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">        var Module = NativeModule.require('module');</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">        . . .</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">        preloadModules();</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>    <span>    // 最终调用这里</span></span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">        run(Module.runMain);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">      } else {</font><br/></div><div>. . .</div></div><div><br/></div><div>来看下 run 函数是什么：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  function run(entryFunction) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>    // 调试状态下，会进入第一个分支，注释说明很清楚</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    if (process._debugWaitConnect &amp;&amp; isDebugBreak()) {</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">      // XXX Fix this terrible hack!</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">      //</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">      // Give the client program a few ticks to connect.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">      // Otherwise, there's a race condition where `node debug foo.js`</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">      // will not be able to connect in time to catch the first</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">      // breakpoint message on line 1.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">      //</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">      // A better fix would be to somehow get a message from the</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">      // V8 debug object about a connection, and runMain when</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">      // that occurs.  --isaacs</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">      var debugTimeout = +process.env.NODE_DEBUG_TIMEOUT || 50;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>    <span>  // 这就是调试状态下为什么会出现timer回调的原因</span></span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">      setTimeout(entryFunction, debugTimeout);</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    } else {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">      // Main entry point into most programs:</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">      entryFunction();</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    }</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  }</font><br/></div></div><div><br/></div><div>如下图的执行调用栈：</div><div><br/></div><div><img src="timer%20%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E7%BB%86%E8%8A%82%E8%A7%A3%E6%9E%90%20-%20process.nextTick%20-%201.resources/C87E78D2-4DE0-4D19-9463-A795CD1A7DC8.png" height="auto" width="100%"/><br/></div><div><br/></div><div>最终，Module.runMain 函数在 timer 的调度下被执行：</div><div><br/></div><div><img src="timer%20%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E7%BB%86%E8%8A%82%E8%A7%A3%E6%9E%90%20-%20process.nextTick%20-%201.resources/F0A463D0-5A91-4350-8185-2687768F48C6.png" height="auto" width="100%"/><br/></div><div><br/></div><div>此时的执行，仅仅是 Module._load 的函数执行（开始执行入口文件逻辑），当所有的入口文件逻辑执行完毕之后，最终进入：process._tickCallback() 回调函数，此函数就像其注释的那样子：Handle any nextTicks added in the first tick of the program.</div><div><br/></div><div>因此，在真正看到用户回调被调用的时候：</div><div><br/></div><div><img src="timer%20%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E7%BB%86%E8%8A%82%E8%A7%A3%E6%9E%90%20-%20process.nextTick%20-%201.resources/580F0706-E22A-4424-BCA6-F0DFD348584B.png" height="auto" width="100%"/><br/></div><div><br/></div><div>会看到这样的调用栈：</div><div><br/></div><div><img src="timer%20%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E7%BB%86%E8%8A%82%E8%A7%A3%E6%9E%90%20-%20process.nextTick%20-%201.resources/0FC765E8-8183-46EF-B8BF-FDA83D529A49.png" height="auto" width="100%"/><br/></div><div><br/></div><div>即，用户回调，最终被 Module.runMain() 的 line 592 行调用，592 行就是 process._tickCallback()，来看此函数的具体内容：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  // Run callbacks that have no domain.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  // Using domains will cause this to be overridden.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  function _tickCallback() {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    var callback, args, tock;</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    do {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>    <span>  // tickInfo[ kIndex ] 是当前的 nextTickQueue 索引</span></span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span><span><span>    <span>  // tickInfo[ kLength ] 是目前 nextTickQueue 中的元素个数</span></span><br/></span></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">      while (tickInfo[kIndex] &lt; tickInfo[kLength]) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>    <span>    // 取到当前的 tickObject</span></span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">        tock = nextTickQueue[tickInfo[kIndex]++];</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">        callback = tock.callback;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">        args = tock.args;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">        // Using separate callback execution functions allows direct</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">        // callback invocation with small numbers of arguments to avoid the</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">        // performance hit associated with using `fn.apply()`</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>    <span>    // 这里是最终回调函数被调用的地方</span></span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span><span><span>    <span>    // 需要注意的地方，在回调调用的地方，也可能会有新的 tickObject 被加入</span></span><br/></span></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">        _combinedTickCallback(args, callback);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">        if (1e4 &lt; tickInfo[kIndex])</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">          tickDone();</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">      }</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">      tickDone();</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>    <span>  // 这个 _runMicrotasks 会直接调用 v8 的 api</span></span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">      _runMicrotasks();</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">      emitPendingUnhandledRejections(); // 此函数不再过多描述</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    } while (tickInfo[kLength] !== 0);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  }</font><br/></div></div><div><br/></div><div>tickDone 的操作主要是归零操作：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  function tickDone() {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    if (tickInfo[kLength] !== 0) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>    <span>  // 一半会走入此分支</span></span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">      if (tickInfo[kLength] &lt;= tickInfo[kIndex]) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>    <span>    // 最终 nextTickQueue 会归零</span></span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">        nextTickQueue = [];</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>    <span>    // 长度归零</span></span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">        tickInfo[kLength] = 0;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">      } else {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">        nextTickQueue.splice(0, tickInfo[kIndex]);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">        tickInfo[kLength] = nextTickQueue.length;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">      }</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    }</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>    // 索引归零</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    tickInfo[kIndex] = 0;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  }</font><br/></div></div><div><br/></div><div>有关上述 _runMicrotasks() 的详细描述，不在讨论范围内，参见：<a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/">https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/</a></div><div><br/></div><div>总结就是：</div><div><br/></div><div><img src="timer%20%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E7%BB%86%E8%8A%82%E8%A7%A3%E6%9E%90%20-%20process.nextTick%20-%201.resources/56721DF3-2937-4991-9675-C7C342F3FBC9.png" height="auto" width="100%"/><br/></div><div><br/></div><div/><div/>

<hr class="tail-hr">
<div class="tail-licenses">
<p>版权声明：自由转载-非商用-非衍生-保持署名(<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">创意共享3.0许可证</a>)</p>
<p>文章作者：Pooky (<a href="mailto:guananddu@icloud.com">guananddu@icloud.com</a>)</p>
<p>更新日期：Sat Dec 24 2016 19:20:16 GMT+0800 (CST)</p>
</div></body></html>