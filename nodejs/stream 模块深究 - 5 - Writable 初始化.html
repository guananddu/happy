<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 6.10 (454267)"/><meta name="author" content="管伟"/><meta name="created" content="2017-01-07 07:53:04 +0000"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2017-01-08 07:09:47 +0000"/><title>stream 模块深究 - 5 - Writable 初始化</title></head><body><style>
    a { color: #43B0D6 !important; }
    a:visited { color: #7b7ed2 !important; }
    .title-p { font-size:12px; color:gray; }
    .title-hr { margin-bottom: 20px; }
    .tail-hr { margin-top: 20px; }
    .tail-licenses { border:1px dashed lightgray; margin:20px 0 20px 0; padding:20px; font-size:14px; }
</style>
<h2>stream 模块深究 - 5 - Writable 初始化</h2>
<p class="title-p">版权声明：自由转载-非商用-非衍生-保持署名(<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">创意共享3.0许可证</a>)</p>
<p class="title-p">文章作者：Pooky (<a href="mailto:guananddu@icloud.com">guananddu@icloud.com</a>)</p>
<hr class="title-hr"><div>从本节开始探讨与 stream.Readable 相对应的 stream.Writable，关于 stream.Readable 我们已经讨论得比较详细，关于 Readable 的相关实现细节可以参看前几节。本节先来看 stream.Writable 的初始化，来看测试代码：</div><div><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'Menlo';font-size:13.5pt;"><span style="color:#cc7832;font-weight:bold;">const </span>fs = require( <span style="color:#6a8759;">'fs' </span>)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;font-weight:bold;">const </span>path = require( <span style="color:#6a8759;">'path' </span>)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;font-weight:bold;">const </span>stream = require( <span style="color:#6a8759;">'stream' </span>)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;"><br/></span><span style="color:#cc7832;font-weight:bold;">const </span>filePath = path.<span style="color:#ffc66d;">resolve</span>( __dirname<span style="color:#cc7832;">, </span><span style="color:#6a8759;">'output.txt' </span>)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;"><br/></span><span style="color:#cc7832;font-weight:bold;">const </span>writeable = fs.<span style="color:#ffc66d;">createWriteStream</span>( filePath<span style="color:#cc7832;">, </span>{<br/>    <span style="color:#9876aa;">defaultEncoding</span>: <span style="color:#6a8759;">'utf8'<br/></span>} )<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;"><br/></span>writeable.<span style="color:#ffc66d;">on</span>( <span style="color:#6a8759;">'close'</span><span style="color:#cc7832;">, </span>o =&gt; {<br/>    <span style="color:#9876aa;">console</span>.<span style="color:#ffc66d;">log</span>( <span style="color:#6a8759;">'close event!'</span><span style="color:#cc7832;">, </span>o )<span style="color:#cc7832;">;<br/></span>} )<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;"><br/></span>writeable.<span style="color:#ffc66d;">on</span>( <span style="color:#6a8759;">'finish'</span><span style="color:#cc7832;">, </span>o =&gt; {<br/>    <span style="color:#9876aa;">console</span>.<span style="color:#ffc66d;">log</span>( <span style="color:#6a8759;">'finish event!'</span><span style="color:#cc7832;">, </span>o )<span style="color:#cc7832;">;<br/></span>} )<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;"><br/></span>writeable.<span style="color:#ffc66d;">write</span>( <span style="color:#6a8759;">'abc</span><span style="color:#cc7832;">\n</span><span style="color:#6a8759;">' </span>)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;"><br/></span>writeable.<span style="color:#ffc66d;">cork</span>()<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;"><br/></span>writeable.<span style="color:#ffc66d;">write</span>( <span style="color:#6a8759;">'测试输出</span><span style="color:#cc7832;">\n</span><span style="color:#6a8759;">' </span>)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;"><br/></span>writeable.<span style="color:#ffc66d;">uncork</span>()<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;"><br/></span>writeable.<span style="color:#ffc66d;">write</span>( Buffer.<span style="color:#ffc66d;">from</span>( <span style="color:#6a8759;">'from buffer</span><span style="color:#cc7832;">\n</span><span style="color:#6a8759;">' </span>) )<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;"><br/></span>writeable.<span style="color:#ffc66d;">end</span>( <span style="color:#6a8759;">'the end' </span>)<span style="color:#cc7832;">;</span>
</pre>此节主要关注 writable 的初始化细节，为了便于理解其概念，仍旧探讨 fs 模块中的实现：fs.createWriteStream 函数。</div><div><br/></div><div>在 fs.createWriteStream 函数内部，将直接 return new WriteStream( xxx, xxx ) ，来看 WriteStream 的实现：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">util.inherits(WriteStream, Writable); // <font style="font-size: 12px; color: rgb(51, 51, 51);">const Writable = Stream.Writable; 继承关系</font></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">function WriteStream(path, options) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  . . . // 主要是关于 options 的类型判断等等</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  options = Object.create(options); // “派生”一个新的 options 配置对象</font></div><div><span>  // 调用父类构造函数，见下分析</span><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  Writable.call(this, options);</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  this.path = path; // 即为 writable 的输出文件路径</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  . . . // fd/flags/mode</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  . . .</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  . . . // 处理 this.start 逻辑</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (options.encoding)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    this.setDefaultEncoding(options.encoding); // 仍旧是设置 this._writableState.defaultEncoding 的具体值</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (typeof this.fd !== 'number’) // null</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    this.open(); // 进入执行，见下分析</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // dispose on finish. // 绑定一个一次性的 finish 事件监听器</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  this.once('finish', function() {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    if (this.autoClose) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      this.close();</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    }</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  });</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">}</font><br/></div></div><div><br/></div><div>关于 Writable.call(this, options) 的调用分析（进入 node/lib/_stream_writable.js 源代码文件）：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">function Writable(options) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  . . .</span>  </font></div><div><span>  // writable 也会有一个自己的内部状态对象，见下分析</span><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  this._writableState = new WritableState(options, this);</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // legacy.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  this.writable = true; // 遗留标识</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (options) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    if (typeof options.write === 'function')</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      this._write = options.write; // 可以通过 write 属性来复写 _write 底层函数</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    if (typeof options.writev === 'function')</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      this._writev = options.writev; // 同理 writev 函数同理</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  }</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  Stream.call(this); // EventEmiter.call( this ) 继承 Event 特性</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">}</font><br/></div></div><div><br/></div><div>来看 WritableState 对象的初始化【部分初始化代码被省略掉】：</div><div><br/></div><div/><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">function WritableState(options, stream) {</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  options = options || {};</font></div><div style="color: rgb(51, 51, 51);"><br/></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  // object stream flag to indicate whether or not this stream</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  // contains buffers or objects.</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  this.objectMode = !!options.objectMode;</font></div><div style="color: rgb(51, 51, 51);"><br/></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  . . .</font></div><div style="color: rgb(51, 51, 51);"><br/></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  // the point at which write() starts returning false</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  // Note: 0 is a valid value, means that we always return false if</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  // the entire buffer is not flushed immediately on write()</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  var hwm = options.highWaterMark;</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // 同样涉及 highWaterMark 的设置，正常模式默认值为 16kb</span><br/></font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  var defaultHwm = this.objectMode ? 16 : 16 * 1024;</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;</font></div><div style="color: rgb(51, 51, 51);"><br/></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  // cast to ints.</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  this.highWaterMark = ~~this.highWaterMark;</font></div><div style="color: rgb(51, 51, 51);"><br/></div><div style="color: rgb(51, 51, 51);"><span>  // needDrain/ending/ended/finished 等的初始化</span><br/></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  . . .</font></div><div style="color: rgb(51, 51, 51);"><br/></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  // should we decode strings into buffers before passing to _write?</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  // this is here so that some node-core streams can optimize string</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  // handling at a lower level.</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  var noDecode = options.decodeStrings === false;</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  this.decodeStrings = !noDecode;</font></div><div style="color: rgb(51, 51, 51);"><br/></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  // Crypto is kind of old and crusty.  Historically, its default string</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  // encoding is 'binary' so we have to make this configurable.</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  // Everything else in the universe uses 'utf8', though.</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  this.defaultEncoding = options.defaultEncoding || 'utf8’; // 默认编码</font></div><div style="color: rgb(51, 51, 51);"><br/></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  // not an actual buffer we keep track of, but a measurement</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  // of how much we're waiting to get pushed to some underlying</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  // socket or file.</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  this.length = 0; // 注意这个变量</font></div><div style="color: rgb(51, 51, 51);"><br/></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  . . . // 一系列状态值的初始化</font></div><div style="color: rgb(51, 51, 51);"><br/></div><div><font style="color: rgb(51, 51, 51); font-size: 12px;">  // </font><font style="font-size: 12px;" color="#ff2600">the callback that's passed to _write(chunk,cb)</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  this.onwrite = function(er) {</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">    onwrite(stream, er);</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  };</font></div><div style="color: rgb(51, 51, 51);"><br/></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  // the callback that the user supplies to write(chunk,encoding,cb)</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  this.writecb = null;</font></div><div style="color: rgb(51, 51, 51);"><br/></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  // the amount that is being written when _write is called.</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  this.writelen = 0;</font></div><div style="color: rgb(51, 51, 51);"><br/></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  this.bufferedRequest = null;</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  this.lastBufferedRequest = null;</font></div><div style="color: rgb(51, 51, 51);"><br/></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  // number of pending user-supplied write callbacks</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  // this must be 0 before 'finish' can be emitted</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  this.pendingcb = 0;</font></div><div style="color: rgb(51, 51, 51);"><br/></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  . . .</font></div><div style="color: rgb(51, 51, 51);"><br/></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  // count buffered requests</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  this.bufferedRequestCount = 0;</font></div><div style="color: rgb(51, 51, 51);"><br/></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  // allocate the first CorkedRequest, there is always</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  // one allocated and free to use, and we maintain at most two</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  this.corkedRequestsFree = new CorkedRequest(this);</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">}</font><br/></div></div><div><br/></div><div>来看关于 CorkedRequest 的初始化动作（具体作用是什么随后具体分析）：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">// It seems a linked list but it is not</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">// there will be only 2 of these for each stream</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">function CorkedRequest(state) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  this.next = null;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  this.entry = null;</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  this.finish = (err) =&gt; {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    var entry = this.entry;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    this.entry = null;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    while (entry) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      var cb = entry.callback;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      state.pendingcb--;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      cb(err);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      entry = entry.next;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    }</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    if (state.corkedRequestsFree) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      state.corkedRequestsFree.next = this;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    } else {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      state.corkedRequestsFree = this;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    }</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  };</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">}</font><br/></div></div><div><br/></div><div><hr/></div><div><br/></div><div>关于 WritStream.prototype.open 函数的具体实现细节：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">WriteStream.prototype.open = function() {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  fs.open(this.path, this.flags, this.mode, function(er, fd) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    if (er) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      . . .</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      return;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    }</font></div><div><span>    // 记录文件描述符</span><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    this.fd = fd;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    this.emit('open', fd); // 触发 open 事件</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  }.bind(this));</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">};</font><br/></div></div><div><br/></div><div>最终进入 fs 模块的 open 函数：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">fs.open = function(path, flags, mode, callback_) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  var callback = makeCallback(arguments[arguments.length - 1]); // 回到函数处理</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  mode = modeNum(mode, 0o666);</font></div><div><span>  // 检查 path 中是不是有 null bytes</span><br/></div><div><span><span>  // <font style="font-size: 12px; color: rgb(51, 51, 51);">('' + path).indexOf('\u0000') !== -1 的话就会报错</font></span><br/></span></div><div><span><span><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // <font style="font-size: 12px; color: rgb(51, 51, 51);">Path must be a string without null bytes</font></span><br/></font></span></span></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (!nullCheck(path, callback)) return; </font></div><div><span>  </span><br/></div><div><span><span>  // 具体 fs 模块的 c++ binding 实现不再深究，之后有专门章节描述 fs 模块相关函数</span><br/></span></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  var req = new FSReqWrap();</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  req.oncomplete = callback; // 绑定回调函数</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  binding.open(pathModule._makeLong(path),</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">               stringToFlags(flags),</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">               mode,</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">               req);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">};</font><br/></div></div><div><br/></div><div>Writable 的初始化分析完毕，下一节分析示例当中的具体函数调用流程。</div><div><br/></div>

<hr class="tail-hr">
<div class="tail-licenses">
<p>版权声明：自由转载-非商用-非衍生-保持署名(<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">创意共享3.0许可证</a>)</p>
<p>文章作者：Pooky (<a href="mailto:guananddu@icloud.com">guananddu@icloud.com</a>)</p>
<p>更新日期：Sun Jan 08 2017 15:12:07 GMT+0800 (CST)</p>
</div></body></html>