<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 6.10 (454267)"/><meta name="author" content="管伟"/><meta name="created" content="2016-12-29 07:23:21 +0000"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2016-12-29 10:28:17 +0000"/><title>string_decoder 模块详解</title></head><body><style>
    a { color: #43B0D6 !important; }
    a:visited { color: #7b7ed2 !important; }
    .title-p { font-size:12px; color:gray; }
    .title-hr { margin-bottom: 20px; }
    .tail-hr { margin-top: 20px; }
    .tail-licenses { border:1px dashed lightgray; margin:20px 0 20px 0; padding:20px; font-size:14px; }
</style>
<h2>string_decoder 模块详解</h2>
<p class="title-p">版权声明：自由转载-非商用-非衍生-保持署名(<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">创意共享3.0许可证</a>)</p>
<p class="title-p">文章作者：Pooky (<a href="mailto:guananddu@icloud.com">guananddu@icloud.com</a>)</p>
<hr class="title-hr"><div>string_decoder 模块在 Buffer 及 Stream 中的应用非常多，所以先来分析一下这个有意思的小模块，见官方实例：</div><div><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'Menlo';font-size:13.5pt;"><span style="color:#808080;">// In the following example, the three UTF-8 encoded bytes of<br/></span><span style="color:#808080;">// the European Euro symbol (€) are written over three separate operations:<br/></span><span style="color:#808080;"><br/></span><span style="color:#cc7832;font-weight:bold;">const </span>StringDecoder = require( <span style="color:#6a8759;">'string_decoder' </span>).<span style="color:#ffc66d;">StringDecoder</span><span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;font-weight:bold;">const </span>decoder = <span style="color:#cc7832;font-weight:bold;">new </span>StringDecoder( <span style="color:#6a8759;">'utf8' </span>)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;"><br/></span>decoder.<span style="color:#ffc66d;">write</span>( Buffer.<span style="color:#ffc66d;">from</span>( [ <span style="color:#6897bb;">0xE2 </span>] ) )<span style="color:#cc7832;">;<br/></span>decoder.<span style="color:#ffc66d;">write</span>( Buffer.<span style="color:#ffc66d;">from</span>( [ <span style="color:#6897bb;">0x82 </span>] ) )<span style="color:#cc7832;">;<br/></span><span style="color:#9876aa;">console</span>.<span style="color:#ffc66d;">log</span>( decoder.<span style="color:#ffc66d;">end</span>( Buffer.<span style="color:#ffc66d;">from</span>( [ <span style="color:#6897bb;">0xAC </span>] ) ) )<span style="color:#cc7832;">;</span>
</pre></div><div>按照文档的说法：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">When a Buffer instance is written to the StringDecoder instance, an internal buffer is used to ensure that the decoded string does not contain any incomplete multibyte characters. These are held in the buffer until the next call to stringDecoder.write() or until stringDecoder.end() is called.</font><br/></div></div><div><br/></div><div>string_decoder 的会通过 internal buffer 来保证输出多字节字符的完整性。</div><div><br/></div><div>来看构造函数的调用，new StringDecoder( 'utf8' )：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">function StringDecoder(encoding) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // 确保输入的编码字符串是正确无误的</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  this.encoding = normalizeEncoding(encoding);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  var nb;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  switch (this.encoding) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    case 'utf16le':</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      . . .</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    // 只以 utf8 编码为例</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    case 'utf8’:</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    <span>  // 指向一个内部函数</span></span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      this.fillLast = utf8FillLast;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>      // 需要的最大字节大小</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      nb = 4;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      break;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    . . .</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  }</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  this.lastNeed = 0;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  this.lastTotal = 0;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // 创建一个 internal Buffer <font style="font-size: 12px; color: rgb(51, 51, 51);">Uint8Array[4]</font></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  this.lastChar = Buffer.allocUnsafe(nb);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">}</font><br/></div></div><div><br/></div><div>上述构造函数主要做的工作：1⃣️确认编码设置无误；2⃣️设置 fillLast 函数指针；3⃣️初始化 internal buffer 实例对象；</div><div><br/></div><div>继续往下走，看 decoder.write 函数的调用（ StringDecoder.prototype.write ），首先是上述测试代码中的第一个 write 调用：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">StringDecoder.prototype.write = function(buf) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // buf: Uint8Array[1]</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><span>  // buf[0] == 226 [0xE2]</span><br/></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><span><span>  // buf.byteLength == 1</span><br/></span></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><span><span>  // buf.length == 1</span></span></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (buf.length === 0)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    return '';</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  var r;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  var i;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // 第一次进来为 0</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (this.lastNeed) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    r = this.fillLast(buf);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    if (r === undefined)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      return '';</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    i = this.lastNeed;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    this.lastNeed = 0;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  } else {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    i = 0;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  }</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // 走入下列分支 r === undefined</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><span>  // 所以继续走入 this.text( buf, i ) 调用</span><br/></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (i &lt; buf.length)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    return (r ? r + this.text(buf, i) : this.text(buf, i));</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  return r || '';</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">};</font><br/></div></div><div><br/></div><div>上述代码中的 this.text 指向一个内部函数：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>StringDecoder.prototype.text = utf8Text;</div></div><div><br/></div><div>来看看 utf8Text 具体怎么调用：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">// partial character, the character's bytes are buffered until the required</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">// number of bytes are available.【注意这里的注释】</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">function utf8Text(buf, i) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // buf, i === 0</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><span>  // total 是最后一个字符总字节长度</span><br/></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  const total = utf8CheckIncomplete(this, buf, i);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // 如果输入 buf 的最后一个字节已经完整，则直接 toString 返回</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (!this.lastNeed)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    return buf.toString('utf8', i);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // 记录总字节长</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  this.lastTotal = total;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // buf.length == 1</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><span>  // end == ( 1 - ( 3 - 2 ) ) == 0</span><br/></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  const end = buf.length - (total - this.lastNeed);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // this.lastChar 即为 internal buffer 的指针</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><span>  // buf.copy 是一个 c++ 底层函数，参数定义为：</span><br/></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><span>  // <font style="font-size: 12px; color: rgb(51, 51, 51);">CHECK_NOT_OOB(ParseArrayIndex(args[1], 0, &amp;target_start));</font></span></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // CHECK_NOT_OOB(ParseArrayIndex(args[2], 0, &amp;source_start));</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // CHECK_NOT_OOB(ParseArrayIndex(args[3], ts_obj_length, &amp;source_end));</font><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><span/><br/></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  buf.copy(this.lastChar, 0, end);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // buf.toString 参数定义为：<font style="font-size: 12px; color: rgb(51, 51, 51);">buf.toString([encoding[, start[, end]]])</font></span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // 关于 end: <font style="font-size: 12px; color: rgb(51, 51, 51);">end &lt;Integer&gt; The byte offset to stop decoding at (not inclusive【不包括】). Default: buf.length</font></span><br/></font></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // 当 end === 0 时， Buffer.toString 直接返回空字符串</span><br/></font></span></font></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><span>  // 详见 Buffer 模块中的内部函数：slowToString 函数调用</span><br/></span></font></span></font></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><span><span>  // 🌟 故，第一次调用 StringDecoder.prototype.write( 0xE2 ) 直接返回空字符串，因为当前 utf8 字符编码还未结束</span></span></span></font></span></font></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  return buf.toString('utf8', i, end);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">}</font><br/></div></div><div><br/></div><div>【插曲】utf8CheckIncomplete 函数会检查目前多字节字符编码是不是已经完整，回忆一下 Unicode 采用 utf-8 编码的规范：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">Unicode符号范围      | UTF-8编码方式</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">(十六进制)           | （二进制）</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">--------------------+---------------------------------------------</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">0000 0000-0000 007F | 【单字节】0xxxxxxx</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">0000 0080-0000 07FF | 【双字节】110xxxxx 10xxxxxx</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">0000 0800-0000 FFFF | 【三字节】1110xxxx 10xxxxxx 10xxxxxx</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">0001 0000-0010 FFFF | 【四字节】11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</font></div></div><div><br/></div><div>故，若某字节是 0 开头，则可以确定一定是单字节 utf8 字符；11 开头为双字节开始；111 开头为三字节开始；1111 为四字节开始；而 10 开头，则肯定是编码中间某字节或者最后一个字节。</div><div><br/></div><div>来看 utf8CheckIncomplete 函数调用，第一次调用传入的是 0xE2( 1110 0010 ) 可知其为三字节 utf8 编码开始字节：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">// Checks at most 3 bytes at the end of a Buffer in order to detect an</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">// needed to complete the UTF-8 character (if applicable) are returned.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">function utf8CheckIncomplete(self, buf, i) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // 检查传入 buf 的最后一个字节状态</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  var j = buf.length - 1;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (j &lt; i)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    return 0;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // 注意此函数【第一次 nb == 3】</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  var nb = utf8CheckByte(buf[j]);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (nb &gt;= 0) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    if (nb &gt; 0)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    <span>  // lastNeed 记录还需要几个字节长</span></span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      self.lastNeed = nb - 1;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    // 返回总字节长</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    return nb;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  }</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  . . .</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">}</font><br/></div></div><div><br/></div><div>✨来看核心判断逻辑：utf8CheckByte：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">// continuation byte.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">function utf8CheckByte(byte) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // 0x7F == 0111 1111 【符合单字节 utf8 编码规范，直接返回 0】</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (byte &lt;= 0x7F)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    return 0;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // 0x06 == 0000 0110 【符合双字节开始规范】</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  else if (byte &gt;&gt; 5 === 0x06)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    return 2;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // 0x0E == 0000 1110 【符合三字节开始规范】</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  else if (byte &gt;&gt; 4 === 0x0E)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    return 3;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // 0x1E == 0001 1110 【符合四字节开始规范】</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  else if (byte &gt;&gt; 3 === 0x1E)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    return 4;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // 都不符合，则为中间未结束状态，等待继续 write</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  return -1;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">}</font><br/></div></div><div><br/></div><div>如上代码分析，第一次输入的是 0xE6 == 1110 0110 为三字节开始字节，所以仍旧需要写入自己的 internal buffer 等待完整性判断。</div><div><br/></div><div><hr/></div><div><br/></div><div>总结第一次调用：</div><div><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'Menlo';font-size:13.5pt;"><span style="background-color:#344134;">decoder</span>.<span style="color:#ffc66d;">write</span>( Buffer.<span style="color:#ffc66d;">from</span>( [ <span style="color:#6897bb;">0xE2 </span>] ) )<span style="color:#cc7832;">;</span>
</pre>时，此句代码返回空字符串，并且因为 0xE2 为三字节字符的开始字节（高位字节），解码工作还未结束，所以不能输出任何字符。但是，此时已经把 0xE2 存入 decoder 中的 internal buffer 中，等待后续 write 的继续调用。</div><div><br/></div><div>开始第二次调用（0x82 == 1000 0010）：</div><div><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'Menlo';font-size:13.5pt;"><span style="background-color:#344134;">decoder</span>.<span style="color:#ffc66d;">write</span>( Buffer.<span style="color:#ffc66d;">from</span>( [ <span style="color:#6897bb;">0x82 </span>] ) )<span style="color:#cc7832;">;</span></pre></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">StringDecoder.prototype.write = function(buf) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (buf.length === 0)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    return '';</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  var r;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  var i;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // 第二次调用则会有 lastNeed 这个变量</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><span>  // this.lastNeed === 2</span><br/></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><span><span>  // this.lastTotal === 3</span><br/></span></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (this.lastNeed) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    // 走入 fillLast 函数</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    r = this.fillLast(buf);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    if (r === undefined)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      return '';</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    i = this.lastNeed;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    this.lastNeed = 0;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  } else </font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    . . .</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><span>  . . .</span><br/></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">};</font><br/></div></div><div><br/></div><div>来看进入的 this.fillLast 函数：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">function utf8FillLast(buf) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // 第2次：p == ( 3 - 2 ) == 1</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  const p = this.lastTotal - this.lastNeed;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // 此函数不再赘述，抽出其注释来看就知道是做什么了：</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><span>  <font style="font-size: 12px; color: rgb(51, 51, 51);">// Validates as many continuation bytes for a multi-byte UTF-8 character as</font></span></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // needed or are available. If we see a non-continuation byte where we expect</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // one, we "replace" the validated continuation bytes we've seen so far with</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // UTF-8 replacement characters ('\ufffd'), to match v8's UTF-8 decoding</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // behavior. The continuation byte check is included three times in the case</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // where all of the continuation bytes for a character exist in the same buffer.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // It is also done this way as a slight performance increase instead of using a</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // loop.</font><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><span/><br/></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  var r = utf8CheckExtraBytes(this, buf, p);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (r !== undefined)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    return r;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // 如果传入的 buf 已经足够弥合剩余所需的字节长，则直接 copy 完毕然后返回 toString() 结果</span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (this.lastNeed &lt;= buf.length) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    buf.copy(this.lastChar, p, 0, this.lastNeed);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    return this.lastChar.toString(this.encoding, 0, this.lastTotal);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  }</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // 否则再次 copy 第二个 0x82 字节给 internal buffer</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  buf.copy(this.lastChar, p, 0, buf.length);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // 修正 lastNeed</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  this.lastNeed -= buf.length;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">}</font><br/></div></div><div><br/></div><div>总结，在第二次调用 StringDecoder.prototype.write( 0x82 ) 之后，其中的：r = this.fillLast( buf ) 仍旧返回 undefined ，故第二次 write 仍旧返回空字符串。</div><div><br/></div><div><hr/></div><div><br/></div><div>第三次调用：</div><div><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'Menlo';font-size:13.5pt;">decoder.<span style="color:#ffc66d;">end</span>( Buffer.<span style="color:#ffc66d;">from</span>( [ <span style="color:#6897bb;">0xAC </span>] ) )
</pre>直接调用了 StringDecoder.prototype.end = utf8End 函数：</div><div><br/></div><div/><div style="box-sizing: border-box; padding: 8px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">// For UTF-8, a replacement character for each buffered byte of a (partial)</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">// character needs to be added to the output.</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">function utf8End(buf) {</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // 首先进入 this.write 函数调用</span></font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><span>  // <font style="font-size: 12px; color: rgb(51, 51, 51);">见下分析 最终 r === "€"</font></span><br/></span></font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">  const r = (buf &amp;&amp; buf.length ? this.write(buf) : '’);</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // this.lastNeed 已经归 0</span><br/></font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (this.lastNeed)</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">    return r + '\ufffd'.repeat(this.lastTotal - this.lastNeed);</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">  return r;</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">}</font><br/></div></div><div><br/></div><div>第三次的 write 调用：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>this.fillLast( buf ) 调用：</div><div>. . .</div><div><span>  // 完成最后一个字节的 copy 工作</span><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (this.lastNeed &lt;= buf.length) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    buf.copy(this.lastChar, p, 0, this.lastNeed);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    // 并且直接 toString 返回此 3 字节长字符 <font style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51);">€</font></span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    return this.lastChar.toString(this.encoding, 0, this.lastTotal);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  }</font><br/></div><div>. . .</div></div><div><br/></div><div>最终 utf8End 函数将 € 作为最终的输出字符。本节分析完毕。</div><div><br/></div><div><br/></div>

<hr class="tail-hr">
<div class="tail-licenses">
<p>版权声明：自由转载-非商用-非衍生-保持署名(<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">创意共享3.0许可证</a>)</p>
<p>文章作者：Pooky (<a href="mailto:guananddu@icloud.com">guananddu@icloud.com</a>)</p>
<p>更新日期：Thu Dec 29 2016 18:32:30 GMT+0800 (CST)</p>
</div></body></html>