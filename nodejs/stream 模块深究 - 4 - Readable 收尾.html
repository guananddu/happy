<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 6.10 (454267)"/><meta name="author" content="管伟"/><meta name="created" content="2017-01-05 08:40:11 +0000"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2017-01-05 16:09:26 +0000"/><title>stream 模块深究 - 4 - Readable 收尾</title></head><body><style>
    a { color: #43B0D6 !important; }
    a:visited { color: #7b7ed2 !important; }
    .title-p { font-size:12px; color:gray; }
    .title-hr { margin-bottom: 20px; }
    .tail-hr { margin-top: 20px; }
    .tail-licenses { border:1px dashed lightgray; margin:20px 0 20px 0; padding:20px; font-size:14px; }
</style>
<h2>stream 模块深究 - 4 - Readable 收尾</h2>
<p class="title-p">版权声明：自由转载-非商用-非衍生-保持署名(<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">创意共享3.0许可证</a>)</p>
<p class="title-p">文章作者：Pooky (<a href="mailto:guananddu@icloud.com">guananddu@icloud.com</a>)</p>
<hr class="title-hr"><div>通过 Readable 1,2,3 三节，基本上 Readable 的逻辑大致已经梳理清楚。下面再补充几处疏漏点：</div><div><br/></div><div>🌟关于 readable.read(0) 与 readable.read() 的区别，通过源码中 _stream_readable.js 文件中的：Readable.prototype.read 函数体可以了解其逻辑，前几节中有源码罗列。</div><div><br/></div><div>readable.read(0) 的关键点：通过 howMuchToRead 函数来确定，最终要读取的数据大小为 0，即最终 readable.read(0) 的返回值是 null，且不会触发 data 事件。但是，只要 doRead 的标识为 true，仍旧会调用底层的 readable._read(state.highWaterMark) 函数来读取底层数据；</div><div><br/></div><div>而 readable.read() 的关键点，会返回目前 internal buffer 中已有的可用数据，作为其返回值，并且触发 data 事件。同样，只要条件允许，仍旧会调用 readable._read 函数来继续读取底层数据。 </div><div><br/></div><div>再来重温下文档中的 readable.read 函数的说明：</div><div><br/></div><div/><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">readable.read([size])#</font></div><div style="color: rgb(51, 51, 51);"><br/></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">Added in: v0.9.4</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">size &lt;Number&gt; Optional argument to specify how much data to read.</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">Return &lt;String&gt; | &lt;Buffer&gt; | &lt;Null&gt;</font></div><div><font style="color: rgb(51, 51, 51); font-size: 12px;">The readable.read() method pulls some data out of the internal buffer and returns it. </font><font style="font-size: 12px;" color="#ff7e79">If no data available to be read, null is returned</font><font style="color: rgb(51, 51, 51); font-size: 12px;">. By default, the data will be returned as a Buffer object unless an encoding has been specified using the readable.setEncoding() method or the stream is operating in object mode.</font></div><div style="color: rgb(51, 51, 51);"><br/></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">The optional size argument specifies a specific number of bytes to read. If size bytes are not available to be read, null will be returned unless the stream has ended, in which case all of the data remaining in the internal buffer will be returned (even if it exceeds size bytes).</font></div><div style="color: rgb(51, 51, 51);"><br/></div><div><font style="font-size: 12px;" color="#ff7e79">If the size argument is not specified, all of the data contained in the internal buffer will be returned.</font></div><div style="color: rgb(51, 51, 51);"><br/></div><div><font style="color: rgb(51, 51, 51); font-size: 12px;">The readable.read() method should only be called on Readable streams operating </font><font style="font-size: 12px;" color="#0096ff">in paused mode</font><font style="color: rgb(51, 51, 51); font-size: 12px;">. In flowing mode, readable.read() is called automatically until the internal buffer is fully drained.</font><br/></div></div><div><br/></div><div>🌟关于 readable.pause 和 readable.resume 函数的执行流程。测试代码见下：</div><div><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'Menlo';font-size:13.5pt;"><span style="color:#cc7832;font-weight:bold;">const </span>readable = fs.<span style="color:#ffc66d;">createReadStream</span>( filePath<span style="color:#cc7832;">, </span>{<br/>    <span style="color:#9876aa;">highWaterMark</span>: <span style="color:#6897bb;">20000<br/></span>} )<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;"><br/></span>readable.<span style="color:#ffc66d;">on</span>( <span style="color:#6a8759;">'data'</span><span style="color:#cc7832;">, </span>( chunk ) =&gt; {<br/>    <span style="color:#9876aa;">console</span>.<span style="color:#ffc66d;">log</span>( <span style="color:#6a8759;">`Received </span>${chunk.<span style="color:#9876aa;">length</span>}<span style="color:#6a8759;"> bytes of data.` </span>)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">    </span>readable.<span style="color:#ffc66d;">pause</span>()<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">    </span><span style="color:#9876aa;">console</span>.<span style="color:#ffc66d;">log</span>( <span style="color:#6a8759;">'There will be no additional data for 1 second.' </span>)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">    </span><span style="color:#ffc66d;">setTimeout</span>( () =&gt; {<br/>        <span style="color:#9876aa;">console</span>.<span style="color:#ffc66d;">log</span>( <span style="color:#6a8759;">'Now data will start flowing again.' </span>)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">        </span>readable.<span style="color:#ffc66d;">resume</span>()<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">    </span>}<span style="color:#cc7832;">, </span><span style="color:#6897bb;">1000 </span>)<span style="color:#cc7832;">;<br/></span>} )<span style="color:#cc7832;">;</span>
</pre>进入断点流程，首先进入 readable.on( ‘data’ … ) 时，就会触发一次 resume 的执行：</div><div><br/></div><div><img src="stream%20%E6%A8%A1%E5%9D%97%E6%B7%B1%E7%A9%B6%20-%204%20-%20Readable%20%E6%94%B6%E5%B0%BE.resources/D24586D0-80C4-4EFF-B280-B0601AB79F15.png" height="auto" width="100%"/><br/></div><div><br/></div><div>那么就可以跟进入 resume 函数一探究竟：</div><div><br/></div><div><img src="stream%20%E6%A8%A1%E5%9D%97%E6%B7%B1%E7%A9%B6%20-%204%20-%20Readable%20%E6%94%B6%E5%B0%BE.resources/328890BD-1679-4F08-8934-75A7CFEF11C3.png" height="auto" width="100%"/><br/></div><div><br/></div><div>相关断点变量可以从截图中看到，state.flowing 一开始为 null ，进入 if 分支内部，再被赋值成 true，也就是 state.flowing === true。通过前几节提到的“两种运行模式／三种内部状态”解释了 state.flowing === true 是 flowing 模式开始的标记。然后再次进入内部的 resume 函数：</div><div><br/></div><div><img src="stream%20%E6%A8%A1%E5%9D%97%E6%B7%B1%E7%A9%B6%20-%204%20-%20Readable%20%E6%94%B6%E5%B0%BE.resources/E3DF0D1C-661A-444D-BE12-8642FA2C275E.png" height="auto" width="100%"/><br/></div><div><br/></div><div>进入此环节，需要将 state.resumeScheduled 标记为 true，然后在 nextTick 中执行内部私有函数 resume_ ，并带入 stream 和 state 参数：</div><div><br/></div><div/><div style="box-sizing: border-box; padding: 8px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">function resume_(stream, state) {</font></div><div><font><font face="Monaco, Menlo, Consolas, Courier New, monospace" color="#333333"><span style="font-size: 12px;">  // 从 on( ‘data’, … ) 中触发的 resume 执行开始，state.reading 状态肯定为 false</span></font><br/></font></div><div><font><font face="Monaco, Menlo, Consolas, Courier New, monospace" color="#333333"><span style="font-size: 12px;"><span>  // 因为还没开始从底层读取任何数据，所以肯定会走入此分支</span><br/></span></font></font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (!state.reading) {</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">    debug('resume read 0');</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">    stream.read(0); // 不需要返回值，但是启动底层的 _read 来获取资源数据</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">  }</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><br/></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">  state.resumeScheduled = false;</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">  state.awaitDrain = 0;</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">  stream.emit('resume’); // resume 事件在这里触发</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">  flow(stream); // 🌟 重点看 flow 函数</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (state.flowing &amp;&amp; !state.reading)</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">    stream.read(0);</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">}</font><br/></div></div><div><br/></div><div>flow 函数也很简单：</div><div><br/></div><div/><div style="box-sizing: border-box; padding: 8px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">function flow(stream) {</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">  const state = stream._readableState;</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">  debug('flow', state.flowing);</font></div><div><font><font face="Monaco, Menlo, Consolas, Courier New, monospace" color="#333333"><span style="font-size: 12px;">  // 开始持续不断地 “flowing” 读取数据，且只要 stream.read() 持续返回数据，就会持续触发 data 事件，以使轮子转起来</span></font><br/></font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">  while (state.flowing &amp;&amp; stream.read() !== null);</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">}</font><br/></div></div><div><br/></div><div/><div>🌟当 data 事件被触发，则进入 data 事件回调，里面会有 pause 函数的调用，见断点：</div><div><br/></div><div><img src="stream%20%E6%A8%A1%E5%9D%97%E6%B7%B1%E7%A9%B6%20-%204%20-%20Readable%20%E6%94%B6%E5%B0%BE.resources/81F769ED-D420-455B-8531-4127E1A481DD.png" height="auto" width="100%"/><br/></div><div><br/></div><div>注意右下方的断点变量值，由此可见 pause 函数仅仅是把 state.flowing 置为 false （具体含义参见前几节），并且触发 pause 事件。</div><div><br/></div><div>🌟为什么 resume 能使“轮子转起来”，即能够源源不断地获取底层数据资源，并且触发 data 事件：</div><div><br/></div><div>第一点，因为 resume_ 内部的 flow 函数中的：while (state.flowing &amp;&amp; stream.read() !== null) 语句，stream.read() 函数在 internal buffer 中数据可用的状态下（ state.length !== 0 ）会直接触发 data 事件并且带入 chunk 数据；</div><div><br/></div><div>第二点，若因为 internal buffer 中暂无数据（例如，read(0) 的底层回调函数还没有被执行，即第 3 节提到的 readable.push(chunk) 函数仍旧没有被执行，可能原因比如文件读取慢就会导致这种情形 ）。此时，待 read(0) 更加底层的 fs.read 函数的 onread 回调被执行后，如果 chunk 正常，则就会最终执行 readable.push(chunk) 函数，而 push 函数最终调用 readableAddChunk 函数中的逻辑：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    . . .  </font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    </span>if (!skipAdd) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">        // if we want the data now, just emit it.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">        if (state.flowing &amp;&amp; state.length === 0 &amp;&amp; !state.sync) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">          // 如果 readable 为 flowing 模式，且 internal buffer 中已经没有可用资源，且是异步模式</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">          // 直接触发 data 事件，并且把这次新获取的数据直接 emit 出去</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">          stream.emit('data', chunk);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">          // 继续开始读取底层数据【轮子得以转起来】</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">          stream.read(0);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">        } else {</font></div><div><span>    <span>    . . .</span></span><br/></div></div><div><br/></div><div>持续调用的 emit 和 read 函数保证了“轮子的持续运转”。</div><div><br/></div><div><br/></div>

<hr class="tail-hr">
<div class="tail-licenses">
<p>版权声明：自由转载-非商用-非衍生-保持署名(<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">创意共享3.0许可证</a>)</p>
<p>文章作者：Pooky (<a href="mailto:guananddu@icloud.com">guananddu@icloud.com</a>)</p>
<p>更新日期：Fri Jan 06 2017 00:16:11 GMT+0800 (CST)</p>
</div></body></html>