<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 6.10 (454267)"/><meta name="author" content="管伟"/><meta name="created" content="2016-12-01 09:22:54 +0000"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2016-12-22 03:10:59 +0000"/><title>timer 相关函数细节解析 - process.nextTick - 2</title></head><body><style>
    a { color: #43B0D6 !important; }
    .title-p { font-size:12px; color:gray; }
    .title-hr { margin-bottom: 20px; }
    .tail-hr { margin-top: 20px; }
    .tail-licenses { border:1px dashed lightgray; margin:20px 0 20px 0; padding:20px; font-size:14px; }
</style>
<h2>timer 相关函数细节解析 - process.nextTick - 2</h2>
<p class="title-p">版权声明：自由转载-非商用-非衍生-保持署名(<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">创意共享3.0许可证</a>)</p>
<p class="title-p">文章作者：Pooky (<a href="mailto:guananddu@icloud.com">guananddu@icloud.com</a>)</p>
<hr class="title-hr"><div>第一节主要分析的是 js 层级的 nextTick 对象的调用过程，此节分析 c++ 层次的调用。</div><div>再来回顾一下官方文档的说明：</div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">The process.nextTick() method adds the callback to the "next tick queue". Once the current turn of the event loop turn runs to completion, all callbacks currently in the next tick queue will be called.</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">This is not a simple alias to setTimeout(fn, 0). It is much more efficient. It runs before any additional I/O events (including timers) fire in subsequent ticks of the event loop.</font><br/></div></div><div><br/></div><div>首先，为什么入口文件中的 process.nextTick 的回调调用要比 setTimeout( func, 0 ) 还要快，是因为：</div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">function run(entryFunction) {</font></div><div><div/><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>    // 调试状态下，会进入第一个分支，注释说明很清楚</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    if (process._debugWaitConnect &amp;&amp; isDebugBreak()) {</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">      // XXX Fix this terrible hack!</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">      //</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">      // Give the client program a few ticks to connect.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">      // Otherwise, there's a race condition where `node debug foo.js`</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">      // will not be able to connect in time to catch the first</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">      // breakpoint message on line 1.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">      //</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">      // A better fix would be to somehow get a message from the</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">      // V8 debug object about a connection, and runMain when</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">      // that occurs.  --isaacs</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">      var debugTimeout = +process.env.NODE_DEBUG_TIMEOUT || 50;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>    <span>  // 这就是调试状态下为什么会出现timer回调的原因</span></span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">      setTimeout(entryFunction, debugTimeout);</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    } else {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>    <span>  // 正常情况下，会直接调用此处回调</span></span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">      // Main entry point into most programs:</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">      entryFunction();</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    }</font></div></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  }</font><br/></div></div><div><br/></div><div>在 node 的启动过程中，在底层函数： <font style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51);">node::StartNodeInstance</font> 被调用( 具体是：LoadEnvironment(env) 函数调用 )，加载了 bootstrap_node.js 以及被 ascii 化的 js 内置模块代码之后，uv_loop 循环才真正开始，而在 bootstrap_node.js 的逻辑被调用时，Module.runMain() 函数的逻辑会被执行，此处的逻辑就包含了首轮 tick 中 nextTick 回调函数的调用：</div><div><img src="timer%20%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E7%BB%86%E8%8A%82%E8%A7%A3%E6%9E%90%20-%20process.nextTick%20-%202.resources/EFDFF652-4950-4686-87D4-56DEC24C6680.png" height="auto" width="100%"/><br/></div><div>process._tickCallback() 回调先于 uv_loop 的执行，即先于任何异步处理回调的执行，包括 timer 回调！</div><div><hr/>为了印证上述结论，参看 xcode 调试，测试代码见 nextTick.js，最终在执行完 LoadEnvironment( env ) 之后，开始执行 uv_run 循环：</div><div><img src="timer%20%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E7%BB%86%E8%8A%82%E8%A7%A3%E6%9E%90%20-%20process.nextTick%20-%202.resources/4A336357-FF71-4264-9FB5-F9FD2EBC4467.png" height="auto" width="100%"/>最终走入：<br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">#0     0x000000010008e3b9 in node::TimerWrap::OnTimeout(uv_timer_s*) at /Users/mrguan/work/build/node/node-6.6.0/src/timer_wrap.cc:95</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  static void OnTimeout(uv_timer_t* handle) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    TimerWrap* wrap = static_cast&lt;TimerWrap*&gt;(handle-&gt;data);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    Environment* env = wrap-&gt;env();</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    HandleScope handle_scope(env-&gt;isolate());</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    Context::Scope context_scope(env-&gt;context());</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>    // 这里将触发 timer 回调函数</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    wrap-&gt;MakeCallback(kOnTimeout, 0, nullptr);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  }</font><br/></div></div><div><br/></div><div>先看看 wrap-&gt;MakeCallback 调用之前的 console 输出：</div><div><img src="timer%20%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E7%BB%86%E8%8A%82%E8%A7%A3%E6%9E%90%20-%20process.nextTick%20-%202.resources/6F4A0ADF-0F58-4019-9845-146D7D34880F.png" height="auto" width="100%"/><br/></div><div>可见，nextTick 相关的回调已经被调用。但是 timer 的回调还没有被调用，最终进入到：</div><div/><div style="box-sizing: border-box; padding: 8px; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">#0     0x0000000100005163 in node::AsyncWrap::MakeCallback(v8::Local&lt;v8::Function&gt;, int, v8::Local&lt;v8::Value&gt;*) at /Users/mrguan/work/build/node/node-6.6.0/src/async-wrap.cc:197</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><br/></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">timer 的回调函数的运行，在这里被执行：</div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">Local&lt;Value&gt; ret = cb-&gt;Call(context, argc, argv);</font></div><div>之后：</div><div><img src="timer%20%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E7%BB%86%E8%8A%82%E8%A7%A3%E6%9E%90%20-%20process.nextTick%20-%202.resources/22AB34E3-C241-410F-B271-CEBD051C95F1.png" height="auto" width="100%"/><br/></div><div>timer 的回调被执行！</div></div><div><br/></div><div>之后，node::AsyncWrap::MackCallback 的逻辑继续往下执行，进入重头戏：</div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">#0     0x0000000100005a33 in node::AsyncWrap::MakeCallback(v8::Local&lt;v8::Function&gt;, int, v8::Local&lt;v8::Value&gt;*) at /Users/mrguan/work/build/node/node-6.6.0/src/async-wrap.cc:271</font></div><div><br/></div><div>. . .</div><div><span>  </span><br/></div><div><span><span>  // 获取当前 js 层级的，nextTickQueue 队列信息</span><br/></span></div><div><span><span><span>  // tick_info 分为两个字段，第一个字段默认为 0（开始索引）；第二个字段是 nextTickQueue 队列的长度</span><br/></span></span></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  Environment::TickInfo* tick_info = env()-&gt;tick_info();</font></div><div><span>  // 如果队列长度为 0</span><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  if (tick_info-&gt;length() == 0) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    env()-&gt;isolate()-&gt;RunMicrotasks();</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  }</font></div><div><span>  // 获取 process 对象</span><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  Local&lt;Object&gt; process = env()-&gt;process_object();</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  if (tick_info-&gt;length() == 0) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    tick_info-&gt;set_index(0);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    return ret;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  }</font></div><div><span>  // 直接调用 js 层次的 _tickCallback 回调函数！剩余的逻辑交给 js 层次来处理！【参见上一节的分析】</span><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  if (env()-&gt;tick_callback_function()-&gt;Call(process, 0, nullptr).IsEmpty()) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    return Local&lt;Value&gt;();</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  }</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  return ret;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">}</font><br/></div></div><div><br/></div><div>最终：</div><div><img src="timer%20%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E7%BB%86%E8%8A%82%E8%A7%A3%E6%9E%90%20-%20process.nextTick%20-%202.resources/D702C64D-E5C9-42D9-AC69-0615B3EC15C3.png" height="auto" width="100%"/><br/></div><div><br/></div><div>一句话总结：</div><div>start, scheduled 均为用户 js 入口文件中的输出逻辑，在调用 bootstrap_node.js 中引入主模块时被执行输出，即 Module.runMain 中的 Module._load 函数执行时输出；</div><div><br/></div><div>nextTick callback, nextTick 2 callback 为 bootstrap_node.js 中，Module.runMain 函数 第二句：process._tickCallback 函数执行时被执行输出；</div><div><br/></div><div>setTimeout callback 在 uv_run 中的 uv__run_timers 中被执行回调函数；</div><div><br/></div><div>i am a inner nextTick callback! 在 timer 的回调函数被执行完毕之后，由 node::AsyncWrap::MakeCallback 函数中的：</div><div>env()-&gt;tick_callback_function()-&gt;Call 函数所调用。 <br/></div><div><br/></div>

<hr class="tail-hr">
<div class="tail-licenses">
<p>版权声明：自由转载-非商用-非衍生-保持署名(<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">创意共享3.0许可证</a>)</p>
<p>文章作者：Pooky (<a href="mailto:guananddu@icloud.com">guananddu@icloud.com</a>)</p>
<p>更新日期：Thu Dec 22 2016 14:39:19 GMT+0800 (CST)</p>
</div></body></html>