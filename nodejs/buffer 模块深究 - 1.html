<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 6.10 (454267)"/><meta name="author" content="管伟"/><meta name="created" content="2016-12-16 08:41:30 +0000"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2016-12-24 07:08:00 +0000"/><title>buffer 模块深究 - 1</title></head><body><style>
    a { color: #43B0D6 !important; }
    a:visited { color: #7b7ed2 !important; }
    .title-p { font-size:12px; color:gray; }
    .title-hr { margin-bottom: 20px; }
    .tail-hr { margin-top: 20px; }
    .tail-licenses { border:1px dashed lightgray; margin:20px 0 20px 0; padding:20px; font-size:14px; }
</style>
<h2>buffer 模块深究 - 1</h2>
<p class="title-p">版权声明：自由转载-非商用-非衍生-保持署名(<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">创意共享3.0许可证</a>)</p>
<p class="title-p">文章作者：Pooky (<a href="mailto:guananddu@icloud.com">guananddu@icloud.com</a>)</p>
<hr class="title-hr"><div>首先回顾下官方手册对 buffer 的描述信息： </div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">Prior to the introduction of TypedArray in ECMAScript 2015 (ES6), the JavaScript language had no mechanism for reading or manipulating streams of binary data. The Buffer class was introduced as part of the Node.js API to make it possible to interact with octet streams in the context of things like TCP streams and file system operations.</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">Now that TypedArray has been added in ES6, the Buffer class implements the Uint8Array API（注意这里是 Buffer 扩展了 V8 已经实现的 Uint8Array） in a manner that is more optimized and suitable for Node.js' use cases.</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">Instances of the Buffer class are similar to arrays of integers but correspond to fixed-sized, raw memory allocations outside the V8 heap（注意这里的“outside”，在 node 层面，Buffer 的实例对象不再受到 V8 的堆内存限制）. The size of the Buffer is established when it is created and cannot be resized.</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">The Buffer class is a global within Node.js, making it unlikely that one would need to ever use require('buffer').Buffer.</font><br/></div></div><div><br/></div><div>buffer 模块也是作为全局对象 global 的 Buffer 属性，在 node 启动阶段就加载好的。</div><div><br/></div><div>这里顺带说一下，global 这个全局对象变量，是什么时候被“注入”的？global 变量的全局“注入”，在 node 启动之时，断点位置是：</div><div> <br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">#0     0x000000010002a484 in node::LoadEnvironment(node::Environment*) at /Users/mrguan/work/build/node/node-6.6.0/src/node.cc:3498</font></div></div><div><br/></div><div><img src="buffer%20%E6%A8%A1%E5%9D%97%E6%B7%B1%E7%A9%B6%20-%201.resources/3F558EAF-4890-476C-9C88-36F8BD0F6076.png" height="auto" width="100%"/><br/></div><div><br/></div><div>LoadEnvironment 的作用就是调用 bootstrap_node.js 启动文件中的启动函数，而截图中的上述代码，则是在启动函数调用之前，将  global 注入进启动函数的上下文中。</div><div><hr/>在 bootstrap_node.js 启动流程中，startup 函数体中会调用 setupGlobalVariables 函数：</div><div><br/></div><div/><div style="box-sizing: border-box; padding: 8px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  function setupGlobalVariables() {</font></div><div><font style="color: rgb(51, 51, 51); font-family: Monaco; font-size: 12px;">    . . .</font></div><div><font style="color: rgb(51, 51, 51); font-family: Monaco; font-size: 12px;"><span>    // 引入 Buffer 模块</span><br/></font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    global.Buffer = NativeModule.require('buffer').Buffer;</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    process.domain = null;</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    process._exiting = false;</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  }</font><br/></div></div><div><br/></div><div><hr/></div><div><br/></div><div>buffer 在被加载之时，做了哪些操作呢？</div><div><br/></div><div>有几个关键点，看下面的代码，代码来自 node/lib/buffer.js 文件，是一些前期声明：</div><div><br/></div><div/><div style="box-sizing: border-box; padding: 8px; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">/* eslint-disable require-buffer */</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">'use strict';</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">// 引用底层 c++ 模块</div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">const binding = process.binding('buffer');</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">const { isArrayBuffer } = process.binding('util’);</font></div><div><font face="Monaco">// c++ 和 js 通信桥</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">const bindingObj = {};</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">const internalUtil = require('internal/util');</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">// FastBuffer 直接继承了 V8 的 Uint8Array</div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">class FastBuffer extends Uint8Array {}</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">// 设置构造函数属性</div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">FastBuffer.prototype.constructor = Buffer;</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">Buffer.prototype = FastBuffer.prototype;</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">// 暴露 Buffer</div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">exports.Buffer = Buffer;</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">exports.SlowBuffer = SlowBuffer;</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">exports.INSPECT_MAX_BYTES = 50;</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">// 大小限制见下分析</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">exports.kMaxLength = binding.kMaxLength;</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">// 错误信息</div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">const kFromErrorMsg = 'First argument must be a string, Buffer, ' +</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">                      'ArrayBuffer, Array, or array-like object.';</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">// poolSize 8KB 大小为 1 个 poolSize</div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">Buffer.poolSize = 8 * 1024;</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">// 这几个变量为 Buffer 逻辑内的全局对象</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">var poolSize, poolOffset, allocPool;</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><br/></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">// 调用底层函数，见下分析</div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">// 为 Buffer 构造函数的 prototype 对象附加一些底层函数，之后还会附加 js 层级的函数</div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">binding.setupBufferJS(Buffer.prototype, bindingObj);</font><br/></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><br/></font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">// 上一步已经设置好 bindingObj.flags 对象为一个 Uint32Array 对象，且只有一个元素</font></div><div><font face="Monaco">// c++ &lt;==&gt; js 通信用</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><font style="font-size: 12px; color: rgb(51, 51, 51);">const flags = bindingObj.flags;</font></font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51);">const kNoZeroFill = 0;</font><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><br/></font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">. . .</font></div></div><div><br/></div><div>关于 binding.kMaxLength，在 buffer 底层 c++ 模块被加载时赋予的属性值：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">target-&gt;Set(env-&gt;context(),</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">     FIXED_ONE_BYTE_STRING(env-&gt;isolate(), "kMaxLength"),</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">     Integer::NewFromUnsigned(env-&gt;isolate(), kMaxLength)).FromJust();</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">====&gt;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">// kMaxLength 定义</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">static const unsigned int kMaxLength =</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    // 由下面的宏定义可知：intptr_r == long</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    sizeof(int32_t) == sizeof(intptr_t) ? 0x3fffffff : 0x7fffffff;</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">====&gt;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">// 相关宏定义</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">typedef int     int32_t;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">typedef __darwin_intptr_t intptr_t;</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">#ifdef __GNUC__</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">typedef __signed char   __int8_t;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">#else /* !__GNUC__ */</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">typedef char      __int8_t;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">#endif  /* !__GNUC__ */</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">typedef unsigned char   __uint8_t;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">typedef short     __int16_t;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">typedef unsigned short    __uint16_t;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">typedef int     __int32_t;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">typedef unsigned int    __uint32_t;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">typedef long long   __int64_t;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">typedef unsigned long long  __uint64_t;</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">// 这里</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">typedef long      __darwin_intptr_t;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">typedef unsigned int    __darwin_natural_t;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">. . .</font></div><div><br/></div></div><div><br/></div><div>0x3FFFFFFF 和 0x7FFFFFFF 的形象化表示：</div><div><br/></div><div><img src="buffer%20%E6%A8%A1%E5%9D%97%E6%B7%B1%E7%A9%B6%20-%201.resources/41A5E3A1-9481-4C09-9982-FDAE3A5B54C5.png" height="auto" width="100%"/><br/></div><div><img src="buffer%20%E6%A8%A1%E5%9D%97%E6%B7%B1%E7%A9%B6%20-%201.resources/D5929A97-A1E5-429A-8483-848FCC2FEB30.png" height="auto" width="100%"/><br/></div><div><br/></div><div>至于 10 进制是什么就不去换算了。上述的 sizeof 判断则为机器架构的判断：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">On 32-bit architectures, this value is (2^30)-1 (~1GB). On 64-bit architectures, this value is (2^31)-1 (~2GB).</font><br/></div></div><div><br/></div><div><hr/></div><div><br/></div><div>关于 binding.setupBufferJS 的调用，第一个参数是 Buffer.prototype ，第二个参数是一个空的 {}，断点进入：</div><div> <br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">#0     0x00000001000404ef in node::Buffer::SetupBufferJS(v8::FunctionCallbackInfo&lt;v8::Value&gt; const&amp;) at /Users/mrguan/work/build/node/node-6.6.0/src/node_buffer.cc:1300</font></div></div><div><br/></div><div><img src="buffer%20%E6%A8%A1%E5%9D%97%E6%B7%B1%E7%A9%B6%20-%201.resources/7C490DF0-7CAB-4F4C-8F27-358DE7F2A665.png" height="auto" width="100%"/><br/></div><div><br/></div><div>具体怎么附加 prototype 对象的方法不再赘述，如上截图，关注第二个参数 bindingObj：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">#0     0x0000000100040672 in node::Buffer::SetupBufferJS(v8::FunctionCallbackInfo&lt;v8::Value&gt; const&amp;) at /Users/mrguan/work/build/node/node-6.6.0/src/node_buffer.cc:1312</font></div><div><br/>// 此处开始设置 bindingObj 相关的逻辑</div><div>. . .</div><div><span>  // 确保第二个参数是一个 Object</span><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  CHECK(args[1]-&gt;IsObject());</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // 获取到此 Object</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  Local&lt;Object&gt; bObj = args[1].As&lt;Object&gt;();</font></div><div><span>  // <font style="font-size: 12px; color: rgb(51, 51, 51);">fields     uint32_t *const     0x105008600     0x0000000105008600</font></span><br/></div><div><span><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // fields 最终返回一个 uint32_t 的数组指针</span><br/></font></span></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  uint32_t* const fields = env-&gt;array_buffer_allocator_info()-&gt;fields();</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // 返回字段个数</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  uint32_t const fields_count =</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      env-&gt;array_buffer_allocator_info()-&gt;fields_count();</font></div><div><span>  // 创建一个标准的 v8 ArrayBuffer 结构，大小由 fields 和 fields_count 来决定</span><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  Local&lt;ArrayBuffer&gt; array_buffer =</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      ArrayBuffer::New(env-&gt;isolate(), fields, sizeof(*fields) * fields_count);</font></div><div><span>  // 在 ArrayBuffer 的基础上，创建 js 层级的 Uint32Array 对象</span><br/></div><div><span><span>  // 即设置 js 层级的 bindingObj.flags 为此 Uint32Array 对象</span><br/></span></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  bObj-&gt;Set(String::NewFromUtf8(env-&gt;isolate(), "flags"),</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">            Uint32Array::New(array_buffer, 0, fields_count));</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">}</font><br/></div><div>====&gt;</div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">inline int Environment::ArrayBufferAllocatorInfo::fields_count() const {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  return kFieldsCount;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">}</font><br/></div><div>====&gt;</div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">enum Fields {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  kNoZeroFill,</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  kFieldsCount // 1</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">};</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">uint32_t fields_[kFieldsCount];</font></div></div><div><br/></div><div><hr/></div><div>🌟buffer 模块在被加载之初，会首次执行 createPool 函数来创建一个 “pool”：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">// 默认 poolSize 大小为 8KB 大小</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">Buffer.poolSize = 8 * 1024;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">var poolSize, poolOffset, allocPool;</font></div><div><br/></div><div>// 已经分析</div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">binding.setupBufferJS(Buffer.prototype, bindingObj);</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">const flags = bindingObj.flags;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">const kNoZeroFill = 0;</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">function createUnsafeBuffer(size) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // 非填充数据</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  flags[kNoZeroFill] = 1;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  try {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    // 创建 FastBuffer 对象</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    return new FastBuffer(size);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  } finally {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    // 恢复 0</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    flags[kNoZeroFill] = 0;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  }</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">}</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">function createPool() {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // 8 * 1024</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  poolSize = Buffer.poolSize;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // 调用 createUnsafeBuffer 创建 FastBuffer( Uint8Array 子类 )</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><span>  // 这就是一个 poolSize 大小的 allocPool 【全局对象】</span><br/></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  allocPool = createUnsafeBuffer(poolSize);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // 恢复偏移量【全局】</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  poolOffset = 0;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">}</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">// buffer 模块加载时执行</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">createPool();</font><br/></div></div><div><br/></div><div><hr/>测试文件参见 test-nodejs/buffer/main.js ，首先进入第一个测试语句：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>const buf1 = Buffer.alloc( 20 );</div></div><div><br/></div><div>此条语句最终进入 node/lib/buffer.js ：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">/**</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"> * Creates a new filled Buffer instance.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"> * alloc(size[, fill[, encoding]])</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"> **/</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">Buffer.alloc = function(size, fill, encoding) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>  // size == 20</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span><span>  // fill == undefined == encoding</span><br/></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span><span><span>  // 这一句只是保证传入的 size 参数一定要是一个 number</span><br/></span></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  assertSize(size);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>  // 因为 fill == undefined 故此分支不会进入</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  if (size &gt; 0 &amp;&amp; fill !== undefined) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    . . .</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  }</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>  // 进入此构造函数</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  return new FastBuffer(size);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">};</font><br/></div></div><div><br/></div><div>而 FastBuffer 的构造函数很简单：</div><div><br/></div><div/><div style="box-sizing: border-box; padding: 8px; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">// 这里的 Uint8Array 是 V8 层面的对象</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">class FastBuffer extends Uint8Array {}</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">// 修改其实例的构造函数属性</div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">FastBuffer.prototype.constructor = Buffer;</font></div><div><font face="Monaco">// Buffer 的原型对象和 FastBuffer 保持一致</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">Buffer.prototype = FastBuffer.prototype;</font><br/></div></div><div><br/></div><div>下节继续分析</div><div><br/></div>

<hr class="tail-hr">
<div class="tail-licenses">
<p>版权声明：自由转载-非商用-非衍生-保持署名(<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">创意共享3.0许可证</a>)</p>
<p>文章作者：Pooky (<a href="mailto:guananddu@icloud.com">guananddu@icloud.com</a>)</p>
<p>更新日期：Sat Dec 24 2016 16:00:43 GMT+0800 (CST)</p>
</div></body></html>