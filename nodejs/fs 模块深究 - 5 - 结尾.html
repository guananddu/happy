<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 6.10 (454267)"/><meta name="altitude" content="53.85741806030273"/><meta name="author" content="管伟"/><meta name="created" content="2017-03-02 02:54:21 +0000"/><meta name="latitude" content="39.9707813937525"/><meta name="longitude" content="116.3234009072468"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2017-03-02 06:24:27 +0000"/><title>fs 模块深究 - 5 - 结尾</title></head><body><style>
    a { color: #43B0D6 !important; }
    a:visited { color: #7b7ed2 !important; }
    .title-p { font-size:12px; color:gray; }
    .title-hr { margin-bottom: 20px; }
    .tail-hr { margin-top: 20px; }
    .tail-licenses { border:1px dashed lightgray; margin:20px 0 20px 0; padding:20px; font-size:14px; }
</style>
<h2>fs 模块深究 - 5 - 结尾</h2>
<p class="title-p">版权声明：自由转载-非商用-非衍生-保持署名(<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">创意共享3.0许可证</a>)</p>
<p class="title-p">文章作者：Pooky (<a href="mailto:guananddu@icloud.com">guananddu@icloud.com</a>)</p>
<hr class="title-hr"><div>由上一节分析可知，子线程通过 <span style="color: rgb(0, 0, 0); font-family: -webkit-standard; font-size: medium; font-style: normal; font-variant-caps: normal; font-weight: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; float: none;">uv__fs_work 函数，来执行真正的针对文件的底层操作，之后将调用结果存入：uv_fs_t* req 的 result 字段中去：</span></div><div><span style="color: rgb(0, 0, 0); font-family: -webkit-standard; font-size: medium; font-style: normal; font-variant-caps: normal; font-weight: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; float: none;"><br/></span></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>. . .</div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    w-&gt;work(w); // 调用 uv__fs_work 函数</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    uv_mutex_lock(&amp;w-&gt;loop-&gt;wq_mutex);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    w-&gt;work = NULL;  /* Signal uv_cancel() that the work req is done</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">                        executing. */</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    // ✨子线程最终把当前的 w-&gt;wq 推入整个 loop 的 loop-&gt;wq 全局链表中去✨</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    QUEUE_INSERT_TAIL(&amp;w-&gt;loop-&gt;wq, &amp;w-&gt;wq);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    uv_async_send(&amp;w-&gt;loop-&gt;wq_async);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    uv_mutex_unlock(&amp;w-&gt;loop-&gt;wq_mutex);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  }</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">}</font><br/></div></div><div><br/></div><div>这里有一个：uv_async_send 函数调用，参数为 &amp;w-&gt;loop-&gt;wq_async：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">int uv_async_send(uv_async_t* handle) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  . . .</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (cmpxchgi(&amp;handle-&gt;pending, 0, 1) == 0)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    // 最终调用此函数</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    uv__async_send(&amp;handle-&gt;loop-&gt;async_watcher);</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  return 0;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">}</font><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><br/></font></div><div>// async_watcher 是 loop 的一个字段：</div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">struct uv__async async_watcher; </font><br/></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">struct uv__async {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  uv__async_cb cb;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  uv__io_t io_watcher;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  int wfd; // 相关联的文件描述符</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">};</font><br/></div></div><div><br/></div><div>来看看最终的：uv__async_send 函数：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">void uv__async_send(struct uv__async* wa) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  const void* buf;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  ssize_t len;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  int fd;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  int r;</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  buf = "";</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  len = 1;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  fd = wa-&gt;wfd; // 获取到 uv__async 的 wfd 字段（文件描述符）</font></div><div><br/></div><div><span>  . . .</span><br/></div><div><span>    </span><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  do</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    // 往 fd 中写入 buf 的 1 字节数据</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    r = write(fd, buf, len);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  while (r == -1 &amp;&amp; errno == EINTR);</font></div><div><span>  // 如果写入成功则直接跳出</span><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (r == len)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    return;</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  . . .</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">}</font><br/></div></div><div><br/></div><div>归根到底，子线程在完成具体工作之后，将 result 保留入此次相关联的 uv_fs_t* req 中的 result 字段，并且把此次的 req-&gt;work_req(struct uv__work)-&gt;wq(void* wq[2]) 插入至全局 loop 的 loop-&gt;wq 链表中去。最后通过 uv_async_send 函数向 handle-&gt;loop-&gt;async_watcher 所关联的 wfd 文件描述符写入一字节数据（貌似是写入一个空字节），这种表现形式应该是类似于打点了一个标记，便于 loop 在“下一次 tick”获取 async 信息【即观察者模式】。</div><div><br/></div><div><hr/></div><div><br/></div><div>最终，在 loop 的 tick 中，执行到 uv__io_poll 函数，则开始 check 与 io 相关的信息：</div><div><br/></div><div><img src="fs%20%E6%A8%A1%E5%9D%97%E6%B7%B1%E7%A9%B6%20-%205%20-%20%E7%BB%93%E5%B0%BE.resources/5BD7227C-4FDF-487A-B045-C103BB2094B5.png" height="auto" width="100%"/><br/></div><div><br/></div><div>具体的 uv__io_poll 函数非常长，设计各个与 io 相关的轮询操作，例如 kqueue 等，不再赘述。uv__io_poll 中通过 uv__async_io 函数，来判断与“异步io”相关的操作：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">static void uv__async_io(uv_loop_t* loop, uv__io_t* w, unsigned int events) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  struct uv__async* wa;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  char buf[1024];</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  unsigned n;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  ssize_t r;</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  n = 0;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  for (;;) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    // 注意这里的 w-&gt;fd 是一个管道的“读入端”，与本节上方的“写入端”是同一个管道的两端</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    r = read(w-&gt;fd, buf, sizeof(buf));</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    if (r &gt; 0)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      n += r;</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    if (r == sizeof(buf))</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      continue;</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    if (r != -1)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      break;</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    . . .</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  }</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  wa = container_of(w, struct uv__async, io_watcher);</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  . . .</font></div><div><span>  // 最终调用回调函数 uv__async_event</span><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  wa-&gt;cb(loop, wa, n);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">}</font><br/></div></div><div><br/></div><div>如上，提到关于 uv__async 的管道“写入端” wa-&gt;wfd 和 wa-&gt;io_watcher-&gt;fd 的管道“读入端”是一个管道结构，这个管道在 node 启动流程中被创建，具体在：<a>https://guananddu.github.io/happy/nodejs/NodeJS%20启动流程3.html</a> 中有相关的描述：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">int uv__async_start(uv_loop_t* loop, struct uv__async* wa, uv__async_cb cb) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  int pipefd[2];</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  int err;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  ...</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // 创建管道描述符：pipefd</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  ...</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // 调用 init</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // 初始化 loop-&gt;async_watcher-&gt;io_watcher 的 pending_queue、watcher_queue 双向链表</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // 设置 wa-&gt;io_watcher-&gt;cb = uv__async_io</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // 设置 wa-&gt;io_watcher-&gt;fd = pipefd[0] （管道读入端）</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // 等等...</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  uv__io_init(&amp;wa-&gt;io_watcher, uv__async_io, pipefd[0]);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // 将此 wa-&gt;io_watcher 追加入 loop-&gt;watcher_queue 双向链表</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // 再将此 watcher 通过 pipefd[0] 为索引，放入 loop-&gt;watchers 数组</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // loop-&gt;nfds++</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  uv__io_start(loop, &amp;wa-&gt;io_watcher, POLLIN);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // 最后，设置 loop-&gt;async_watcher-&gt;wfd 值为管道写入端的描述符</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  wa-&gt;wfd = pipefd[1];</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // 设置 loop-&gt;async_watcher-&gt;cb = uv__async_event【函数】</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  wa-&gt;cb = cb;</font><br/></div></div><div><br/></div><div>本质上其实是观察者模式的一种实现。如果有异步请求 req 被处理完成，则通过写入 wa-&gt;wfd 写入端，来通知 wa-&gt;io_watcher ，而在每一次的 tick 的 io_pool 轮训中，通过判断 wa-&gt;io_watcher-&gt;fd 读入端来判断是不是有异步消息等待被处理。</div><div><br/></div><div>继续看 uv__async_event 函数：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">static void uv__async_event(uv_loop_t* loop,</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">                            struct uv__async* w,</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">                            unsigned int nevents) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  . . .</font></div><div><span>  </span><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  QUEUE_MOVE(&amp;loop-&gt;async_handles, &amp;queue);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  while (!QUEUE_EMPTY(&amp;queue)) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    . . .</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    h-&gt;async_cb(h);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  }</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">}</font><br/></div></div><div><br/></div><div>具体的函数细节不再跟踪，在 node 初始化过程中，与 loop-&gt;async_handles 链表相关联的初始化已经完成（仍旧是参看：<a>https://guananddu.github.io/happy/nodejs/NodeJS%20启动流程3.html</a>）。因此，在 uv__async_event 回调函数中，通过遍历 loop-&gt;async_handles 链表找出相关的节点进行处理。</div><div><br/></div><div>上述 QUEUE_MOVE 的操作在：<a>https://guananddu.github.io/happy/nodejs/timer%20相关函数细节解析%20-%20setImmediate%20-%20from%20c_c%2B%2B.html</a> 文中有过描述，基本操作流程就是：为原始链表 loop-&gt;async_handles 新创建一个头节点 H，然后将原始链表头“剥离”，通过 while 循环遍历 H 头节点完成每一个节点操作，之后再将处理过的每一个节点重新插回到 loop-&gt;async_handles 链表中去。这是 node 底层中处理关键链表的一个通用模式。</div><div><br/></div><div>最终，进入 uv__work_done 回调函数：</div><div><br/></div><div><img src="fs%20%E6%A8%A1%E5%9D%97%E6%B7%B1%E7%A9%B6%20-%205%20-%20%E7%BB%93%E5%B0%BE.resources/CF1599C6-FA0B-4010-A753-9466EDA623EB.png" height="auto" width="100%"/><br/></div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">void uv__work_done(uv_async_t* handle) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  struct uv__work* w;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  uv_loop_t* loop;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  QUEUE* q;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  QUEUE wq; // 局部变量</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  int err;</font></div><div><span>  // 通过 container_of 反推出 loop 的地址</span><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  loop = container_of(handle, uv_loop_t, wq_async);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  uv_mutex_lock(&amp;loop-&gt;wq_mutex); // 加锁</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  QUEUE_MOVE(&amp;loop-&gt;wq, &amp;wq); // 将 loop-&gt;wq 置空，并且将此链表“移动”至 wq 指针</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  uv_mutex_unlock(&amp;loop-&gt;wq_mutex); // 释放</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  while (!QUEUE_EMPTY(&amp;wq)) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    q = QUEUE_HEAD(&amp;wq); // 获取 QUEUE_NEXT</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    QUEUE_REMOVE(q); // 移除节点</font></div><div><span>    // 获取 uv__work 真身</span><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    w = container_of(q, struct uv__work, wq);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    err = (w-&gt;work == uv__cancelled) ? UV_ECANCELED : 0;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    w-&gt;done(w, err); // 调用回调 uv__fs_done</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  }</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">}</font><br/></div></div><div><br/></div><div>真是层层回调调不休啊，w-&gt;done(w, err) 的调用也就是 uv__fs_done 函数的调用：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">static void uv__fs_done(struct uv__work* w, int status) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  uv_fs_t* req;</font></div><div><span>  // 获取 uv_fs_t 这个 request 结构体</span><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  req = container_of(w, uv_fs_t, work_req);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  uv__req_unregister(req-&gt;loop, req); // unregister</font></div><div><span>  . . .</span><br/></div><div><span>  // 走入 req 层级的回调</span><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  req-&gt;cb(req);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">}</font><br/></div></div><div><br/></div><div>这次就走入了最终的回调函数，来先看看截图：</div><div><br/></div><div><img src="fs%20%E6%A8%A1%E5%9D%97%E6%B7%B1%E7%A9%B6%20-%205%20-%20%E7%BB%93%E5%B0%BE.resources/6C5187C3-D175-4412-8E33-273284871C3A.png" height="auto" width="100%"/><br/></div><div><br/></div><div>此 node::After 函数的执行流程比较简单，主要就是通过 req-&gt;result 来判断底层调用是否正常，生成 agrc 和 argv，并最终通过 req_wrap-&gt;MakeCallback(env-&gt;oncomplete_string(), argc, argv) 创建 js 层级的回调函数调用，最后的最后，清理 req_wrap-&gt;req_ 及其自身 req_wrap。</div><div><br/></div><div><br/></div>

<hr class="tail-hr">
<div class="tail-licenses">
<p>版权声明：自由转载-非商用-非衍生-保持署名(<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">创意共享3.0许可证</a>)</p>
<p>文章作者：Pooky (<a href="mailto:guananddu@icloud.com">guananddu@icloud.com</a>)</p>
<p>更新日期：Thu Mar 02 2017 14:29:17 GMT+0800 (CST)</p>
</div></body></html>