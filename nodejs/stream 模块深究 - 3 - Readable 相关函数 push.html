<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 6.10 (454267)"/><meta name="author" content="管伟"/><meta name="created" content="2017-01-04 17:45:16 +0000"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2017-01-05 15:54:36 +0000"/><title>stream 模块深究 - 3 - Readable 相关函数 push</title></head><body><style>
    a { color: #43B0D6 !important; }
    a:visited { color: #7b7ed2 !important; }
    .title-p { font-size:12px; color:gray; }
    .title-hr { margin-bottom: 20px; }
    .tail-hr { margin-top: 20px; }
    .tail-licenses { border:1px dashed lightgray; margin:20px 0 20px 0; padding:20px; font-size:14px; }
</style>
<h2>stream 模块深究 - 3 - Readable 相关函数 push</h2>
<p class="title-p">版权声明：自由转载-非商用-非衍生-保持署名(<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">创意共享3.0许可证</a>)</p>
<p class="title-p">文章作者：Pooky (<a href="mailto:guananddu@icloud.com">guananddu@icloud.com</a>)</p>
<hr class="title-hr"><div>接上节的分析，关于 Readable.prototype.push 函数的细节点，我们还是只根据上节的示例代码来跟进：</div><div><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'Menlo';font-size:13.5pt;"><span style="color:#cc7832;font-weight:bold;">const </span>readable = fs.<span style="color:#ffc66d;">createReadStream</span>( filePath<span style="color:#cc7832;">, </span>{<br/>    <span style="color:#9876aa;">highWaterMark</span>: <span style="color:#6897bb;">20000<br/></span>} )<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;"><br/></span>readable.<span style="color:#ffc66d;">on</span>( <span style="color:#6a8759;">'readable'</span><span style="color:#cc7832;">, </span>() =&gt; {<br/>    <span style="color:#cc7832;font-weight:bold;">var </span>chunk<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">    </span><span style="color:#cc7832;font-weight:bold;">while </span>( <span style="color:#cc7832;font-weight:bold;">null </span>!== ( chunk = readable.<span style="color:#ffc66d;">read</span>() ) ) {<br/>        <span style="color:#9876aa;">console</span>.<span style="color:#ffc66d;">log</span>( <span style="color:#6a8759;">`Received </span>${chunk.<span style="color:#9876aa;">length</span>}<span style="color:#6a8759;"> bytes of data.` </span>)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">    </span>}<br/>} )<span style="color:#cc7832;">;</span>
</pre>当最终通过 readable.read 函数调用至 readable._read ，直至 fs.read 中的回调函数被执行（异步），fs.read 函数中的回调函数见：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  . . .</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  </span>// move the pool positions, and internal position for reading.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (this.pos !== undefined)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    this.pos += toRead;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  pool.used += toRead;</font></div><div><span>  // 这里</span><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  function onread(er, bytesRead) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    if (er) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      if (self.autoClose) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">        self.destroy();</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      }</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      self.emit('error', er);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    } else {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      var b = null;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      if (bytesRead &gt; 0) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">        self.bytesRead += bytesRead;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">        b = thisPool.slice(start, start + bytesRead);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      }</font></div><div><span>    <span>  // 主要关注此函数</span></span><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      self.push(b);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    }</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  }</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">};</font><br/></div></div><div><br/></div><div>如代码：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">// Manually shove something into the read() buffer.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">// This returns true if the highWaterMark has not been hit yet,</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">// similar to how Writable.write() returns true if you should</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">// write() some more.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">Readable.prototype.push = function(chunk, encoding) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  var state = this._readableState;</font></div><div><span>  . . .</span><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  return readableAddChunk(this, state, chunk, encoding, false);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">};</font><br/></div></div><div><br/></div><div>重要的大函数 readableAddChunk:</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">function readableAddChunk(stream, state, chunk, encoding, addToFront) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  var er = chunkInvalid(state, chunk); // 检查是不是合法的 chunk</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (er) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    stream.emit('error', er);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  } else if (chunk === null) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    // 如果读取为 null 或者到达文件末尾的处理点，此处的逻辑不再追踪</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    state.reading = false;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    onEofChunk(stream, state);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  } else if (state.objectMode || chunk &amp;&amp; chunk.length &gt; 0) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    if (state.ended &amp;&amp; !addToFront) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      const e = new Error('stream.push() after EOF');</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      stream.emit('error', e);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    } else if (state.endEmitted &amp;&amp; addToFront) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      const e = new Error('stream.unshift() after end event');</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      stream.emit('error', e);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    } else {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    <span>  // 正常走入这里</span></span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      var skipAdd;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      if (state.decoder &amp;&amp; !addToFront &amp;&amp; !encoding) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">        chunk = state.decoder.write(chunk);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">        skipAdd = (!state.objectMode &amp;&amp; chunk.length === 0);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      }</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      if (!addToFront)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    <span>    // 标记 state.reading 为 false</span></span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">        state.reading = false;</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      // Don't add to the buffer if we've decoded to an empty string chunk and</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      // we're not in object mode</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      if (!skipAdd) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">        // if we want the data now, just emit it.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">        if (state.flowing &amp;&amp; state.length === 0 &amp;&amp; !state.sync) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    <span>    <span>  // 如果 readable 为 flowing 模式，且 internal buffer 中已经没有可用资源，且是异步模式</span></span></span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><span><span><span>    <span>    <span>  // 直接触发 data 事件，并且把这次新获取的数据直接 emit 出去</span></span></span><br/></span></span></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">          stream.emit('data', chunk);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    <span>    <span>  // 继续开始读取底层数据【轮子得以转起来】</span></span></span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">          stream.read(0);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">        } else {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    <span>    <span>  // 当 readable 为 paused 模式【或者排除之前的 if 语句条件之后】</span></span></span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">          // update the buffer info. // state.length 增加可消费数据资源记录</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">          state.length += state.objectMode ? 1 : chunk.length;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">          if (addToFront)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">            state.buffer.unshift(chunk);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">          else</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    <span>    <span>    // 一般情况下追加至 BufferList 末尾</span></span></span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">            state.buffer.push(chunk);</font></div><div><span>    <span>    <span>  // 数据就绪，可以触发 readable 事件了</span></span></span><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">          if (state.needReadable)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">            emitReadable(stream);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">        }</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      }</font></div><div><span>    <span>  // 此函数不再赘述 process.nextTick 执行一个回调，在符合</span></span><br/></div><div><span><span><span>    <span>  // <font style="font-size: 12px; color: rgb(51, 51, 51);">!state.reading &amp;&amp; !state.flowing &amp;&amp; !state.ended </font></span></span></span></span></div><div><span><span><span><span><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    <span>  // <span>    </span></span></span>&amp;&amp; </font></span></span></span></span>state.length &lt; state.highWaterMark</div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    <span>  // 的条件下 while 执行 stream.read(0)</span></span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      maybeReadMore(stream, state);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    }</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  } else if (!addToFront) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    state.reading = false;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  }</font></div><div><span>  // 返回是不是仍旧需要继续 read 的标识，见下</span><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  return needMoreData(state);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">}</font><br/></div></div><div><br/></div><div>关于 needMoreData:</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">// if it's past the high water mark, we can push in some more.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">// Also, if we have no data yet, we can stand some</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">// more bytes.  This is to work around cases where hwm=0,</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">// such as the repl.  Also, if the push() triggered a</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">// readable event, and the user called read(largeNumber) such that</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">// needReadable was set, then we ought to push more, so that another</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">// 'readable' event will be triggered.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">function needMoreData(state) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  return !state.ended &amp;&amp;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">         (state.needReadable ||</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">          state.length &lt; state.highWaterMark ||</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">          state.length === 0);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">}</font><br/></div></div><div><br/></div><div>至此，stream.Readable 基本上分析完毕。</div><div><br/></div>

<hr class="tail-hr">
<div class="tail-licenses">
<p>版权声明：自由转载-非商用-非衍生-保持署名(<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">创意共享3.0许可证</a>)</p>
<p>文章作者：Pooky (<a href="mailto:guananddu@icloud.com">guananddu@icloud.com</a>)</p>
<p>更新日期：Fri Jan 06 2017 00:16:11 GMT+0800 (CST)</p>
</div></body></html>