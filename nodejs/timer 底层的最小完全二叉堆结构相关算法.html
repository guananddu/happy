<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 6.10 (454267)"/><meta name="author" content="管伟"/><meta name="created" content="2016-11-16 09:00:13 +0000"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2017-01-06 06:58:30 +0000"/><title>timer 底层的最小完全二叉堆结构相关算法</title></head><body><style>
    a { color: #43B0D6 !important; }
    a:visited { color: #7b7ed2 !important; }
    .title-p { font-size:12px; color:gray; }
    .title-hr { margin-bottom: 20px; }
    .tail-hr { margin-top: 20px; }
    .tail-licenses { border:1px dashed lightgray; margin:20px 0 20px 0; padding:20px; font-size:14px; }
</style>
<h2>timer 底层的最小完全二叉堆结构相关算法</h2>
<p class="title-p">版权声明：自由转载-非商用-非衍生-保持署名(<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">创意共享3.0许可证</a>)</p>
<p class="title-p">文章作者：Pooky (<a href="mailto:guananddu@icloud.com">guananddu@icloud.com</a>)</p>
<hr class="title-hr"><div>根据章节《timer 相关函数细节解析 - setInterval - 2》中开始的总结描述，可以知道，lib_uv 采用 Binary Min Heap （最小二叉堆）的数据结构，来组织和判断 setInterval 和 setTimeout 的底层 timer 节点，保证 timer 的按时执行。</div><div><br/></div><div>lib_uv 核心函数 uv_run 中 有 uv__run_timers 的调用，来判断目前各个 timer 节点的时机状态( node/deps/uv/src/unix/timer.c )：</div><div><br/></div><div/><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">void uv__run_timers(uv_loop_t* loop) {</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  struct heap_node* heap_node;</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  uv_timer_t* handle;</font></div><div style="color: rgb(51, 51, 51);"><br/></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  for (;;) {</font></div><div><font style="color: rgb(51, 51, 51); font-size: 12px;">    heap_node = heap_min((struct heap*) &amp;</font><font style="font-size: 12px;" color="#ff7e79">loop-&gt;timer_heap</font><font style="color: rgb(51, 51, 51); font-size: 12px;">);</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">    if (heap_node == NULL)</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">      break;</font></div><div style="color: rgb(51, 51, 51);"><br/></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">    handle = container_of(heap_node, uv_timer_t, heap_node);</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">    if (handle-&gt;timeout &gt; loop-&gt;time)</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">      break;</font></div><div style="color: rgb(51, 51, 51);"><br/></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">    uv_timer_stop(handle);</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">    uv_timer_again(handle);</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">    handle-&gt;timer_cb(handle);</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  }</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">}</font><br/></div></div><div><br/></div><div>上述代码中的 loop-&gt;timer_heap 则是整个 loop 的 最小二叉堆结构结构体指针：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">/* A binary min heap.  The usual properties hold: the root is the lowest</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"> * element in the set, the height of the tree is at most log2(nodes) and</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"> * it's always a complete binary tree.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"> *</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"> * The heap function try hard to detect corrupted tree nodes at the cost</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"> * of a minor reduction in performance.  Compile with -DNDEBUG to disable.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"> */</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">struct heap {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  struct heap_node* min; // 始终指向 root 节点（lowest element）</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  unsigned int nelts; // 节点总个数</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">};</font><br/></div></div><div><br/></div><div>如下图：</div><div><br/></div><div><img src="timer%20%E5%BA%95%E5%B1%82%E7%9A%84%E6%9C%80%E5%B0%8F%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E5%A0%86%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95.resources/A24A6F4F-70B9-4994-A8A2-B041B21C38A7.png" height="auto" width="100%"/><br/></div><div> </div><div>因为最小二叉堆有其特有的操作算法，具体算法实现不再赘述，比较复杂。具体的实现代码在 node 源码中的：node/deps/uv/src/heap-inl.h 中，为了方便查看，代码见下（比较长）：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">#ifndef UV_SRC_HEAP_H_</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">#define UV_SRC_HEAP_H_</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">#include &lt;stddef.h&gt;  /* NULL */</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">#if defined(__GNUC__)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"># define HEAP_EXPORT(declaration) __attribute__((unused)) static declaration</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">#else</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"># define HEAP_EXPORT(declaration) static declaration</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">#endif</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">struct heap_node {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  struct heap_node* left;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  struct heap_node* right;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  struct heap_node* parent;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">};</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">/* A binary min heap.  The usual properties hold: the root is the lowest</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"> * element in the set, the height of the tree is at most log2(nodes) and</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"> * it's always a complete binary tree.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"> *</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"> * The heap function try hard to detect corrupted tree nodes at the cost</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"> * of a minor reduction in performance.  Compile with -DNDEBUG to disable.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"> */</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">struct heap {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  struct heap_node* min;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  unsigned int nelts;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">};</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">/* Return non-zero if a &lt; b. */</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">typedef int (*heap_compare_fn)(const struct heap_node* a,</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">                               const struct heap_node* b);</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">/* Public functions. */</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">HEAP_EXPORT(void heap_init(struct heap* heap));</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">HEAP_EXPORT(struct heap_node* heap_min(const struct heap* heap));</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">HEAP_EXPORT(void heap_insert(struct heap* heap,</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">                             struct heap_node* newnode,</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">                             heap_compare_fn less_than));</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">HEAP_EXPORT(void heap_remove(struct heap* heap,</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">                             struct heap_node* node,</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">                             heap_compare_fn less_than));</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">HEAP_EXPORT(void heap_dequeue(struct heap* heap, heap_compare_fn less_than));</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">/* Implementation follows. */</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">HEAP_EXPORT(void heap_init(struct heap* heap)) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  heap-&gt;min = NULL;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  heap-&gt;nelts = 0;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">}</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">HEAP_EXPORT(struct heap_node* heap_min(const struct heap* heap)) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  return heap-&gt;min;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">}</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">/* Swap parent with child. Child moves closer to the root, parent moves away. */</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">static void heap_node_swap(struct heap* heap,</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">                           struct heap_node* parent,</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">                           struct heap_node* child) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  struct heap_node* sibling;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  struct heap_node t;</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  t = *parent;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  *parent = *child;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  *child = t;</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  parent-&gt;parent = child;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (child-&gt;left == child) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    child-&gt;left = parent;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    sibling = child-&gt;right;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  } else {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    child-&gt;right = parent;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    sibling = child-&gt;left;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  }</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (sibling != NULL)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    sibling-&gt;parent = child;</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (parent-&gt;left != NULL)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    parent-&gt;left-&gt;parent = parent;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (parent-&gt;right != NULL)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    parent-&gt;right-&gt;parent = parent;</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (child-&gt;parent == NULL)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    heap-&gt;min = child;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  else if (child-&gt;parent-&gt;left == parent)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    child-&gt;parent-&gt;left = child;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  else</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    child-&gt;parent-&gt;right = child;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">}</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">HEAP_EXPORT(void heap_insert(struct heap* heap,</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">                             struct heap_node* newnode,</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">                             heap_compare_fn less_than)) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  struct heap_node** parent;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  struct heap_node** child;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  unsigned int path;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  unsigned int n;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  unsigned int k;</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  newnode-&gt;left = NULL;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  newnode-&gt;right = NULL;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  newnode-&gt;parent = NULL;</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  /* Calculate the path from the root to the insertion point.  This is a min</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">   * heap so we always insert at the left-most free node of the bottom row.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">   */</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  path = 0;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  for (k = 0, n = 1 + heap-&gt;nelts; n &gt;= 2; k += 1, n /= 2)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    path = (path &lt;&lt; 1) | (n &amp; 1);</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  /* Now traverse the heap using the path we calculated in the previous step. */</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  parent = child = &amp;heap-&gt;min;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  while (k &gt; 0) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    parent = child;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    if (path &amp; 1)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      child = &amp;(*child)-&gt;right;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    else</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      child = &amp;(*child)-&gt;left;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    path &gt;&gt;= 1;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    k -= 1;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  }</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  /* Insert the new node. */</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  newnode-&gt;parent = *parent;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  *child = newnode;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  heap-&gt;nelts += 1;</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  /* Walk up the tree and check at each node if the heap property holds.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">   * It's a min heap so parent &lt; child must be true.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">   */</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  while (newnode-&gt;parent != NULL &amp;&amp; less_than(newnode, newnode-&gt;parent))</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    heap_node_swap(heap, newnode-&gt;parent, newnode);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">}</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">HEAP_EXPORT(void heap_remove(struct heap* heap,</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">                             struct heap_node* node,</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">                             heap_compare_fn less_than)) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  struct heap_node* smallest;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  struct heap_node** max;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  struct heap_node* child;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  unsigned int path;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  unsigned int k;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  unsigned int n;</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (heap-&gt;nelts == 0)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    return;</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  /* Calculate the path from the min (the root) to the max, the left-most node</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">   * of the bottom row.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">   */</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  path = 0;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  for (k = 0, n = heap-&gt;nelts; n &gt;= 2; k += 1, n /= 2)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    path = (path &lt;&lt; 1) | (n &amp; 1);</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  /* Now traverse the heap using the path we calculated in the previous step. */</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  max = &amp;heap-&gt;min;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  while (k &gt; 0) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    if (path &amp; 1)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      max = &amp;(*max)-&gt;right;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    else</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      max = &amp;(*max)-&gt;left;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    path &gt;&gt;= 1;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    k -= 1;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  }</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  heap-&gt;nelts -= 1;</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  /* Unlink the max node. */</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  child = *max;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  *max = NULL;</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (child == node) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    /* We're removing either the max or the last node in the tree. */</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    if (child == heap-&gt;min) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      heap-&gt;min = NULL;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    }</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    return;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  }</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  /* Replace the to be deleted node with the max node. */</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  child-&gt;left = node-&gt;left;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  child-&gt;right = node-&gt;right;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  child-&gt;parent = node-&gt;parent;</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (child-&gt;left != NULL) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    child-&gt;left-&gt;parent = child;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  }</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (child-&gt;right != NULL) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    child-&gt;right-&gt;parent = child;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  }</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (node-&gt;parent == NULL) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    heap-&gt;min = child;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  } else if (node-&gt;parent-&gt;left == node) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    node-&gt;parent-&gt;left = child;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  } else {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    node-&gt;parent-&gt;right = child;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  }</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  /* Walk down the subtree and check at each node if the heap property holds.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">   * It's a min heap so parent &lt; child must be true.  If the parent is bigger,</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">   * swap it with the smallest child.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">   */</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  for (;;) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    smallest = child;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    if (child-&gt;left != NULL &amp;&amp; less_than(child-&gt;left, smallest))</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      smallest = child-&gt;left;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    if (child-&gt;right != NULL &amp;&amp; less_than(child-&gt;right, smallest))</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      smallest = child-&gt;right;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    if (smallest == child)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      break;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    heap_node_swap(heap, child, smallest);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  }</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  /* Walk up the subtree and check that each parent is less than the node</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">   * this is required, because `max` node is not guaranteed to be the</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">   * actual maximum in tree</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">   */</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  while (child-&gt;parent != NULL &amp;&amp; less_than(child, child-&gt;parent))</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    heap_node_swap(heap, child-&gt;parent, child);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">}</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">HEAP_EXPORT(void heap_dequeue(struct heap* heap, heap_compare_fn less_than)) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  heap_remove(heap, heap-&gt;min, less_than);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">}</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">#undef HEAP_EXPORT</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">#endif  /* UV_SRC_HEAP_H_ */</font><br/></div></div><div><br/></div><div><br/></div>

<hr class="tail-hr">
<div class="tail-licenses">
<p>版权声明：自由转载-非商用-非衍生-保持署名(<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">创意共享3.0许可证</a>)</p>
<p>文章作者：Pooky (<a href="mailto:guananddu@icloud.com">guananddu@icloud.com</a>)</p>
<p>更新日期：Fri Jan 06 2017 15:01:58 GMT+0800 (CST)</p>
</div></body></html>