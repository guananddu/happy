<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 6.10 (454267)"/><meta name="author" content="管伟"/><meta name="created" content="2017-01-08 07:18:24 +0000"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2017-01-09 07:21:17 +0000"/><title>stream 模块深究 - 6 - Writable 相关函数</title></head><body><style>
    a { color: #43B0D6 !important; }
    a:visited { color: #7b7ed2 !important; }
    .title-p { font-size:12px; color:gray; }
    .title-hr { margin-bottom: 20px; }
    .tail-hr { margin-top: 20px; }
    .tail-licenses { border:1px dashed lightgray; margin:20px 0 20px 0; padding:20px; font-size:14px; }
</style>
<h2>stream 模块深究 - 6 - Writable 相关函数</h2>
<p class="title-p">版权声明：自由转载-非商用-非衍生-保持署名(<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">创意共享3.0许可证</a>)</p>
<p class="title-p">文章作者：Pooky (<a href="mailto:guananddu@icloud.com">guananddu@icloud.com</a>)</p>
<hr class="title-hr"><div>此节继续分析测试代码中的函数调用实现：</div><div><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'Menlo';font-size:13.5pt;"><span style="color:#cc7832;font-weight:bold;">const </span>fs = require( <span style="color:#6a8759;">'fs' </span>)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;font-weight:bold;">const </span>path = require( <span style="color:#6a8759;">'path' </span>)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;font-weight:bold;">const </span>stream = require( <span style="color:#6a8759;">'stream' </span>)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;"><br/></span><span style="color:#cc7832;font-weight:bold;">const </span>filePath = path.<span style="color:#ffc66d;">resolve</span>( __dirname<span style="color:#cc7832;">, </span><span style="color:#6a8759;">'output.txt' </span>)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;"><br/></span><span style="color:#cc7832;font-weight:bold;">const </span>writeable = fs.<span style="color:#ffc66d;">createWriteStream</span>( filePath<span style="color:#cc7832;">, </span>{<br/>    <span style="color:#9876aa;">defaultEncoding</span>: <span style="color:#6a8759;">'utf8'<br/></span>} )<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;"><br/></span>writeable.<span style="color:#ffc66d;">on</span>( <span style="color:#6a8759;">'close'</span><span style="color:#cc7832;">, </span>o =&gt; {<br/>    <span style="color:#9876aa;">console</span>.<span style="color:#ffc66d;">log</span>( <span style="color:#6a8759;">'close event!'</span><span style="color:#cc7832;">, </span>o )<span style="color:#cc7832;">;<br/></span>} )<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;"><br/></span>writeable.<span style="color:#ffc66d;">on</span>( <span style="color:#6a8759;">'finish'</span><span style="color:#cc7832;">, </span>o =&gt; {<br/>    <span style="color:#9876aa;">console</span>.<span style="color:#ffc66d;">log</span>( <span style="color:#6a8759;">'finish event!'</span><span style="color:#cc7832;">, </span>o )<span style="color:#cc7832;">;<br/></span>} )<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;"><br/></span>writeable.<span style="color:#ffc66d;">write</span>( <span style="color:#6a8759;">'abc</span><span style="color:#cc7832;">\n</span><span style="color:#6a8759;">' </span>)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;"><br/></span>writeable.<span style="color:#ffc66d;">cork</span>()<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;"><br/></span>writeable.<span style="color:#ffc66d;">write</span>( <span style="color:#6a8759;">'测试输出</span><span style="color:#cc7832;">\n</span><span style="color:#6a8759;">' </span>)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;"><br/></span>writeable.<span style="color:#ffc66d;">uncork</span>()<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;"><br/></span>writeable.<span style="color:#ffc66d;">write</span>( Buffer.<span style="color:#ffc66d;">from</span>( <span style="color:#6a8759;">'from buffer</span><span style="color:#cc7832;">\n</span><span style="color:#6a8759;">' </span>) )<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;"><br/></span>writeable.<span style="color:#ffc66d;">end</span>( <span style="color:#6a8759;">'the end' </span>)<span style="color:#cc7832;">;<br/></span>
</pre><br/></div><div>测试代码中用的变量起名用的是 writeable，下面分析中，使用 writable，两者的含义都一样，为了和文档保持统一，下面均使用 writable：<br/></div><div><br/></div><div>首先，on 函数的调用，并没有太多特殊之处，不像之前分析过的 readable 的 on 需要处理特殊逻辑，writable 的 on 函数直接调用 EventEmitter.prototype.addListener 函数来绑定事件监听器，不再具体分析，之后会专门对 EventEmitter 进行剖析。</div><div><br/></div><div>来看第一次的 write 函数调用：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">writeable.write( 'abc\n’ );</font><br/></div></div><div><br/></div><div>进入函数内部：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">Writable.prototype.write = function(chunk, encoding, cb) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  var state = this._writableState; // 获取 writableState 对象</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  var ret = false;</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  . . .</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (chunk instanceof Buffer) // 如果 chunk 是 buffer</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    encoding = 'buffer';</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  else if (!encoding)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    encoding = state.defaultEncoding; // 如果非 buffer 且没有传入 encoding 则为默认 utf8</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (typeof cb !== 'function')</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    cb = nop; // 统一化处理 callback 函数</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (state.ended)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    writeAfterEnd(this, cb);</font></div><div><br/></div><div><span>  // 来看看针对 validChunk 函数的说明：</span><br/></div><div><span><font style="font-size: 12px; color: rgb(51, 51, 51);">  // If we get something that is not a buffer, string, null, or undefined,</font></span></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // and we're not in objectMode, then that's an error.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // Otherwise stream chunks are all considered to be of length=1, and the</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // watermarks determine how many objects to keep in the buffer, rather than</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // how many bytes or characters.</font><span><br/></span></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // validChunk 用来验证 chunk 的正确性</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  else if (validChunk(this, state, chunk, cb)) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    state.pendingcb++; // 每次调用 write 函数，state.pendingcb 就会增加计数</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    // writeOrBuffer 函数分析见下</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    ret = writeOrBuffer(this, state, chunk, encoding, cb);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  }</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  return ret;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">};</font><br/></div></div><div><br/></div><div>该走入 writeOrBuffer 函数，先看下此时的运行状态：</div><div><br/></div><div><img src="stream%20%E6%A8%A1%E5%9D%97%E6%B7%B1%E7%A9%B6%20-%206%20-%20Writable%20%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0.resources/B32D3787-1BB1-43D3-A6DB-57ECAA2BA00B.png" height="auto" width="100%"/><br/></div><div><br/></div><div>进入 writeOrBuffer 的具体运行函数内部：</div><div><br/></div><div/><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">// 一定要留意这里的注释</font></div><div><font style="color: rgb(51, 51, 51); font-size: 12px;">// </font><font style="font-size: 12px;" color="#ff2600">if we're already writing something, then just put this</font></div><div><font style="color: rgb(51, 51, 51); font-size: 12px;">// </font><font style="font-size: 12px;" color="#ff2600">in the queue, and wait our turn</font><font style="color: rgb(51, 51, 51); font-size: 12px;">.  Otherwise, call _write</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">// If we return false, then we need a drain event, so set that flag.</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">function writeOrBuffer(stream, state, chunk, encoding, cb) {</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // decodeChunk 函数主要针对 chunk 为字符串类型时候的处理，将此字符串转换为特定 encoding 的 Buffer</span><br/></font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><span>  // 通过 Buffer.from 函数来实现，见下面的截图</span><br/></span></font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  chunk = decodeChunk(state, chunk, encoding);</font></div><div style="color: rgb(51, 51, 51);"><span>  // chunk 统一为 Buffer 实例</span><br/></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (chunk instanceof Buffer)</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">    encoding = 'buffer';</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  var len = state.objectMode ? 1 : chunk.length; // 确定写入长度</font></div><div style="color: rgb(51, 51, 51);"><br/></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  state.length += len; // 记录待 write 的总长</font></div><div style="color: rgb(51, 51, 51);"><br/></div><div><font color="#333333">  // </font><font color="#ff2600">再来复习一下 Writable.prototype.write 函数的返回值的意义：</font><br/></div><div style="color: rgb(51, 51, 51);"><span><span>  // <font style="font-size: 12px; color: rgb(51, 51, 51);">Returns: &lt;Boolean&gt; false if the stream wishes for the </font></span></span></div><div style="color: rgb(51, 51, 51);"><span><span><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // </span>calling code to wait for the 'drain' event to be emitted </font></span></span></div><div style="color: rgb(51, 51, 51);"><span><span><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // </span>before continuing to write additional data; otherwise true.</font></span><br/></span></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  var ret = state.length &lt; state.highWaterMark; </font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  // we must ensure that previous needDrain will not be reset to false.</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (!ret)</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">    state.needDrain = true;</font></div><div style="color: rgb(51, 51, 51);"><br/></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (state.writing || state.corked) {</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">    . . . // 第一次调用 write 的逻辑不会走入这里，先行忽略</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  } else {</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    // 最终走入 doWrite 函数</span><br/></font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">    doWrite(stream, state, false, len, chunk, encoding, cb);</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  }</font></div><div style="color: rgb(51, 51, 51);"><br/></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">  return ret;</font></div><div style="color: rgb(51, 51, 51);"><font style="font-size: 12px; color: rgb(51, 51, 51);">}</font><br/></div></div><div><br/></div><div>decodeChunk 函数的内部细节截图：</div><div><br/></div><div><img src="stream%20%E6%A8%A1%E5%9D%97%E6%B7%B1%E7%A9%B6%20-%206%20-%20Writable%20%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0.resources/60BA8F44-A601-4B60-9D6A-0FB98BA81B71.png" height="auto" width="100%"/><br/></div><div><br/></div><div>来看 doWrite 函数的执行断点截图：</div><div><br/></div><div><img src="stream%20%E6%A8%A1%E5%9D%97%E6%B7%B1%E7%A9%B6%20-%206%20-%20Writable%20%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0.resources/804D3FFF-5188-4DBC-882F-46644DC8D63A.png" height="auto" width="100%"/><br/></div><div><br/></div><div>如图所示，state.writelen 记录此次 write 调用时候的写入长度；state.writecb 为回调函数；state.writing 字段被标记为 true；同时需要注意的是，stream._write 函数的回调函数是：state.onwrite 函数（在上一节初始化中有这个函数的出现）：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>// 在 writableState 被初始化的时候：</div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">// the callback that's passed to _write(chunk,cb)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">this.onwrite = function(er) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  onwrite(stream, er); // 后面再分析</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">};</font><br/></div></div><div><br/></div><div>先看进入：stream._write(chunk, encoding, state.onwrite) 的 fs 实现是什么样子的：</div><div><br/></div><div/><div style="box-sizing: border-box; padding: 8px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">WriteStream.prototype._write = function(data, encoding, cb) {</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">  . . .</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><span>  // 当进入到 _write 此函数内部的时候，很可能 WriteStream.prototype.open 函数中的 fs.open 函数的回调函数还没有执行完毕</span><br/></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><span><span>  // 当 fs.open 的回调函数执行完毕的时候，this.fd 才被赋值</span><br/></span></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (typeof this.fd !== 'number’)</font></div><div><font><font face="Monaco, Menlo, Consolas, Courier New, monospace" color="#333333"><span style="font-size: 12px;">    // 所以此时只需要结束 _write 的执行，并且等待 fs.open 回调函数中的 this.emit( ‘open’, fs ) 事件被触发</span></font><br/></font></div><div><font><font face="Monaco, Menlo, Consolas, Courier New, monospace" color="#333333"><span style="font-size: 12px;"><span>    // 然后再次调用 this._write 函数来继续执行后续逻辑</span><br/></span></font></font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">    return this.once('open', function() {</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">      this._write(data, encoding, cb);</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">    });</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><span>  // 真正进入后面的逻辑我们后续继续分析</span><br/></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">  . . .</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">};</font><br/></div></div><div><br/></div><div><hr/></div><div><br/></div><div>测试代码执行完毕 writeable.write( ’abc\n’ ) 之后（还没有真正写入文件），继续往下执行：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">writeable.cork();</font><br/></div></div><div><br/></div><div>第一次执行到这里的时候，看一下运行截图：</div><div><br/></div><div><img src="stream%20%E6%A8%A1%E5%9D%97%E6%B7%B1%E7%A9%B6%20-%206%20-%20Writable%20%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0.resources/F73A4984-0B3B-4546-B2A1-1045F1ECEFAD.png" height="auto" width="100%"/><br/></div><div><br/></div><div>在没有执行过 cork 时，state.corked === 0 ，在 WritableStream 对象被初始化的时候赋予 0。执行完 writeable.cork()，之后，state.corked === 1。</div><div><br/></div><div><hr/></div><div><br/></div><div>测试代码继续往下执行：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">writeable.write( '测试输出\n’ );</font><br/></div></div><div><br/></div><div>再次走一遍上面对 write 函数的细节：</div><div><br/></div><div>Writable.prototype.write 中：state.pendingcb ++，并且走入 writeOrBuffer 函数：</div><div><br/></div><div><img src="stream%20%E6%A8%A1%E5%9D%97%E6%B7%B1%E7%A9%B6%20-%206%20-%20Writable%20%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0.resources/3F25C84A-78CB-4C58-8C02-90A0A973EAF3.png" height="auto" width="100%"/><br/></div><div><br/></div><div>再次走入 writeOrBuffer 函数后，看一下各个内部变量的状态：</div><div><br/></div><div><img src="stream%20%E6%A8%A1%E5%9D%97%E6%B7%B1%E7%A9%B6%20-%206%20-%20Writable%20%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0.resources/BB200B42-C891-49FD-A38A-23AC6FAD5F99.png" height="auto" width="100%"/><br/></div><div><br/></div><div>上一次调用的 write( ‘abc\n’ ) 还没有真正被写入文件，所以，这次的 write( '测试输出\n’ ) 调用，buffer.length 为 13，13 + 4 === 17；state.length 记录目前总共需要被 write 的字节长度为 17；而且，目前的 state.writing 状态为 true；因为调用了一次 writeable.cork() ，故 state.corked === 1。</div><div><br/></div><div>这次调用的 writeOrBuffer：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">// if we're already writing something, then just put this</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">// in the queue, and wait our turn.  Otherwise, call _write</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">// If we return false, then we need a drain event, so set that flag.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">function writeOrBuffer(stream, state, chunk, encoding, cb) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  . . .</font></div><div><span>  // 会进入此分支</span><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (state.writing || state.corked) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    var last = state.lastBufferedRequest; // null</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    // 这里初始化了一个 WriteReq 对象，见下分析</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><span>    // 初始化好以后，将它赋给 <font style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51);">state.lastBufferedRequest</font></span><br/></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    if (last) { // 此次进入时，last 为 null</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      last.next = state.lastBufferedRequest;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    } else {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    <span>  // 这次的 write 调用因为 state.writing 和 state.corked 的原因被放入 state.bufferedRequest</span></span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      state.bufferedRequest = state.lastBufferedRequest;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    }</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    // 计数器加一</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    state.bufferedRequestCount += 1;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  } else {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    doWrite(stream, state, false, len, chunk, encoding, cb);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  }</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  return ret;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">}</font><br/></div></div><div><br/></div><div>WriteReq 对象的初始化比较简单：</div><div><br/></div><div><img src="stream%20%E6%A8%A1%E5%9D%97%E6%B7%B1%E7%A9%B6%20-%206%20-%20Writable%20%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0.resources/13342A2A-1B54-4186-878B-D25AC942401B.png" height="auto" width="100%"/><br/></div><div><br/></div><div><hr/></div><div><br/></div><div>测试代码继续往下走：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">writeable.uncork();</font><br/></div></div><div><br/></div><div>uncork 函数与 cork 函数相对应，来看其执行：</div><div><br/></div><div><img src="stream%20%E6%A8%A1%E5%9D%97%E6%B7%B1%E7%A9%B6%20-%206%20-%20Writable%20%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0.resources/1BA36C34-4F82-4087-BB16-9E1C7B0F9CEA.png" height="auto" width="100%"/><br/></div><div><br/></div><div>因为不符合 clearBuffer 的条件（state.writing 仍旧为 true），所以不会进行 clearBuffer，不过，clearBuffer 的函数体可以留意一下其内容：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">// if there's something in the buffer waiting, then process it</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">// 如果 buffer 中仍旧有什么东西存在，则处理它们</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">function clearBuffer(stream, state) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  state.bufferProcessing = true; // 标记正在处理当中</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  var entry = state.bufferedRequest; // 拿到被 buffered 的 request</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (stream._writev &amp;&amp; entry &amp;&amp; entry.next) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    . . . // _writev 的情形暂不分析</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  } else {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    // Slow case, write chunks one-by-one</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    while (entry) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      var chunk = entry.chunk;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      var encoding = entry.encoding;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      var cb = entry.callback;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      var len = state.objectMode ? 1 : chunk.length;</font></div><div><span>    <span>  // 获取第一个要被处理的 entry，调用 doWrite 函数</span></span><br/></div><div><span><span><span>    <span>  // doWrite 函数上面有分析，内部调用 stream._write 函数【fs 的实现层】</span></span><br/></span></span></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      doWrite(stream, state, false, len, chunk, encoding, cb);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      entry = entry.next; // 下一个</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      // if we didn't call the onwrite immediately, then</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      // it means that we need to wait until it does.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      // also, that means that the chunk and cb are currently</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      // being processed, so move the buffer counter past them.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      if (state.writing) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">        break;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      }</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    }</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    if (entry === null)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      state.lastBufferedRequest = null;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  }</font></div><div><span>  // 清空</span><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  state.bufferedRequestCount = 0;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  state.bufferedRequest = entry;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  state.bufferProcessing = false;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">}</font><br/></div></div><div><br/></div><div><hr/></div><div><br/></div><div>继续看测试代码接下来：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">writeable.write( Buffer.from( 'from buffer\n' ) );</font><br/></div></div><div><br/></div><div>调用流程同样是：</div><div><br/></div><div>writeable.write[ state.pendingcb++ ] -&gt; writeOrBuffer[ state.length += len ]</div><div><br/></div><div>在 writeOrBuffer 内部，因为 state.writing === true，所以，此次的 write 请求仍旧会被写入 writeReq 队列中去：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">. . .  </font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (state.writing || state.corked) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    var last = state.lastBufferedRequest; // 目前正等待 write 的 writeReq</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    // 初始化此次的 writeReq</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    if (last) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    <span>  // 将这次新创建的的 writeReq 对象 append 至更早的 writeReq 后</span></span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      last.next = state.lastBufferedRequest;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    } else {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      state.bufferedRequest = state.lastBufferedRequest;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    }</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    // 同样需要 ++</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    state.bufferedRequestCount += 1;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  } else {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    doWrite(stream, state, false, len, chunk, encoding, cb);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  }</font><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">. . .</font></div></div><div><br/></div><div><hr/></div><div><br/></div><div>步进至最后一句：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">writeable.end( 'the end' );</font><br/></div></div><div><br/></div><div>时，所有的待写入的 string / buffer 都被“缓存”到了 writeReq 队列中去了（除去第一次调用的 write( ‘abc\n’ )，第一次调用在等待 WriteStream.prototype._write 中的 open 事件），还没有真正写入文件中去，因为 state.writing 一直为 true。只有当 Writable.prototype.open 的底层函数 fs.open 的回调函数被触发（state.onwrite）时，state.writing 才被恢复为 false。state.onwrite 函数下节再来分析，先来看 end 函数，函数执行时的截图为：</div><div><br/></div><div><img src="stream%20%E6%A8%A1%E5%9D%97%E6%B7%B1%E7%A9%B6%20-%206%20-%20Writable%20%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0.resources/B1AAA552-E0CC-4845-9E03-F872EDA798EB.png" height="auto" width="100%"/><br/></div><div><br/></div><div>可看到，this.write(chunk, encoding) 会被调用一次，调用完毕后，state.bufferedRequestCount === 3；之后进入 endWriteable 函数：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">function endWritable(stream, state, cb) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // cb == undefined</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  state.ending = true; // 表明正在结束的过程中</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  finishMaybe(stream, state);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (cb) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    . . . // 先不关心 cb 的处理</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  }</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  state.ended = true; // 表明已经结束</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  stream.writable = false;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">}</font><br/></div></div><div><br/></div><div>继续进入 finishMaybe 函数里面，此函数内部会先进行 needFinish 的判断：</div><div><br/></div><div><img src="stream%20%E6%A8%A1%E5%9D%97%E6%B7%B1%E7%A9%B6%20-%206%20-%20Writable%20%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0.resources/DEB7DA9A-575B-40C3-9617-550AFF243CA6.png" height="auto" width="100%"/><br/></div><div><br/></div><div>由截图可知，还不满足 finish 的条件，最终执行完 end 函数，合着此次的 end 函数执行，只是调用了一下 write 函数，然后把 state.ending 标记为 true，把 state.ended 标记为 true，把 stream.writable 标记为 false。 而真正的 prefinish 函数调用以及 finish 事件的触发还没有开始。</div><div><br/></div><div>测试代码的最后一句都执行完毕了，为什么还没有真正开始写入呢？当然是在等待 state.onwrite 函数的执行。</div><div><br/></div><div>state.onwrite 下一节分析。</div><div><br/></div>

<hr class="tail-hr">
<div class="tail-licenses">
<p>版权声明：自由转载-非商用-非衍生-保持署名(<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">创意共享3.0许可证</a>)</p>
<p>文章作者：Pooky (<a href="mailto:guananddu@icloud.com">guananddu@icloud.com</a>)</p>
<p>更新日期：Mon Jan 09 2017 15:25:04 GMT+0800 (CST)</p>
</div></body></html>