<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 6.10 (454267)"/><meta name="altitude" content="53.34476852416992"/><meta name="author" content="管伟"/><meta name="created" content="2017-02-14 06:40:59 +0000"/><meta name="latitude" content="39.97078575963447"/><meta name="longitude" content="116.3233947161891"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2017-03-01 13:23:54 +0000"/><title>fs 模块深究 - 4 - 子线程的执行流程</title></head><body><style>
    a { color: #43B0D6 !important; }
    a:visited { color: #7b7ed2 !important; }
    .title-p { font-size:12px; color:gray; }
    .title-hr { margin-bottom: 20px; }
    .tail-hr { margin-top: 20px; }
    .tail-licenses { border:1px dashed lightgray; margin:20px 0 20px 0; padding:20px; font-size:14px; }
</style>
<h2>fs 模块深究 - 4 - 子线程的执行流程</h2>
<p class="title-p">版权声明：自由转载-非商用-非衍生-保持署名(<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">创意共享3.0许可证</a>)</p>
<p class="title-p">文章作者：Pooky (<a href="mailto:guananddu@icloud.com">guananddu@icloud.com</a>)</p>
<hr class="title-hr"><div>先补充一下关于互斥锁和条件变量的知识，再对上一节中初始化线程池中表述模糊的地方再次澄清一下：</div><div><br/></div><div>如同上一节中，以 memcached 应用场景举例，node 主线程在初始化自身线程池的过程中，像极了 memcached 线程池的初始化，应该说，这也是一种通用的范式：</div><div><br/></div><div><img src="fs%20%E6%A8%A1%E5%9D%97%E6%B7%B1%E7%A9%B6%20-%204%20-%20%E5%AD%90%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.resources/F8023C14-B4DE-4E28-944A-8B9D63689C90.png" height="auto" width="100%"/><br/></div><div><br/></div><div>如上图，node 主线程运行至 uv__work_submit 函数内部，在 uv_once 中调用 init_once 函数来初始化线程池，先来看主线程需要调用的 post 函数：</div><div><br/></div><div><img src="fs%20%E6%A8%A1%E5%9D%97%E6%B7%B1%E7%A9%B6%20-%204%20-%20%E5%AD%90%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.resources/D328EE4B-E221-4F6F-896A-E6AD494D43E0.png" height="auto" width="100%"/><br/></div><div><br/></div><div>主线程在 post 函数的第一句中，开始尝试获取 mutex 互斥锁，所以，这里就会遇到多线程竞争问题，因为，调用 post 之前，线程池已经开始初始化，且可能线程池中的某个子线程已经获取了互斥锁 mutex，如果主线程没有获取到 mutex 互斥锁，则会在 108 行等待，直至 mutex 被释放。</div><div><br/></div><div>而子线程在被主线程创建出来之后，开始进入自己的执行上下文：</div><div><br/></div><div><img src="fs%20%E6%A8%A1%E5%9D%97%E6%B7%B1%E7%A9%B6%20-%204%20-%20%E5%AD%90%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.resources/C2236C2C-087A-4828-80EF-CDA6D02E7982.png" height="auto" width="100%"/><br/></div><div><br/></div><div>每一个子线程先获取 mutex 锁，尝试检查 wq 链表是不是存在任务，如果为空，则说明目前没有任务，那么 idle_threads 用来记录当前空闲的线程数目。这里需要注意的是：uv_cond_wait 函数的调用，会释放 mutex 锁，同时开始“监听” cond 条件变量，也就是开始等待“有任务”的消息。</div><div><br/></div><div>在所有的子线程都运行至 uv_cond_wait 函数开始等待时，主线程才终于获取了 mutex 锁，开始继续执行 post 之后的逻辑。主线程最终通过：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">. . .  </font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  QUEUE_INSERT_TAIL(&amp;wq, q); // 插入任务</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (idle_threads &gt; 0)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    uv_cond_signal(&amp;cond); // 发送 cond 条件变量信号，通知子线程，开始干活儿了</font><br/></div><div>. . .</div></div><div><br/></div><div><hr/></div><div><br/></div><div>下面来看一个子线程具体是怎么工作的：</div><div><br/></div><div>继续来看 fs.access 操作中，nodejs 的全局线程池中的某一个 worker 工作线程到底是如何操作的，从上一节可知，在 uv_work_submit 函数的最后一条语句 post 执行的时候，会最终发送条件变量信号，并且释放释放互斥锁：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">#0  0x0000000101013147 in post at /Users/mrguan/work/build/node/node-6.6.0/deps/uv/src/threadpool.c:113</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">static void post(QUEUE* q) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  uv_mutex_lock(&amp;mutex);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  QUEUE_INSERT_TAIL(&amp;wq, q);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (idle_threads &gt; 0)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    uv_cond_signal(&amp;cond);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  uv_mutex_unlock(&amp;mutex);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">}</font><br/></div></div><div><br/></div><div>上述代码中的：uv_cond_signal 语句最终发送条件变量信号，致使 worker 开始工作，在此次调试中，Thread 8 被调度接收此条件变量信号，而其他的线程则仍旧在 uv_cond_wait(&amp;cond, &amp;mutex) 处等待新信号：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">/* To avoid deadlock with uv_cancel() it's crucial that the worker</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"> * never holds the global mutex and the loop-local mutex at the same time.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"> */</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">static void worker(void* arg) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  struct uv__work* w; // 注意 w 的类型</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  QUEUE* q;</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  (void) arg;</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  for (;;) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    uv_mutex_lock(&amp;mutex);</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    while (QUEUE_EMPTY(&amp;wq)) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      idle_threads += 1;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    <span>  // Thread 8 从此处被“唤醒”开始工作</span></span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      uv_cond_wait(&amp;cond, &amp;mutex);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      idle_threads -= 1; // 减少空闲记录</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    }</font></div><div><span>    // 获取节点</span><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    q = QUEUE_HEAD(&amp;wq);</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    if (q == &amp;exit_message)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      uv_cond_signal(&amp;cond);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    else {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      QUEUE_REMOVE(q); // 从全局链表 wq 中移除当前要处理的 q 节点</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      QUEUE_INIT(q);  /* Signal uv_cancel() that the work req is</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">                             executing. */</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    }</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    uv_mutex_unlock(&amp;mutex); // 解锁 mutex 互斥量</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    if (q == &amp;exit_message)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      break;</font></div><div><span>    // 关于 QUEUE_DATA 的解释见下</span><br/></div><div><span><span>    // 以及调用至此处的运行栈截图见下</span><br/></span></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    w = QUEUE_DATA(q, struct uv__work, wq);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    // 此一步，把 w 自身作为参数，调用 w-&gt;work 函数</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    w-&gt;work(w); // 此调用分析见下</font></div><div><span>    // 将要把 w-&gt;wq 插入 loop-&gt;wq 全局队列中，所以需要先获取 wq_mutex 互斥锁</span><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    uv_mutex_lock(&amp;w-&gt;loop-&gt;wq_mutex);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    // 置空 w-&gt;work 回调函数</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    w-&gt;work = NULL;  /* Signal uv_cancel() that the work req is done</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">                        executing. */</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    QUEUE_INSERT_TAIL(&amp;w-&gt;loop-&gt;wq, &amp;w-&gt;wq); // 执行插入</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    // uv_async_send 函数的含义没有搞清楚</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    uv_async_send(&amp;w-&gt;loop-&gt;wq_async);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    uv_mutex_unlock(&amp;w-&gt;loop-&gt;wq_mutex); // 解锁 loop-&gt;wq_mutext</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  }</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">}</font></div><div><br/></div></div><div><br/></div><div>关于 QUEUE_DATA 的宏调用：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">/* Public macros. */</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">#define QUEUE_DATA(ptr, type, field)                                          \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  ((type *) ((char *) (ptr) - offsetof(type, field)))</font><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><br/></font></div><div>// <font style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51);">ptr 是一个 field 类型指针，</font>此宏通过对 type 中 field 字段的偏移量进行计算，通过 ptr 指针“反推”出 ptr 所在的 type 类型结构体的指针</div></div><div><br/></div><div>c 内置函数：offsetof 函数的解释：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">offsetof</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">Defined in header &lt;stddef.h&gt;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">#define offsetof(type, member) /*implementation-defined*/</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">The macro offsetof expands to a constant of type size_t, the value of which is the offset, in bytes, from the beginning of an object of specified type to its specified member, including padding if any.</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">Example</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">#include &lt;stdio.h&gt;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">#include &lt;stddef.h&gt;</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">struct S {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    char c;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    double d;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">};</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">int main(void)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">{</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    printf("the first element is at offset %zu\n", offsetof(struct S, c));</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    printf("the double is at offset %zu\n", offsetof(struct S, d));</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">}</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">Possible output:</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">the first element is at offset 0</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">the double is at offset 8</font><br/></div></div><div><br/></div><div>当获取到 uv__work 类型的 w 之后的调用栈：</div><div><br/></div><div><img src="fs%20%E6%A8%A1%E5%9D%97%E6%B7%B1%E7%A9%B6%20-%204%20-%20%E5%AD%90%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.resources/70FA14DC-B76F-46EC-BB90-919D6776A6C8.png" height="auto" width="100%"/><br/></div><div><br/></div><div>来看看 w-&gt;work(w) 的具体调用，w-&gt;work 指向的是：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51);">#0  0x000000010101a30c in uv__fs_work at /Users/mrguan/work/build/node/node-6.6.0/deps/uv/src/unix/fs.c:888</font><br/></div><div><font style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51);">// 此位置的 uv__fs_work 函数</font></div></div><div><br/></div><div>函数内部：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">static void uv__fs_work(struct uv__work* w) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  . . .</font></div><div><span>  // container_of 是一个宏定义</span><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  req = container_of(w, uv_fs_t, work_req);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // <font style="font-size: 12px; color: rgb(51, 51, 51);">fs_type     uv_fs_type     UV_FS_ACCESS</font></span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  retry_on_eintr = !(req-&gt;fs_type == UV_FS_CLOSE);</font><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">. . .</font></div></div><div><br/></div><div>container_of 的行为类似于上面见到的 QUEUE_DATA 宏，w 是一个 struct uv__work 类型的指针，而 request 类型中的 struct uv_fs_t 类型中的 work_req 字段即为 struct uv__work 类型，再看看 container_of 宏定义：<br/></div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">#define container_of(ptr, type, member) \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  ((type *) ((char *) (ptr) - offsetof(type, member)))</font><br/></div></div><div><br/></div><div>由此可知，通过 container_of 宏展开调用，struct uv_fs_t 的指针 req 被“反推”出来。看截图：</div><div><br/></div><div><img src="fs%20%E6%A8%A1%E5%9D%97%E6%B7%B1%E7%A9%B6%20-%204%20-%20%E5%AD%90%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.resources/5DA0E42A-10F0-46DD-B53D-CCB76E5BB630.png" height="auto" width="100%"/><br/></div><div><br/></div><div>可以注意到截图中的 req-&gt;fs_type 类型为 UV_FS_ACCESS，而不为 UV_FS_CLOSE。uv__fs_work 函数的后半部分则调用：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>. . .</div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  do {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    errno = 0;</font></div><div>// 这里定义了一个宏</div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">#define X(type, action)                                                       \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  case UV_FS_ ## type:                                                        \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    // r 记录具体 c 函数的调用返回值</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    r = action;                                                               \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    break;</font></div><div><span>    // UV_FS_ACCESS</span><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    switch (req-&gt;fs_type) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    // 所以走入此分支</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><span>    // <font style="font-size: 12px; color: rgb(51, 51, 51);">path  const char *  "/Users/mrguan/work/git/happy/test-nodejs/fs/myfile.txt"  0x0000000104803130</font></span><br/></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><span><span>    // <font style="font-size: 12px; color: rgb(51, 51, 51);">flags     int     6</font></span><br/></span></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    X(ACCESS, access(req-&gt;path, req-&gt;flags));</font><br/></div><div>. . .</div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">#undef X</font><br/></div></div><div><br/></div><div>也就是说，最终调用进入：access(req-&gt;path, req-&gt;flags) 的 c 函数，并且返回值由 r 来记录，来看看 access 函数的作用：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">linux c access函数简介</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">一、函数简介</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">access函数在c语言中的功能是检测文件相对于当前运行此程序的用户所具有的文件访问性。</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">使用access函数需要引入头文件　</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">#include &lt; unistd.h&gt;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">#include &lt; fcntl.h&gt;</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">函数原型:</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">int access(const char *fileName, int mode);</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">参数说明:</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">fileName:为文件路径名</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">mode: </font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">00  检查文件存在性质</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">01  检查是否拥有执行权限</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">02  检查是否拥有写权限</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">04  检查是否拥有读权限</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">06  检查读写权限</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">返回参数</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">执行成功返回０</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">执行异常返回－１</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">系统errno列表:</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">EINVAL: 模式值异常</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">EACCES: 文件或路径名中包含的目录不可访问</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">ELOOP: 解释路径名过程中存在太多的符号连接</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">ENAMETOOLONG:路径名太长</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">ENOENT:路径名中的目录不存在或是无效的符号连接</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">ENOTDIR:路径名中当作目录的组件并非目录</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">EROFS:文件系统只读</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">EFAULT:路径名指向可访问的空间外</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">EIO:输入输出错误</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">ENOMEM:不能获取足够的内核内存</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">ETXTBSY:对程序写入出错</font><br/></div></div><div><br/></div><div>来看 uv__fs_work 函数的最后：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>. . .</div><div><span>  // 不管结果正常与否都要写入 req-&gt;result 字段</span><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (r == -1)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    req-&gt;result = -errno;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  else</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    req-&gt;result = r;</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (r == 0 &amp;&amp; (req-&gt;fs_type == UV_FS_STAT ||</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">                 req-&gt;fs_type == UV_FS_FSTAT ||</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">                 req-&gt;fs_type == UV_FS_LSTAT)) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    req-&gt;ptr = &amp;req-&gt;statbuf;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  }</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">}</font><br/></div></div><div><br/></div><div>uv__fs_work 函数最终执行完毕。</div><div><br/></div><div><hr/></div><div><br/></div><div>最终，线程 Thread 8 中的 for(;;) { … } 执行完一遍。当最终判断 QUEUE_EMPTY(&amp;wq) 仍旧返回 true 时，idle_threads += 1，并且再次进入 uv_cond_wait(&amp;cond, &amp;mutex) 进行等待。 </div><div><br/></div><div><br/></div>

<hr class="tail-hr">
<div class="tail-licenses">
<p>版权声明：自由转载-非商用-非衍生-保持署名(<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">创意共享3.0许可证</a>)</p>
<p>文章作者：Pooky (<a href="mailto:guananddu@icloud.com">guananddu@icloud.com</a>)</p>
<p>更新日期：Wed Mar 01 2017 21:39:49 GMT+0800 (CST)</p>
</div></body></html>