<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 6.10 (454267)"/><meta name="altitude" content="53.13844680786133"/><meta name="author" content="管伟"/><meta name="created" content="2017-02-10 07:39:37 +0000"/><meta name="latitude" content="39.97078333832356"/><meta name="longitude" content="116.3234013536423"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2017-02-14 06:16:09 +0000"/><title>fs 模块深究 - 3 - 线程池的初始化</title></head><body><style>
    a { color: #43B0D6 !important; }
    a:visited { color: #7b7ed2 !important; }
    .title-p { font-size:12px; color:gray; }
    .title-hr { margin-bottom: 20px; }
    .tail-hr { margin-top: 20px; }
    .tail-licenses { border:1px dashed lightgray; margin:20px 0 20px 0; padding:20px; font-size:14px; }
</style>
<h2>fs 模块深究 - 3 - 线程池的初始化</h2>
<p class="title-p">版权声明：自由转载-非商用-非衍生-保持署名(<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">创意共享3.0许可证</a>)</p>
<p class="title-p">文章作者：Pooky (<a href="mailto:guananddu@icloud.com">guananddu@icloud.com</a>)</p>
<hr class="title-hr"><div>接上一节的分析，上一节分析到了 init_once 函数的调用，此函数通过 pthread_once 函数（平台相关）来保证自身在多线程环境下只执行一次。init_once 函数主要用来初始化 nodejs 的全局线程池（下面只分析 unix 架构下的实现）：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">static void init_once(void) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  . . .</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // 定义摘录：</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // static uv_thread_t default_threads[4]; // 默认线线程池大小为 4</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // typedef pthread_t uv_thread_t; // 平台相关，线程 id 类型</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // #define ARRAY_SIZE(a) (sizeof(a) / sizeof((a)[0]))</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // 计算出默认的线程池大小 4</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  nthreads = ARRAY_SIZE(default_threads);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // 通过系统函数 getenv 获取用户自定义的线程池大小</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // val     const char *     NULL     0x0000000000000000 【在这里我们并没有设置这个环境变量，所以忽略其操作】</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  val = getenv("UV_THREADPOOL_SIZE");</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (val != NULL)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    . . .</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (nthreads == 0)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    nthreads = 1;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // #define MAX_THREADPOOL_SIZE 128 【最大限制为 128 大小】</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (nthreads &gt; MAX_THREADPOOL_SIZE)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    nthreads = MAX_THREADPOOL_SIZE;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // static uv_thread_t* threads; threads 是一个指针指向 uv_thread_t【也就是数组 default_threads 的另一个指针】</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  threads = default_threads;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // 如果线程池大小超过了默认大小，则需要“扩充” threads 数组【重新开辟空间符合的大小】</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (nthreads &gt; ARRAY_SIZE(default_threads)) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    threads = uv__malloc(nthreads * sizeof(threads[0]));</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    if (threads == NULL) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      nthreads = ARRAY_SIZE(default_threads);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      threads = default_threads;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    }</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  }</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // 这两个数据结构都为静态【全局条件变量和互斥锁】</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // static uv_cond_t cond; // typedef pthread_cond_t uv_cond_t;【平台相关】</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // static uv_mutex_t mutex; // typedef pthread_mutex_t uv_mutex_t;【平台相关】</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // 初始化条件变量【不深究】</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (uv_cond_init(&amp;cond))</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    abort();</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // 初始化互斥锁【不深究】</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (uv_mutex_init(&amp;mutex))</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    abort();</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // 注意这里的 wq 是一个文件级别的静态全局变量</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // static QUEUE wq; 在 threadpool.c 文件中被定义</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // 双向链表初始化【链表头】</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  QUEUE_INIT(&amp;wq);</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  for (i = 0; i &lt; nthreads; i++)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    // uv_thread_create 函数逻辑不再深究，底层调用平台相关函数：pthread_create 用来创建工作线程</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    if (uv_thread_create(threads + i, worker, NULL))</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      abort();</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // static volatile int initialized;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // 最终，创建完成默认的 4 个工作线程，完成初始化操作，并且标识初始化完毕</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  initialized = 1;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">}</font></div></div><div><br/></div><div>init_once 函数中的线程池初始化逻辑比较复杂，但也是一个在多线程编程领域常见的初始化常用逻辑，参见：<a href="http://www.cnblogs.com/motadou/archive/2010/02/13/1668075.html">http://www.cnblogs.com/motadou/archive/2010/02/13/1668075.html</a> 文章中描述的：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">memcached应用条件变量实例【以 memcached 应用场景举例】</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">背景：memcached是一个多线程结构的程序，主线程负责接收和分发请求，工作者线程实际处理请求。工作者线程在主线程中创建。创建线程后，工作者线程需要完成一些初始化工作，才允许主线程继续执行，所以主线程需要等待这些工作者线程全部初始化完毕。 </font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">这里就使用到了条件变量，大体的流程是这样的： </font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">(1)主线程初始化一个条件变量和一个互斥锁； </font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">(2)主线程创建n个工作者线程； </font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">(3)主线程调用pthread_mutex_lock锁定互斥锁，然后调用pthread_cond_wait在条件变量上wait，等待被唤醒； </font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">(4)子线程执行初始化代码，完毕后获取互斥锁，累加已初始化线程数量，调用pthread_cond_signal给该条件变量发送信号，同时释放互斥锁； </font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">(5)线程调度唤醒主线程，主线程检查现在已经初始化的线程数目，如果都初始化了就释放互斥锁，顺序执行其他代码；如果还没初始化完毕，调用pthread_cond_wait再次等待。</font><br/></div></div><div><br/></div><div>与 memcached 的线程池初始化逻辑类似，nodejs 的主线程也需要在创建 n 个工作线程之前，初始化一个条件变量和一个互斥锁。在函数 init_once（init_once at node/node-6.6.0/deps/uv/src/threadpool.c:177） 执行完毕的时候，在观察 xcode 的 debug 断点栏：</div><div><br/></div><div><img src="fs%20%E6%A8%A1%E5%9D%97%E6%B7%B1%E7%A9%B6%20-%203%20-%20%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96.resources/EA91CF30-CE97-497B-AF30-F26DC506F6C5.png" height="auto" width="100%"/><br/></div><div><br/></div><div>注意上面截图中的 Thread 7 - 10 即为此次新创建出来的 4 个工作线程，同时，这四个工作线程将会执行函数 worker 中的逻辑：</div><div><br/></div><div><img src="fs%20%E6%A8%A1%E5%9D%97%E6%B7%B1%E7%A9%B6%20-%203%20-%20%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96.resources/3921280E-B71C-42A4-8908-F4CAD9AA0F63.png" height="auto" width="100%"/><br/></div><div><br/></div><div>这里有一个细节需要注意，如上图中的代码，工作线程再开始执行的时候，需要先获取互斥锁：uv_mutex_lock(&amp;mutex) ，因为 fs 模块相关函数调用而生成的工作请求作为一个请求节点，被放置在全局链表 wq 中，wq 是一个全局性质的变量，也是一个公用的请求池，所以线程池中的 worker 需要先获取互斥锁，才能处理共享 wq 中的内容。</div><div><br/></div><div>如上图，Thread 7 线程首先获取了互斥锁，然后进入 while 循环中，QUEUE_EMPTY(&amp;wq) 判断目前的 wq 请求链表仍旧为空，进入循环体，static unsigned int idle_threads 变量声明目前的线程池中空闲的 worker 数量，因为 Thread 7 确实为空闲状态，所以需要空闲计数增加 1，之后调用 uv_cond_wait(&amp;cond, &amp;mutex) 来获取条件变量 cond ，并且开始进入休眠状态，开始等待 pthread_cond_signal 函数的调用。【所以代码执行目前终止在 line 75 行】</div><div><br/></div><div>而对于 Thread 8 - 10 ，因为没有竞争过 Thread 7，并没有获取到互斥锁，所以 while 循环都没有进入，就开始等待互斥锁的释放，等待下次内核调度：</div><div><br/></div><div><img src="fs%20%E6%A8%A1%E5%9D%97%E6%B7%B1%E7%A9%B6%20-%203%20-%20%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96.resources/5FA408E4-7BA2-44D4-AECE-8C5539660D68.png" height="auto" width="100%"/><br/></div><div><br/></div><div><hr/></div><div><br/></div><div>4 个 worker 线程初始化完毕，并且已经准备就绪，在来继续看主线程 Thread 1 的工作流，主线程在执行完 init_once 函数完毕之后，继续 uv__work_submit 函数的执行：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">void uv__work_submit(uv_loop_t* loop,</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">                     struct uv__work* w,</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">                     void (*work)(struct uv__work* w),</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">                     void (*done)(struct uv__work* w, int status)) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  uv_once(&amp;once, init_once); // 见上一节的分析</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // 因为 w 按照 &amp;req-&gt;work_req 形式作为参数，故将此次的 req-&gt;work_req 直接作修改【初始化】</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  w-&gt;loop = loop; // 设置关联 loop</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  w-&gt;work = work; // 设置 work 回调函数指针</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  w-&gt;done = done; // 设置 done 回调函数指针</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // 以下着重分析</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  post(&amp;w-&gt;wq);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">}</font><br/></div></div><div><br/></div><div>post 函数做的，即将 req-&gt;work_req-&gt;wq 插入全局的 wq 链表中去：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">static void post(QUEUE* q) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // 首先获取互斥锁 <font style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51);">mutex</font>【 全局的 wq 是共享资源 】</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  uv_mutex_lock(&amp;mutex);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // 插入节点 q</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  QUEUE_INSERT_TAIL(&amp;wq, q);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // 如果有空闲的 worker 工作线程</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (idle_threads &gt; 0)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    // 则发送条件变量 cond 唤醒 worker 来工作</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    uv_cond_signal(&amp;cond);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // 释放互斥锁 mutex</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  uv_mutex_unlock(&amp;mutex);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">}</font><br/></div></div><div><br/></div><div>自此，主线程 Thread 1 中的 uv__work_submit 函数执行完毕，再回顾一下其主要功能：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>- 初始化线程池【按需】</div><div>- 初始化 req-&gt;work_req</div><div>- post req-&gt;work_req-&gt;wq 至全局 wq 双向链表【等待 worker 处理】 </div></div><div><br/></div><div>最终 uv_fs_access 函数也执行结束：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">#define ASYNC_DEST_CALL(func, req, dest, encoding, ...)                       \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  . . .</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // uv_fs_access 函数执行结束</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  int err = uv_fs_ ## func(env-&gt;event_loop(),                                 \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">                           &amp;req_wrap-&gt;req_,                                   \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">                           __VA_ARGS__,                                       \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">                           After);                                            \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  [[ Dispatched 函数定义：</span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><font style="font-size: 12px; color: rgb(51, 51, 51);">        template &lt;typename T&gt;</font></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">        void ReqWrap&lt;T&gt;::Dispatched() {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    <span>    <span>  // 为了之后从 uv_fs_s 中的 data 字段在此获取到 <font style="font-size: 12px; color: rgb(51, 51, 51);">node::FSReqWrap 实例对象</font></span></span></span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><span><span><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    <span>    <span>  // 如下截图</span></span></span><br/></font></span></span></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">          req_.data = this;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">        }</font><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  </span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  ]]</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  req_wrap-&gt;Dispatched();                                                     \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (err &lt; 0) {                                                              \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    . . . // 失败的情况暂不考虑</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  } else {                                                                    \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    // 设置 binding.access 的返回值为 <font style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51);">req_wrap 的持久 handle 对象</font></span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    args.GetReturnValue().Set(req_wrap-&gt;persistent());                        \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  }</font><br/></div></div><div><br/></div><div><img src="fs%20%E6%A8%A1%E5%9D%97%E6%B7%B1%E7%A9%B6%20-%203%20-%20%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96.resources/3ECD7645-DBB9-4168-805B-643D5B60CF1C.png" height="auto" width="100%"/><br/></div><div><br/></div><div>ReqWrap&lt;T&gt; 中的 req_.data 的作用值得留意，因为在 lib_uv 中定义了不同类型的 requests 对象，例如 uv_fs_s 就是一种和文件操作相关的 requests 对象，下降到底层 lib_uv，requests 的实体为 uv_fs_s 类型的结构体。而对应上层的 ReqWrap&lt;T&gt; 即为 ReqWrap&lt;uv_fs_s&gt; 类型，为了将这两者“粘合”，故需要使用一个 uv_fs_s 继承自 uv_req_s 的 public 字段 data 来 hold ReqWrap&lt;uv_fs_s&gt; 类型的实例对象，便于 lib_uv 通知上层对象。</div><div><br/></div><div>在 Access 函数设置完 js 层级的 binding.access 函数的返回值以后，node::Access(v8::FunctionCallbackInfo&lt;v8::Value&gt; const&amp;) at node/node-6.6.0/src/node_file.cc:396 函数最终执行完毕。也就是说，主线程 Thread 1 的 fs.access 函数操作已经执行完毕，开始继续往下执行 js 语句，并且，fs.access 的真正“操作意图”则被发送至线程池中，线程池中的某一个 worker 会执行真正的 access 操作。</div><div><br/></div><div>具体 worker 如何执行 access 的操作，见下一节分析。</div><div><br/></div><div><br/></div>

<hr class="tail-hr">
<div class="tail-licenses">
<p>版权声明：自由转载-非商用-非衍生-保持署名(<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">创意共享3.0许可证</a>)</p>
<p>文章作者：Pooky (<a href="mailto:guananddu@icloud.com">guananddu@icloud.com</a>)</p>
<p>更新日期：Tue Feb 14 2017 14:18:40 GMT+0800 (CST)</p>
</div></body></html>