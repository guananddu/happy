<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 6.10 (454267)"/><meta name="author" content="管伟"/><meta name="created" content="2016-12-23 10:27:26 +0000"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2016-12-26 07:02:39 +0000"/><title>buffer 模块深究 - 2</title></head><body><style>
    a { color: #43B0D6 !important; }
    a:visited { color: #7b7ed2 !important; }
    .title-p { font-size:12px; color:gray; }
    .title-hr { margin-bottom: 20px; }
    .tail-hr { margin-top: 20px; }
    .tail-licenses { border:1px dashed lightgray; margin:20px 0 20px 0; padding:20px; font-size:14px; }
</style>
<h2>buffer 模块深究 - 2</h2>
<p class="title-p">版权声明：自由转载-非商用-非衍生-保持署名(<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">创意共享3.0许可证</a>)</p>
<p class="title-p">文章作者：Pooky (<a href="mailto:guananddu@icloud.com">guananddu@icloud.com</a>)</p>
<hr class="title-hr"><div>示例代码：</div><div><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'Menlo';font-size:13.5pt;"><span style="color:#808080;">// Creates a Buffer of length 20, filled with 0x1.<br/></span><span style="color:#cc7832;font-weight:bold;">const </span>buf2 = Buffer.<span style="color:#ffc66d;">alloc</span>( <span style="color:#6897bb;">20</span><span style="color:#cc7832;">, </span><span style="color:#6897bb;">1 </span>)<span style="color:#cc7832;">;<br/></span><span style="color:#9876aa;">console</span>.<span style="color:#ffc66d;">log</span>( <span style="color:#6a8759;">'buf2: '</span><span style="color:#cc7832;">, </span>buf2 )<span style="color:#cc7832;">;</span>
</pre>即，创建一个长度 20 的 Buffer 实例，且填充 0x1，仍旧走入 Buffer.alloc 函数：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">Buffer.alloc = function(size, fill, encoding) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // size: 20; fill: 1</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  assertSize(size);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // 走入 if 分支</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (size &gt; 0 &amp;&amp; fill !== undefined) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    // Since we are filling anyway, don't zero fill initially.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    // Only pay attention to encoding if it's a string. This</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    // prevents accidentally sending in a number that would</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    // be interpretted as a start offset.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    if (typeof encoding !== 'string')</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      encoding = undefined;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    // 最终到这里, createUnsafeBuffer( size ) 上一节已经分析过</span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><span>    // createUnsafeBuffer 创建一个 FastBuffer 实例对象，而 Buffer 由继承了 FastBuffer</span><br/></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><span><span>    // 直接进入 fill 函数来看</span><br/></span></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    return createUnsafeBuffer(size).fill(fill, encoding);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  }</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  return new FastBuffer(size);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">};</font><br/></div></div><div><br/></div><div>进入 fill 函数，此函数即为 Buffer.prototype.fill &lt;==&gt; FastBuffer.prototype.fill（上一节已经分析过），因为：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>class FastBuffer extends Uint8Array {}<br/></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">FastBuffer.prototype.constructor = Buffer;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">// 按引用传值，共享 prototype</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">Buffer.prototype = FastBuffer.prototype;</font><br/></div></div><div><br/></div><div>fill 函数内部：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">// Usage:</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">//    buffer.fill(number[, offset[, end]])</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">//    buffer.fill(buffer[, offset[, end]])</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">//    buffer.fill(string[, offset[, end]][, encoding])</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">Buffer.prototype.fill = function fill(val, start, end, encoding) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // 只传入一个参数 val: 1，且类型为 number</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><span>  // 剩余三个都是 undefined</span><br/></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // Handle string cases:</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (typeof val === 'string') {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    . . . // 字符串的逻辑稍后分析</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  } else if (typeof val === 'number') {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    // 此填充数字的大小不能超过 255 （即 2^8 - 1 = 255）第一子节全是 1</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><span>    // 数字大小不能超过 1 byte大小</span><br/></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    val = val &amp; 255;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  }</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // Invalid ranges are not set to a default, so can range check early.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (start &lt; 0 || end &gt; this.length)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    throw new RangeError('Out of range index');</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (end &lt;= start)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    return this;</font></div><div><span>  // 所有非数值转成 0；所有大于等于 0 取整数部分</span><br/></div><div><span><span>  // 相关说明：<a href="https://www.zhihu.com/question/20693429">https://www.zhihu.com/question/20693429</a></span><br/></span></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  start = start &gt;&gt;&gt; 0;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  end = end === undefined ? this.length : end &gt;&gt;&gt; 0;</font></div><div><span>  // start === 0</span><br/></div><div><span><span>  // end === 20 ( this.length )</span><br/></span></div><div><span><span><span>  // 走入 binding.fill</span><br/></span></span></div><div><span><span><span><span>  // this ==&gt; Uint8Array</span><br/></span></span></span></div><div><span><span><span><span><span>  // val: 1, start: 0, end: 20, encoding: undefined</span><br/></span></span></span></span></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  binding.fill(this, val, start, end, encoding);</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  return this;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">};</font><br/></div></div><div><br/></div><div>来看看如何走入 binding.fill:</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">#0     0x00000001000396b0 in node::Buffer::Fill(v8::FunctionCallbackInfo&lt;v8::Value&gt; const&amp;) at /Users/mrguan/work/build/node/node-6.6.0/src/node_buffer.cc:605</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">void Fill(const FunctionCallbackInfo&lt;Value&gt;&amp; args) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  Environment* env = Environment::GetCurrent(args);</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  THROW_AND_RETURN_UNLESS_BUFFER(env, args[0]);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  SPREAD_ARG(args[0], ts_obj);</font></div><div>  // 0</div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  size_t start = args[2]-&gt;Uint32Value();</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  size_t end = args[3]-&gt;Uint32Value(); // 20</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  size_t fill_length = end - start; // 20</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  Local&lt;String&gt; str_obj;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  size_t str_length;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // <font style="font-size: 12px; color: rgb(51, 51, 51);">BINARY is a deprecated alias of LATIN1.</font></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // 🌟 enum encoding {ASCII, UTF8, BASE64, UCS2, BINARY, HEX, BUFFER, LATIN1 = BINARY};</font><font style="font-size: 12px; color: rgb(51, 51, 51);"/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  enum encoding enc;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // 保证不越界</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  CHECK(fill_length + start &lt;= ts_obj_length);</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  . . .</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // Then coerce everything that's not a string.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // number</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (!args[1]-&gt;IsString()) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    // 类型转换且保证为 255 以内的数字(1 byte之内)</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    int value = args[1]-&gt;Uint32Value() &amp; 255;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    // 开始设置</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    memset(ts_obj_data + start, value, fill_length);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    return;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  }</font><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">. . .</font></div><div><br/></div><div>====&gt;</div><div><br/></div><div>// 这个宏保证从 js 层级穿入的 obj 对象是一个 Buffer 实例</div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">#define THROW_AND_RETURN_UNLESS_BUFFER(env, obj)                            \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  do {                                                                      \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    if (!HasInstance(obj))                                                  \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      return env-&gt;ThrowTypeError("argument should be a Buffer");            \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  } while (0)</font><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">====&gt;</font></div><div>// arg[0], ts_obj(作为前缀)</div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">#define SPREAD_ARG(val, name)                                                 \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // 保证类型</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  CHECK((val)-&gt;IsUint8Array());                                               \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  Local&lt;Uint8Array&gt; name = (val).As&lt;Uint8Array&gt;();                            \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  ArrayBuffer::Contents name##_c = name-&gt;Buffer()-&gt;GetContents();             \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // ts_obj_offset</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  const size_t name##_offset = name-&gt;ByteOffset();                            \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // ts_obj_length</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  const size_t name##_length = name-&gt;ByteLength();                            \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // ts_obj_data 一个指向 char 类型的指针</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  char* const name##_data =                                                   \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      static_cast&lt;char*&gt;(name##_c.Data()) + name##_offset;                    \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (name##_length &gt; 0)                                                      \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    CHECK_NE(name##_data, nullptr);</font><br/></div><div><br/></div><div>====&gt;</div><div><span>  // ArrayBuffer::Contents 是 v8 对外的 API 类型</span><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  /**</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">   * The contents of an |ArrayBuffer|. Externalization of |ArrayBuffer|</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">   * returns an instance of this class, populated, with a pointer to data</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">   * and byte length.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">   *</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">   * The Data pointer of ArrayBuffer::Contents is always allocated with</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">   * Allocator::Allocate that is set via Isolate::CreateParams.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">   *</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">   * This API is experimental and may change significantly.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">   */</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  class V8_EXPORT Contents { // NOLINT</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">   public:</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    Contents() : data_(NULL), byte_length_(0) {}</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    void* Data() const { return data_; }</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    size_t ByteLength() const { return byte_length_; }</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">   private:</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    void* data_;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    size_t byte_length_;</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    friend class ArrayBuffer;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  };</font><br/></div><div><br/></div></div><div><br/></div><div>有关 memset 函数解析：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">void *memset( void *dest, int ch, size_t count );</font><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">Copies the value ch (after conversion to unsigned char as if by (unsigned char)ch) into each of the first count characters of the object pointed to by dest.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">The behavior is undefined if access occurs beyond the end of the dest array. The behavior is undefined if dest is a null pointer.</font><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"/></div></div><div><br/></div><div>最终 Buffer.alloc( 20, 1 ) 执行完毕。</div><div><br/></div><div><hr/></div><div><br/></div><div>再来看看 fill 字符串的情况，示例代码：</div><div><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'Menlo';font-size:13.5pt;"><span style="color:#cc7832;font-weight:bold;">const </span>buf2a1 = Buffer.<span style="color:#ffc66d;">alloc</span>( <span style="color:#6897bb;">20</span><span style="color:#cc7832;">, </span><span style="color:#6a8759;">'He'</span><span style="color:#cc7832;">, </span><span style="color:#6a8759;">'utf8' </span>)<span style="color:#cc7832;">;<br/></span><span style="color:#9876aa;">console</span>.<span style="color:#ffc66d;">log</span>( <span style="color:#6a8759;">'buf2a1: '</span><span style="color:#cc7832;">, </span>buf2a1 )<span style="color:#cc7832;">;</span>
</pre></div><div>根据之前的分析，alloc 在前半部分做的工作都是一样的：createUnsafeBuffer( size ) ，不一样的地方在 fill 函数的细节处：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">// Usage:</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">//    buffer.fill(number[, offset[, end]])</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">//    buffer.fill(buffer[, offset[, end]])</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">//    buffer.fill(string[, offset[, end]][, encoding])</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">Buffer.prototype.fill = function fill(val, start, end, encoding) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // 以下是处理字符串的情形，不再赘述</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // Handle string cases:</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (typeof val === 'string') {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    if (typeof start === 'string') {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      encoding = start;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      start = 0;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      end = this.length;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    } else if (typeof end === 'string') {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      encoding = end;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      end = this.length;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    }</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    if (val.length === 1) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      var code = val.charCodeAt(0);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      if (code &lt; 256)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">        val = code;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    }</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    if (val.length === 0) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      // Previously, if val === '', the Buffer would not fill,</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      // which is rather surprising.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      val = 0;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    }</font><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    . . .</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><span>    <font style="font-size: 12px; color: rgb(51, 51, 51);">binding.fill(this, val, start, end, encoding);</font></span><br/></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><span><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    . . .</span><br/></font></span></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">. . .</font></div></div><div><br/></div><div>最终进入 binding.fill 函数，首先看进入时的参数截图：</div><div><br/></div><div><img src="buffer%20%E6%A8%A1%E5%9D%97%E6%B7%B1%E7%A9%B6%20-%202.resources/DDDBF4AF-B381-4C6D-819A-16551391BFF8.png" height="auto" width="100%"/><br/></div><div><br/></div><div>进入 fill:</div><div><br/></div><div/><div style="box-sizing: border-box; padding: 8px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">void Fill(const FunctionCallbackInfo&lt;Value&gt;&amp; args) {</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">  . . .</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><span>  // 上面无关紧要的都先不用看</span><br/></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><span><span>  // <font style="font-size: 12px; color: rgb(51, 51, 51);">str_obj     v8::Local&lt;v8::String&gt;     </font></span><br/></span></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">  str_obj = args[1]-&gt;ToString(env-&gt;isolate());</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // <font style="font-size: 12px; color: rgb(51, 51, 51);">enc     node::encoding     UTF8</font></span><br/></font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">  enc = ParseEncoding(env-&gt;isolate(), args[4], UTF8);</font></div><div><font><font face="Monaco, Menlo, Consolas, Courier New, monospace" color="#333333"><span style="font-size: 12px;">  // </span></font><font><font face="Monaco, Menlo, Consolas, Courier New, monospace" color="#333333"><span style="font-size: 12px;">str_length     size_t     2 【因为穿入的 str_obj 是 ‘He'</span></font><font face="Monaco, Menlo, Consolas, Courier New, monospace" color="#333333"><span style="font-size: 12px;">】</span></font></font><br/></font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">  str_length =</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">      enc == UTF8 ? str_obj-&gt;Utf8Length() :</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">      enc == UCS2 ? str_obj-&gt;Length() * sizeof(uint16_t) : str_obj-&gt;Length();</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><br/></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">  . . .</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><br/></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">  // Can't use StringBytes::Write() in all cases. For example if attempting</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">  // to write a two byte character into a one byte Buffer.</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (enc == UTF8) {</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    // <font style="font-size: 12px; color: rgb(51, 51, 51);">str     node::Utf8Value      类型转换为 c++ 层级的字符串对象</font></span><br/></font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);"><span><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    // <span>    <font style="font-size: 12px; color: rgb(51, 51, 51);">buf_st_ char [1024] "He"  </font></span></span><br/></font></span></font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">    node::Utf8Value str(env-&gt;isolate(), args[1]);</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    // 先往 ts_obj_data 中 copy 入 1 个 He</span><br/></font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">    memcpy(ts_obj_data + start, *str, MIN(str_length, fill_length));</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><br/></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">  } </font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  . . .</span><br/></font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><br/></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;">// 下面的 goto 端比较有趣</div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);"> start_fill:</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><br/></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (str_length &gt;= fill_length)</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">    return;</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><br/></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><span>  // 具体要 copy 多少 size_t 长度的字符串，实时变化</span><br/></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">  size_t in_there = str_length; // 2</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // 目前准备 copy 的起点指针</span><br/></font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">  char* ptr = ts_obj_data + start + str_length;</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // ✨下面的循环很有意思✨</span><br/></font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><span>  // 第一次：in_there:2 | fill_length:20 | ptr: start + 2 | ptr += 2 ==&gt; start + 4 | in_there *= 2 ==&gt; 4 | copy count: 2</span></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><span><span>  // 第二次：in_there:4 | <font style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51);">fill_length:20 | ptr: start + 4 | ptr += 4 ==&gt; start + 8 | in_there *= 2 ==&gt; 8 | copy count: 4</font></span><br/></span></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><span>  // 第三次：in_there:8 | <font style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51);">fill_length:20 | ptr: start + 8 | ptr += 8 ==&gt; start + 16 | in_there *= 2 ==&gt; 16 | copy count: 8</font></span><br/></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><span><font style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51);"><span>  // 到第三次结束之时，已经 copy 了：2（一开始的copy） + 2 + 4 + 8 = 16 个字节大小</span><br/></font></span></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><span><font style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51);"><span>  // 第四次：16 &lt; ( 20 - 16 = 4 ) 循环结束</span><br/></font></span></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">  while (in_there &lt; fill_length - in_there) {</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">    memcpy(ptr, ts_obj_data + start, in_there);</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">    ptr += in_there;</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">    in_there *= 2;</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">  }</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><span>  // 此时还有 4 个 byte 空余</span><br/></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><span><span>  // in_there: 16 | fill_length: 20 | diff: 4</span><br/></span></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (in_there &lt; fill_length) {</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    // 直接把剩下的 4 个 byte copy 完毕</span><br/></font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">    memcpy(ptr, ts_obj_data + start, fill_length - in_there);</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">  }</font></div><div style="color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px;"><font style="font-size: 12px; color: rgb(51, 51, 51);">}</font><br/></div></div><div><br/></div><div>最终完成一次 string 类型的 fill 工作。</div><div><br/></div><div>关于 memcpy 函数：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">void* memcpy( void *dest, const void *src, size_t count );</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">Copies count characters from the object pointed to by src to the object pointed to by dest. Both objects are interpreted as arrays of unsigned char.</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">The behavior is undefined if access occurs beyond the end of the dest array. If the objects overlap (which is a violation of the restrict contract) (since C99), the behavior is undefined. The behavior is undefined if either dest or src is a null pointer.</font><br/></div></div><div><br/></div><div>相关例程：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">#define __STDC_WANT_LIB_EXT1__ 1</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">#include &lt;stdio.h&gt;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">#include &lt;stdint.h&gt;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">#include &lt;inttypes.h&gt;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">#include &lt;string.h&gt;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">#include &lt;stdlib.h&gt;</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">int main(void)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">{</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    // simple usage</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    char source[] = "once upon a midnight dreary...", dest[4];</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    memcpy(dest, source, sizeof dest);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    for(size_t n = 0; n &lt; sizeof dest; ++n)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">        putchar(dest[n]);</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    // setting effective type of allocated memory to be int</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    int *p = malloc(3*sizeof(int));   // allocated memory has no effective type</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    int arr[3] = {1,2,3};</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    memcpy(p,arr,3*sizeof(int));      // allocated memory now has an effective type</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    // reinterpreting data</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    double d = 0.1;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">//    int64_t n = *(int64_t*)(&amp;d); // strict aliasing violation</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    int64_t n;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    memcpy(&amp;n, &amp;d, sizeof d); // OK</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    printf("\n%a is %" PRIx64 " as an int64_t\n", d, n);</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">#ifdef __STDC_LIB_EXT1__</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    set_constraint_handler_s(ignore_handler_s);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    char src[] = "aaaaaaaaaa";</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    char dst[] = "xyxyxyxyxy";</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    int r = memcpy_s(dst,sizeof dst,src,5);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    printf("dst = \"%s\", r = %d\n", dst,r);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    r = memcpy_s(dst,5,src,10);            //  count is greater than destsz  </font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    printf("dst = \"");</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    for(size_t ndx=0; ndx&lt;sizeof dst; ++ndx) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">        char c = dst[ndx];</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">        c ? printf("%c", c) : printf("\\0");</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    }</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    printf("\", r = %d\n", r);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">#endif</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">}</font><br/></div></div><div><br/></div><div>对应输出：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">once</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">0x1.999999999999ap-4 is 3fb999999999999a as an int64_t</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">dst = "aaaaayxyxy", r = 0</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">dst = "\0\0\0\0\0yxyxy", r = 22</font><br/></div></div><div><br/></div><div>例程便于理解 memcpy 函数的使用。下节继续分析 buffer 的其他用法。</div><div><br/></div>

<hr class="tail-hr">
<div class="tail-licenses">
<p>版权声明：自由转载-非商用-非衍生-保持署名(<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">创意共享3.0许可证</a>)</p>
<p>文章作者：Pooky (<a href="mailto:guananddu@icloud.com">guananddu@icloud.com</a>)</p>
<p>更新日期：Mon Dec 26 2016 15:08:52 GMT+0800 (CST)</p>
</div></body></html>