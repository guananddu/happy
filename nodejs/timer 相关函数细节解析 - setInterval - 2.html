<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 6.10 (454267)"/><meta name="author" content="管伟"/><meta name="created" content="2016-11-14 05:29:02 +0000"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2016-12-01 09:19:22 +0000"/><title>timer 相关函数细节解析 - setInterval - 2</title></head><body><style>
    a { color: #43B0D6 !important; }
    .title-p { font-size:12px; color:gray; }
    .title-hr { margin-bottom: 20px; }
    .tail-hr { margin-top: 20px; }
    .tail-licenses { border:1px dashed lightgray; margin:20px 0 20px 0; padding:20px; font-size:14px; }
</style>
<h2>timer 相关函数细节解析 - setInterval - 2</h2>
<p class="title-p">版权声明：自由转载-非商用-非衍生-保持署名(<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">创意共享3.0许可证</a>)</p>
<p class="title-p">文章作者：Pooky (<a href="mailto:guananddu@icloud.com">guananddu@icloud.com</a>)</p>
<hr class="title-hr"><div>总结上一节的分析：从js层级调用一次setInterval，会创建一个Timeout对象，根据Timeout对象的idleTime的不同，创建不同的TimersList，TimersList同样也会放入一个以idleTime为key的map中去（js层级）；在创建js层级的Timerslist时，会同样创建一个由c++底层来实现的Timer对象，并且TimersList的_timer指针指向其Timer对象；</div><div>在创建Timer对象的时候，底层Timer对象会有自己的timer_handle属性，并且通过此属性，loop-&gt;handle_queue得以将Timer对象的timer_handle作为节点插入自身（最后的位置）；</div><div>最终调用Timer的start启动定时器，此步骤将Timer的timer_handle的heap_node属性作为粘合点，将自身的heap_node插入到loop-&gt;timer_heap最小完全二叉堆结构中去，并且每插入一次节点，都会进行数结构的顺序调整（父子节点换位，如果需要）；</div><div>一下内容摘自代码注释，有关timer架构的解释：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'Menlo';font-size:13.5pt;"><span style="color:#808080;">// HOW and WHY the timers implementation works the way it does.<br/></span><span style="color:#808080;">//<br/></span><span style="color:#808080;">// Timers are crucial to Node.js. Internally, any TCP I/O connection creates a<br/></span><span style="color:#808080;">// timer so that we can time out of connections. Additionally, many user<br/></span><span style="color:#808080;">// user libraries and applications also use timers. As such there may be a<br/></span><span style="color:#808080;">// significantly large amount of timeouts scheduled at any given time.<br/></span><span style="color:#808080;">// Therefore, it is very important that the timers implementation is performant<br/></span><span style="color:#808080;">// and efficient.<br/></span><span style="color:#808080;">//<br/></span><span style="color:#808080;">// Note: It is suggested you first read though the lib/internal/linkedlist.js<br/></span><span style="color:#808080;">// linked list implementation, since timers depend on it extensively. It can be<br/></span><span style="color:#808080;">// somewhat counter-intuitive at first, as it is not actually a class. Instead,<br/></span><span style="color:#808080;">// it is a set of helpers that operate on an existing object.<br/></span><span style="color:#808080;">//<br/></span><span style="color:#808080;">// In order to be as performant as possible, the architecture and data<br/></span><span style="color:#808080;">// structures are designed so that they are optimized to handle the following<br/></span><span style="color:#808080;">// use cases as efficiently as possible:<br/></span><span style="color:#808080;"><br/></span><span style="color:#808080;">// - Adding a new timer. (insert)<br/></span><span style="color:#808080;">// - Removing an existing timer. (remove)<br/></span><span style="color:#808080;">// - Handling a timer timing out. (timeout)<br/></span><span style="color:#808080;">//<br/></span><span style="color:#808080;">// Whenever possible, the implementation tries to make the complexity of these<br/></span><span style="color:#808080;">// operations as close to constant-time as possible.<br/></span><span style="color:#808080;">// (So that performance is not impacted by the number of scheduled timers.)<br/></span><span style="color:#808080;">//<br/></span><span style="color:#808080;">// Object maps are kept which contain linked lists keyed by their duration in<br/></span><span style="color:#808080;">// milliseconds.<br/></span><span style="color:#808080;">// The linked lists within also have some meta-properties, one of which is a<br/></span><span style="color:#808080;">// TimerWrap C++ handle, which makes the call after the duration to process the<br/></span><span style="color:#808080;">// list it is attached to.<br/></span><span style="color:#808080;">//<br/></span><span style="color:#808080;">//<br/></span><span style="color:#808080;">// ╔════ &gt; Object Map<br/></span><span style="color:#808080;">// ║<br/></span><span style="color:#808080;">// ╠══<br/></span><span style="color:#808080;">// ║ refedLists: { '40': { }, '320': { etc } } (keys of millisecond duration)<br/></span><span style="color:#808080;">// ╚══          ┌─────────┘<br/></span><span style="color:#808080;">//              │<br/></span><span style="color:#808080;">// ╔══          │<br/></span><span style="color:#808080;">// ║ TimersList { _idleNext: { }, _idlePrev: (self), _timer: (TimerWrap) }<br/></span><span style="color:#808080;">// ║         ┌────────────────┘<br/></span><span style="color:#808080;">// ║    ╔══  │                              ^<br/></span><span style="color:#808080;">// ║    ║    { _idleNext: { },  _idlePrev: { }, _onTimeout: (callback) }<br/></span><span style="color:#808080;">// ║    ║      ┌───────────┘<br/></span><span style="color:#808080;">// ║    ║      │                                  ^<br/></span><span style="color:#808080;">// ║    ║      { _idleNext: { etc },  _idlePrev: { }, _onTimeout: (callback) }<br/></span><span style="color:#808080;">// ╠══  ╠══<br/></span><span style="color:#808080;">// ║    ║<br/></span><span style="color:#808080;">// ║    ╚════ &gt;  Actual JavaScript timeouts<br/></span><span style="color:#808080;">// ║<br/></span><span style="color:#808080;">// ╚════ &gt; Linked List<br/></span><span style="color:#808080;">//<br/></span><span style="color:#808080;">//<br/></span><span style="color:#808080;">// With this, virtually constant-time insertion (append), removal, and timeout<br/></span><span style="color:#808080;">// is possible in the JavaScript layer. Any one list of timers is able to be<br/></span><span style="color:#808080;">// sorted by just appending to it because all timers within share the same<br/></span><span style="color:#808080;">// duration. Therefore, any timer added later will always have been scheduled to<br/></span><span style="color:#808080;">// timeout later, thus only needing to be appended.<br/></span><span style="color:#808080;">// Removal from an object-property linked list is also virtually constant-time<br/></span><span style="color:#808080;">// as can be seen in the lib/internal/linkedlist.js implementation.<br/></span><span style="color:#808080;">// Timeouts only need to process any timers due to currently timeout, which will<br/></span><span style="color:#808080;">// always be at the beginning of the list for reasons stated above. Any timers<br/></span><span style="color:#808080;">// after the first one encountered that does not yet need to timeout will also<br/></span><span style="color:#808080;">// always be due to timeout at a later time.<br/></span><span style="color:#808080;">//<br/></span><span style="color:#808080;">// Less-than constant time operations are thus contained in two places:<br/></span><span style="color:#808080;">// TimerWrap's backing libuv timers implementation (a performant heap-based<br/></span><span style="color:#808080;">// queue), and the object map lookup of a specific list by the duration of<br/></span><span style="color:#808080;">// timers within (or creation of a new list).<br/></span><span style="color:#808080;">// However, these operations combined have shown to be trivial in comparison to<br/></span><span style="color:#808080;">// other alternative timers architectures.<br/></span><span style="color:#808080;"><br/></span><span style="color:#808080;"><br/></span><span style="color:#808080;">// Object maps containing linked lists of timers, keyed and sorted by their<br/></span><span style="color:#808080;">// duration in milliseconds.<br/></span><span style="color:#808080;">//<br/></span><span style="color:#808080;">// The difference between these two objects is that the former contains timers<br/></span><span style="color:#808080;">// that will keep the process open if they are the only thing left, while the<br/></span><span style="color:#808080;">// latter will not.<br/></span><span style="color:#808080;">//<br/></span><span style="color:#808080;">// - key = time in milliseconds<br/></span><span style="color:#808080;">// - value = linked list<br/></span><span style="color:#cc7832;font-weight:bold;">const </span>refedLists = {}<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;font-weight:bold;">const </span>unrefedLists = {}<span style="color:#cc7832;">;</span></pre></div></div><div><br/></div><div><hr/>继续上一届未完的内容，上一节分析到了：</div><div/><div style="box-sizing: border-box; padding: 8px; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">insert(), timers.js:138</font><br/></div><div><pre style="font-family: Menlo; background-color: rgb(43, 43, 43); color: rgb(169, 183, 198); font-size: 13.5pt;"><span style="background-color:#344134;">list</span>._timer.start(msecs)<span style="color:#cc7832;">;</span>
</pre><font face="Monaco">的位置，继续往下</font></div><div><font face="Monaco">==</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">// The underlying logic for scheduling or re-scheduling a timer.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">//</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">// Appends a timer onto the end of an existing timers list, or creates a new</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">// TimerWrap backed list if one does not already exist for the specified timeout</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">// duration.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">function insert(item, unrefed) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  <span>  ...</span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>    // 上一节已经分析到此</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    list._timer.start(msecs);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    // 将当前新创建的TimersList对象，放入lists中去，key即为delay时间</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    lists[msecs] = list;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>    // <font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">const kOnTimeout = TimerWrap.kOnTimeout | 0;</font></span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>    <img src="timer%20%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E7%BB%86%E8%8A%82%E8%A7%A3%E6%9E%90%20-%20setInterval%20-%202.resources/2FCCD980-171E-42D7-91F0-49CDEF877D16.png" height="auto" width="100%"/><br/></span><br/></font></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span><span>    // 给TimerWrap实例对象添加c2js的粘合点【设置回调函数／便于c++ call js】</span><br/></span></font></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    list._timer[kOnTimeout] = listOnTimeout;//【一定要注意此回调函数c2js的重要调用点】</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  }</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  // 以底层TimerWrap实例对象作为链表头，将js层级创建的Timeout对象插入此队列中去</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  L.append(list, item);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  assert(!L.isEmpty(list)); // list is not empty</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">}</font><br/></div><div><font face="Monaco"/></div><div><font face="Monaco">==</font></div><div><font face="Monaco">🌟自此 exports.setInterval 中的 active(timer) 执行完毕！</font></div><div><font face="Monaco">此函数以 Timeout 实例对象作为返回值，设置intervalTimer的逻辑到此为止！</font></div><div><font face="Monaco">==</font></div></div><div><br/></div><div><hr/>以下内容关注如何触发timer的回调，首先看c++层次得回调：</div><div><br/></div><div>仍旧是在 loop 的 uv_run 核心函数中的：uv_run_timers 环节来触发的：</div><div><img src="timer%20%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E7%BB%86%E8%8A%82%E8%A7%A3%E6%9E%90%20-%20setInterval%20-%202.resources/5381AA46-3E3F-44F6-B19E-055C0E37B3EC.png" height="auto" width="100%"/><br/></div><div>进入 uv__run_timers(loop)：</div><div/><div style="box-sizing: border-box; padding: 8px; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">void uv__run_timers(uv_loop_t* loop) {</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  struct heap_node* heap_node;</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  uv_timer_t* handle;</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><br/></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  for (;;) {</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>    // 取到heap的根节点</span><br/></font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    heap_node = heap_min((struct heap*) &amp;loop-&gt;timer_heap);</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>    // 如果根节点为空则直接break</span><br/></font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    if (heap_node == NULL)</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">      break;</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span>    通过 handle 的 heap_node 来拿到handle</span><br/></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    handle = container_of(heap_node, uv_timer_t, heap_node);</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    // 如果符合这个条件的话，则表示此timer的delay时间还未到；则跳出</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    if (handle-&gt;timeout &gt; loop-&gt;time)</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">      break;</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span>    // 否则开始执行回调</span><br/></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span><span>    // 1⃣️从最小完全二叉堆中删除当前正在处理的heap_node节点，同时保证结构正确</span><br/></span></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span><span><span>    // 2⃣️标识当前handle的状态为未激活状态</span><br/></span></span></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    uv_timer_stop(handle);</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>    // 与handle-&gt;repeat相关的逻辑／但是有个疑问，handle-&gt;repeat在什么时候为1呢？貌似现在见到的都是0</span><br/></font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    uv_timer_again(handle);</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    // 调用回调函数</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    handle-&gt;timer_cb(handle);</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  }</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">}</font><br/></div><div><font face="Monaco">==</font></div><div><font face="Monaco">🌟 最终进入c++层级的回调函数：</font></div><div><font face="Monaco"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">#0     0x000000010008e36c in node::TimerWrap::OnTimeout(uv_timer_s*) at /Users/mrguan/work/build/node/node-6.6.0/src/timer_wrap.cc:91</font></font></div><div><font face="Monaco"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"/></font></div><div><font face="Monaco"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  static void OnTimeout(uv_timer_t* handle) {</font></font></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    TimerWrap* wrap = static_cast&lt;TimerWrap*&gt;(handle-&gt;data);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    Environment* env = wrap-&gt;env();</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    HandleScope handle_scope(env-&gt;isolate());</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    Context::Scope context_scope(env-&gt;context());</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    // 这里就是c++ 2 js的环节；此句的执行，最终调用了js层级的list._timer[0]</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>    // js level: <font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">list._timer[kOnTimeout] = listOnTimeout;</font></span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    // list._timer 就是wrap【可以这样理解】同时，listOnTimeout的调用上下文即为 _timer 自己</font></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    // <img src="timer%20%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E7%BB%86%E8%8A%82%E8%A7%A3%E6%9E%90%20-%20setInterval%20-%202.resources/DE1FC694-1645-4DFD-B2F9-7FE534D2DE5D.png" height="auto" width="100%"/><br/></font></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    wrap-&gt;MakeCallback(kOnTimeout, 0, nullptr);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  }</font><font face="Monaco"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><br/></font></font></div><div><font face="Monaco"/></div><div><font face="Monaco"/></div><div><font face="Monaco">==</font></div></div><div><br/></div><div>开始进入js层级的回调函数，首先来看此时的触发回调：</div><div><img src="timer%20%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E7%BB%86%E8%8A%82%E8%A7%A3%E6%9E%90%20-%20setInterval%20-%202.resources/ABF09A2B-EE48-4D86-B38A-8B00B550018A.png" height="auto" width="100%"/><br/></div><div/><div style="box-sizing: border-box; padding: 8px; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">listOnTimeout(), timers.js:202</font><br/></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><br/></font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">function listOnTimeout() {</font></font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>  // this 即为 Timer 实例对象 this._list 为 TimersList 对象【js层级的双向链表】</span><br/></font></font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  var list = this._list;</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  // delay 时间</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  var msecs = list.msecs;</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><br/></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  debug('timeout callback %d', msecs);</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span>  // 得到现在的CPU毫秒数</span><br/></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  var now = TimerWrap.now();</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  debug('now: %d', now);</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><br/></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  var diff, timer;</font></div><div><font face="Monaco">  // peek 函数见下，即返回“最老”的节点</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  <img src="timer%20%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E7%BB%86%E8%8A%82%E8%A7%A3%E6%9E%90%20-%20setInterval%20-%202.resources/F80FCC55-4B38-4172-8042-A2C190DFA68A.png" height="auto" width="100%"/><br/></font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  while (timer = L.peek(list)) {</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    diff = now - timer._idleStart;</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><br/></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    // Check if this loop iteration is too early for the next timer.</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    // This happens if there are more timers scheduled for later in the list.</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>    // 如注释所说，在list中的timeout节点过多时，可能会出现此种情况</span><br/></font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    if (diff &lt; msecs) {</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">      var timeRemaining = msecs - (TimerWrap.now() - timer._idleStart);</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">      if (timeRemaining &lt; 0) {</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">        timeRemaining = 0;</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">      }</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>    <span>  // 重新激活底层timer</span></span><br/></font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">      this.start(timeRemaining);</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">      debug('%d list wait because diff is %d', msecs, diff);</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">      return;</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    }</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><br/></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    // The actual logic for when a timeout happens.</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span>    // 将当前要处理的timer节点移除队列</span><br/></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    L.remove(timer);</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    assert(timer !== L.peek(list));</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span>    </span><br/></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    if (!timer._onTimeout) continue;</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><br/></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    … domain相关 </font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span>    // 执行回调</span><br/></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    tryOnTimeout(timer, list);</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><br/></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    if (domain)</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">      domain.exit();</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  }</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><br/></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  // If `L.peek(list)` returned nothing, the list was either empty or we have</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  // called all of the timer timeouts.</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  // As such, we can remove the list and clean up the TimerWrap C++ handle.</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  debug('%d list empty', msecs);</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  assert(L.isEmpty(list));</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  // 此函数执行，最终调入：</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span>  // <img src="timer%20%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E7%BB%86%E8%8A%82%E8%A7%A3%E6%9E%90%20-%20setInterval%20-%202.resources/6FEEA16D-6808-4FDC-BEBA-2034877AFE61.png" height="auto" width="100%"/><br/></span></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span><span>  // <img src="timer%20%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E7%BB%86%E8%8A%82%E8%A7%A3%E6%9E%90%20-%20setInterval%20-%202.resources/8048FA18-E619-42B8-A203-CD7BAED075E0.png" height="auto" width="100%"/><br/></span><br/></span></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"/><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  this.close();</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><br/></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  // Either refedLists[msecs] or unrefedLists[msecs] may have been removed and</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  // recreated since the reference to `list` was created. Make sure they're</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  // the same instance of the list before destroying.</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  if (list._unrefed === true &amp;&amp; list === unrefedLists[msecs]) {</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    delete unrefedLists[msecs];</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  } else if (list === refedLists[msecs]) {</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    delete refedLists[msecs];</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  }</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">}</font><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><br/></font></div><div><font face="Monaco">==</font></div><div><font face="Monaco">🌟 进入tryOnTimeout函数：</font></div><div><font face="Monaco"><img src="timer%20%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E7%BB%86%E8%8A%82%E8%A7%A3%E6%9E%90%20-%20setInterval%20-%202.resources/C5AF59E4-AEAF-42D4-9278-F6BD7B76CEFA.png" height="auto" width="100%"/><br/></font></div><div><font face="Monaco">==</font></div><div><font face="Monaco">🌟 进入 timer._onTimeout()，这个函数指针即为内部函数：wrapper：<font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">wrapper(), timers.js:425</font></font></div><div><font face="Monaco"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"/></font></div><div><font face="Monaco"/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  function wrapper() {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>    // 🌟此_repeat() 即为用户回调函数的包装函数／用户逻辑在此被调起🌟</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    timer._repeat();</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    // Timer might be closed - no point in restarting it</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    if (!timer._repeat)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">      return;</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    // If timer is unref'd (or was - it's permanently removed from the list.)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    if (this._handle) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">      this._handle.start(repeat);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    } else {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>    <span>  // 一般的timer都走这个分支</span></span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span><span><span>    <span>  // 重新设置delay时间</span></span><br/></span></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">      timer._idleTimeout = repeat;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>    <span>  // 重新激活timer／因为是interval调用</span></span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">      active(timer);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    }</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  }</font><br/></div><div><font face="Monaco"/></div><div><font face="Monaco">==</font></div><div style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"/></div></div><div><br/></div><div>总结一句话就是：setInterval 的整体逻辑，当某一个Timeout节点被处理完成以后，就会从js层级的双向链表中remove掉；而在底层的timer_heap（最小完全二叉堆）节点中某一个节点被处理完毕，也会从树中remove掉；但当执行完一次用户回调，Timeout节点会重新被插入js层级的双向链表中，并且重新调用_timer.start()底层调用，往二叉堆中插入节点，便于uv__loop_timers() 来检查；</div><div><br/></div>

<hr class="tail-hr">
<div class="tail-licenses">
<p>版权声明：自由转载-非商用-非衍生-保持署名(<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">创意共享3.0许可证</a>)</p>
<p>文章作者：Pooky (<a href="mailto:guananddu@icloud.com">guananddu@icloud.com</a>)</p>
<p>更新日期：Thu Dec 22 2016 14:39:19 GMT+0800 (CST)</p>
</div></body></html>