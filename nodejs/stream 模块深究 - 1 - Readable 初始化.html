<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 6.10 (454267)"/><meta name="author" content="管伟"/><meta name="created" content="2016-12-29 13:24:52 +0000"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2017-01-04 03:13:32 +0000"/><title>stream 模块深究 - 1 - Readable 初始化</title></head><body><style>
    a { color: #43B0D6 !important; }
    a:visited { color: #7b7ed2 !important; }
    .title-p { font-size:12px; color:gray; }
    .title-hr { margin-bottom: 20px; }
    .tail-hr { margin-top: 20px; }
    .tail-licenses { border:1px dashed lightgray; margin:20px 0 20px 0; padding:20px; font-size:14px; }
</style>
<h2>stream 模块深究 - 1 - Readable 初始化</h2>
<p class="title-p">版权声明：自由转载-非商用-非衍生-保持署名(<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">创意共享3.0许可证</a>)</p>
<p class="title-p">文章作者：Pooky (<a href="mailto:guananddu@icloud.com">guananddu@icloud.com</a>)</p>
<hr class="title-hr"><div>从本节开始学习 stream 模块相关的实现细节，本节先看 stream.Readable 类的实现细节和用法。先来看测试代码：</div><div><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'Menlo';font-size:13.5pt;"><span style="color:#cc7832;font-weight:bold;">const </span>fs = require( <span style="color:#6a8759;">'fs' </span>)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;font-weight:bold;">const </span>path = require( <span style="color:#6a8759;">'path' </span>)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;font-weight:bold;">const </span>stream = require( <span style="color:#6a8759;">'stream' </span>)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;"><br/></span><span style="color:#cc7832;font-weight:bold;">const </span>filePath = path.<span style="color:#ffc66d;">resolve</span>( __dirname<span style="color:#cc7832;">, </span><span style="color:#6a8759;">'bigfile.txt' </span>)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;"><br/></span><span style="color:#cc7832;font-weight:bold;">const </span>readable = fs.<span style="color:#ffc66d;">createReadStream</span>( filePath<span style="color:#cc7832;">, </span>{<br/>    <span style="color:#9876aa;">flags</span>: <span style="color:#6a8759;">'r'</span><span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">    </span><span style="color:#9876aa;">encoding</span>: <span style="color:#6a8759;">'utf8'</span><span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">    </span><span style="color:#9876aa;">fd</span>: <span style="color:#cc7832;font-weight:bold;">null</span><span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">    </span><span style="color:#9876aa;">mode</span>: <span style="color:#6897bb;">0o666</span><span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">    </span><span style="color:#9876aa;">autoClose</span>: <span style="color:#cc7832;font-weight:bold;">true</span><span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">    </span><span style="color:#808080;">// Be aware that, unlike the default value set for highWaterMark on a<br/></span><span style="color:#808080;">    // readable stream (16 kb), the stream returned by this method has a<br/></span><span style="color:#808080;">    // default value of 64 kb for the same parameter.<br/></span><span style="color:#808080;">    </span><span style="color:#9876aa;">highWaterMark</span>: <span style="color:#6897bb;">20000<br/></span>} )<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;"><br/></span>readable.<span style="color:#ffc66d;">setEncoding</span>( <span style="color:#6a8759;">'utf8' </span>)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;"><br/></span>readable.<span style="color:#ffc66d;">on</span>( <span style="color:#6a8759;">'open'</span><span style="color:#cc7832;">, </span>() =&gt; {<br/>    <span style="color:#9876aa;">console</span>.<span style="color:#ffc66d;">log</span>( <span style="color:#6a8759;">`!readable: open event.` </span>)<span style="color:#cc7832;">;<br/></span>} )<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;"><br/></span>readable.<span style="color:#ffc66d;">on</span>( <span style="color:#6a8759;">'readable'</span><span style="color:#cc7832;">, </span>() =&gt; {<br/>    <span style="color:#9876aa;">console</span>.<span style="color:#ffc66d;">log</span>( <span style="color:#6a8759;">`!readable: readable event.` </span>)<span style="color:#cc7832;">;<br/></span>} )<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;"><br/></span>readable.<span style="color:#ffc66d;">on</span>( <span style="color:#6a8759;">'data'</span><span style="color:#cc7832;">, </span>( chunk ) =&gt; {<br/>    <span style="color:#9876aa;">console</span>.<span style="color:#ffc66d;">log</span>( <span style="color:#6a8759;">`readable: received </span>${chunk.<span style="color:#9876aa;">length</span>}<span style="color:#6a8759;"> bytes of data.` </span>)<span style="color:#cc7832;">;<br/></span>} )<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;"><br/></span>readable.<span style="color:#ffc66d;">on</span>( <span style="color:#6a8759;">'close'</span><span style="color:#cc7832;">, </span>() =&gt; {<br/>    <span style="color:#9876aa;">console</span>.<span style="color:#ffc66d;">log</span>( <span style="color:#6a8759;">`!readable: close` </span>)<span style="color:#cc7832;">;<br/></span>} )<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;"><br/></span>readable.<span style="color:#ffc66d;">on</span>( <span style="color:#6a8759;">'end'</span><span style="color:#cc7832;">, </span>() =&gt; {<br/>    <span style="color:#9876aa;">console</span>.<span style="color:#ffc66d;">log</span>( <span style="color:#6a8759;">`!readable: there will be no more data.` </span>)<span style="color:#cc7832;">;<br/></span>} )<span style="color:#cc7832;">;<br/></span>
</pre></div><div>代码运行后的输出为：<br/></div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><font style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51);">!readable: open event.</font><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">readable: received 20000 bytes of data.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">readable: received 20000 bytes of data.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">readable: received 19798 bytes of data.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">!readable: readable event.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">!readable: there will be no more data.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">!readable: close</font><br/></div></div><div><br/></div><div>开始断点调试，首先留意 fs.createReadStream 函数，fs 模块细节先不深究，之后会创建新的文章来分析 fs 模块实现。fs.createReadStream 函数创建了一个可读流，我们主要关注此 Readable Stream 到底是如何创建的，都有哪些细节点：</div><div><br/></div><div>fs.createReadStream 函数在内部直接 return new ReadStream( path, options )，在 fs.js 模块内部，ReadStream 直接继承了 Stream.Readable：</div><div><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'Menlo';font-size:13.5pt;"><span style="background-color:#344134;">util</span>.inherits(ReadStream<span style="color:#cc7832;">, </span>Readable)<span style="color:#cc7832;">;<br/></span>fs.ReadStream = ReadStream<span style="color:#cc7832;">;</span>
</pre></div><div>在 fs.js 中的 ReadStream 构造函数中，有一个关于 highWaterMark 参数的细节：</div><div><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'Menlo';font-size:13.5pt;"><span style="color:#808080;">// a little bit bigger buffer and water marks by default<br/></span>options = Object.create(options)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;font-weight:bold;">if </span>(options.highWaterMark === undefined)<br/>  options.highWaterMark = <span style="color:#6897bb;">64 </span>* <span style="color:#6897bb;">1024</span><span style="color:#cc7832;">;</span>
</pre></div><div>即，默认的 Readable 的 highWaterMark 为 64kb 大小。测试代码传入的是 20000 字节大小。</div><div><br/></div><div>再往下，就会有：</div><div><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'Menlo';font-size:13.5pt;"><span style="background-color:#344134;">Readable</span>.call(<span style="color:#cc7832;font-weight:bold;">this</span><span style="color:#cc7832;">, </span>options)<span style="color:#cc7832;">;</span>
</pre>父类构造函数的调用，我们跟进此函数调用内，此 Readable.call( this, options ) 的构造函数调用，的位置在：node/lib/_stream_readable.js 中，此构造函数比较简略：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">function Readable(options) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (!(this instanceof Readable))</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    return new Readable(options);</font></div><div>  // 此时的 options: { }</div><div><span>  // <font style="font-size: 12px; color: rgb(51, 51, 51);">‌‌JSON.stringify(options.__proto__)</font></span></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">‌  // {"flags":"r","encoding":"utf8","fd":null,"mode":438,"autoClose":true,"highWaterMark":20000}</font><span/><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // 从 ReadableState 对象的构造来看，这是一个<font style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51);">用来记录状态的</font>复杂对象</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  this._readableState = new ReadableState(options, this);</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // legacy</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  this.readable = true;</font></div><div><span>  // 如果提供了 options.read 函数，则用来替代 this._read 内部函数</span><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (options &amp;&amp; typeof options.read === 'function')</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    this._read = options.read;</font></div><div><span>  // EE.call( this )【继承 EventEmitter】关于 EventEmitter 之后专门开辟章节介绍</span><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  Stream.call(this);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">}</font><br/></div></div><div><br/></div><div>ReadableState 对象的构造函数，注意里面的一些注释：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">function ReadableState(options, stream) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  options = options || {};</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // object stream flag. Used to make read(n) ignore n and to</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // make all the buffer merging and length checks go away</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  this.objectMode = !!options.objectMode;</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (stream instanceof Stream.Duplex)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    this.objectMode = this.objectMode || !!options.readableObjectMode;</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // the point at which it stops calling _read() to fill the buffer</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // Note: 0 is a valid value, means "don't call _read preemptively ever"</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  var hwm = options.highWaterMark;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  var defaultHwm = this.objectMode ? 16 : 16 * 1024;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // cast to ints.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  this.highWaterMark = ~~this.highWaterMark;</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // A linked list is used to store data chunks instead of an array because the</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // linked list can remove elements from the beginning faster than</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // array.shift()</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // 这里注意 🌟</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  this.buffer = new BufferList();</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  this.length = 0;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  this.pipes = null;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  this.pipesCount = 0;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  this.flowing = null;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  this.ended = false;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  this.endEmitted = false;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  this.reading = false;</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // a flag to be able to tell if the onwrite cb is called immediately,</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // or on a later tick.  We set this to true at first, because any</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // actions that shouldn't happen until "later" should generally also</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // not happen before the first write call.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  this.sync = true;</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // whenever we return null, then we set a flag to say</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // that we're awaiting a 'readable' event emission.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  this.needReadable = false;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  this.emittedReadable = false;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  this.readableListening = false;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  this.resumeScheduled = false;</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // Crypto is kind of old and crusty.  Historically, its default string</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // encoding is 'binary' so we have to make this configurable.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // Everything else in the universe uses 'utf8', though.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  this.defaultEncoding = options.defaultEncoding || 'utf8';</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // when piping, we only care about 'readable' events that happen</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // after read()ing all the bytes and not getting any pushback.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  this.ranOut = false;</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // the number of writers that are awaiting a drain event in .pipe()s</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  this.awaitDrain = 0;</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // if true, a maybeReadMore has been scheduled</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  this.readingMore = false;</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  this.decoder = null;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  this.encoding = null;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (options.encoding) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    if (!StringDecoder)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      StringDecoder = require('string_decoder').StringDecoder;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    // 🌟关于 StringDecoder 的实现细节请看独立章节</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    this.decoder = new StringDecoder(options.encoding);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    this.encoding = options.encoding;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  }</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">}</font><br/></div></div><div><br/></div><div><hr/></div><div><br/></div><div>fs.js 中的 ReadStream 构造函数在执行完父级构造函数 Readable.call( this, options ) 之后继续往后执行相关初始化：</div><div><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'Menlo';font-size:13.5pt;"><span style="color:#cc7832;font-weight:bold;">if </span>(<span style="color:#cc7832;font-weight:bold;">typeof this</span>.fd !== <span style="color:#6a8759;">'number'</span>)<br/>  <span style="color:#cc7832;font-weight:bold;">this</span>.open()<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;"><br/></span><span style="color:#cc7832;font-weight:bold;">this</span>.on(<span style="color:#6a8759;">'end'</span><span style="color:#cc7832;">, </span><span style="color:#cc7832;font-weight:bold;">function</span>() {<br/>  <span style="color:#cc7832;font-weight:bold;">if </span>(<span style="color:#cc7832;font-weight:bold;">this</span>.autoClose) {<br/>    <span style="color:#cc7832;font-weight:bold;">this</span>.destroy()<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">  </span>}<br/>})<span style="color:#cc7832;">;</span>
</pre>因为并没有传入 this.fd 参数，这里的 this.fs == null，所以进入：this.open() 函数：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">ReadStream.prototype.open = function() {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  var self = this;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>  // 调用 fs.open 异步方法，fs 中的具体方法调用在这一节先不详述</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  fs.open(this.path, this.flags, this.mode, function(er, fd) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    if (er) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>      // 发生错误的情况</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    <span>  // 默认的 self.autoClose == true</span></span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      if (self.autoClose) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">        self.destroy();</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      }</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      self.emit('error', er);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      return;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    }</font></div><div><span>    // 正确打开文件，将文件描述符返回并存储</span><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    self.fd = fd;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);"><span>    // 触发 open 事件</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    self.emit('open', fd);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    // start the flow of data.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    self.read();🌟</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  });</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">};</font><br/></div></div><div><br/></div><div>顺利打开的情况下，`open` 事件在第一时间被触发，后面再来看几个事件的详细触发流程。<br/></div><div><br/></div><div>之后，开始调用 self.read() 函数，之后详述，敬请期待～</div><div><br/></div>

<hr class="tail-hr">
<div class="tail-licenses">
<p>版权声明：自由转载-非商用-非衍生-保持署名(<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">创意共享3.0许可证</a>)</p>
<p>文章作者：Pooky (<a href="mailto:guananddu@icloud.com">guananddu@icloud.com</a>)</p>
<p>更新日期：Wed Jan 04 2017 11:16:09 GMT+0800 (CST)</p>
</div></body></html>