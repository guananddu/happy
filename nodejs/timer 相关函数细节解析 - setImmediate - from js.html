<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 6.10 (454267)"/><meta name="author" content="管伟"/><meta name="created" content="2016-11-10 10:16:24 +0000"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2016-11-14 03:36:09 +0000"/><title>timer 相关函数细节解析 - setImmediate - from js</title></head><body><div>从此节开始，开始分析与timer相关的各种函数调用的内部原理，此节先分析：setImmediate 函数。</div><div>首先需要了解的是：各种timer相关函数的加载，是在bootstrap_node.js中的startup()函数中，此函数中会有：</div><div>setupGlobalTimeouts() 的函数调用：<br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  function setupGlobalTimeouts() {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>    // timers包加载</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    const timers = NativeModule.require('timers’);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>    // 对外暴露接口</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    global.clearImmediate = timers.clearImmediate;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    global.clearInterval = timers.clearInterval;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    global.clearTimeout = timers.clearTimeout;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    global.setImmediate = timers.setImmediate;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    global.setInterval = timers.setInterval;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    global.setTimeout = timers.setTimeout;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  }</font><br/></div></div><div><br/></div><div>开始调试 setImmediate 函数，调试文件参见happy git资源库：</div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">(function (exports, require, module, __filename, __dirname) { debugger;</font></div><div><br/></div><div>// 第一次调用</div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">setImmediate(</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    function () {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">        debugger;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">        console.log( 'i am the first!' );</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">        console.log( this );</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">        console.log( arguments );</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    },</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    'first',</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    123</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">);</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">setImmediate(</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    function () {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">        debugger;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">        console.log( 'i am the second!' );</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">        console.log( this );</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">        console.log( arguments );</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    },</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    'second'</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">});</font><br/></div></div><div><br/></div><div>setImmediate 的函数调用最终进入lib/timers.js文件中的exports.setImmediate函数中：</div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">exports.setImmediate = function(callback, arg1, arg2, arg3) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  if (typeof callback !== 'function') {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    throw new TypeError('"callback" argument must be a function');</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  }</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  var i, args;</font></div><div><span>  // 会进行参数的统一化处理</span><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  switch (arguments.length) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    // fast cases</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    case 0:</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    case 1:</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">      break;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    case 2:</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">      args = [arg1];</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">      break;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    case 3:</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">      args = [arg1, arg2];</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">      break;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    case 4:</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">      args = [arg1, arg2, arg3];</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">      break;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    // slow case</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    default:</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">      args = [arg1, arg2, arg3];</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">      for (i = 4; i &lt; arguments.length; i++)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">        // extend array dynamically, makes .apply run much faster in v6.0.0</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">        args[i - 1] = arguments[i];</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">      break;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  }</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>  <img src="timer%20%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E7%BB%86%E8%8A%82%E8%A7%A3%E6%9E%90%20-%20setImmediate%20-%20from%20js.resources/DA830C61-1540-4FBE-959A-231C3609E761.png" height="auto" width="100%"/><br/></span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  // declaring it `const immediate` causes v6.0.0 to deoptimize this function</font></div><div><span>  <img src="timer%20%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E7%BB%86%E8%8A%82%E8%A7%A3%E6%9E%90%20-%20setImmediate%20-%20from%20js.resources/FEEEC048-75B4-490E-83D2-54D1BE77B8B0.png" height="auto" width="100%"/><br/></span><br/></div><div><span>  // 初始化细节见上图</span><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  var immediate = new Immediate();</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>  // 下面给新创建的 immediate 对象附加属性</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  immediate._callback = callback;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  immediate._argv = args;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  immediate._onImmediate = callback;</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  if (!process._needImmediateCallback) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>    // 会走入这个分支／设置为true</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    process._needImmediateCallback = true;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>    // ✨注意这里，在process对象上挂载_immediateCallback对象；这里是c2js的一个粘合点</span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    process._immediateCallback = processImmediate;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  }</font></div><div><span>  // 这里需要注意</span><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  L.append(immediateQueue, immediate);</font></div><div><span>  // 函数调用完毕</span><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  return immediate;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">};</font><br/></div></div><div><hr/>自此往下的分析，将基于nodev6.6.0，启用了webstorm作为调试工具，简直碉堡了：</div><div>接着上述代码，L是js代码实现的双向链表实现，append为新增节点。</div><div><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'Menlo';font-size:13.5pt;"><span style="color:#cc7832;font-weight:bold;">var </span>immediateQueue = L.create()<span style="color:#cc7832;">;</span>
</pre>如上代码，immediateQueue是新创建的一个双向链表，初始化只有一个空的表头（自己指向自己），见下代码：</div><div><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'Menlo';font-size:13.5pt;"><span style="color:#cc7832;font-weight:bold;">function </span><span style="color:#ffc66d;">init</span>(list) {<br/>  list.<span style="color:#9876aa;">_idleNext </span>= list<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">  </span>list.<span style="color:#9876aa;">_idlePrev </span>= list<span style="color:#cc7832;">;<br/></span><span style="background-color:#344134;">}</span><br/><span style="color:#9876aa;">exports</span>.<span style="color:#ffc66d;">init </span>= <span style="color:#ffc66d;">init</span><span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;"><br/></span><span style="color:#808080;">// create a new linked list<br/></span><span style="color:#cc7832;font-weight:bold;">function </span><span style="color:#ffc66d;">create</span>() {<br/>  <span style="color:#cc7832;font-weight:bold;">const </span>list = { <span style="color:#9876aa;">_idleNext</span>: <span style="color:#cc7832;font-weight:bold;">null</span><span style="color:#cc7832;">, </span><span style="color:#9876aa;">_idlePrev</span>: <span style="color:#cc7832;font-weight:bold;">null </span>}<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">  </span><span style="color:#ffc66d;">init</span>(list)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">  </span><span style="color:#cc7832;font-weight:bold;">return </span>list<span style="color:#cc7832;">;<br/></span>}<br/><span style="color:#9876aa;">exports</span>.<span style="color:#ffc66d;">create </span>= <span style="color:#ffc66d;">create</span><span style="color:#cc7832;">;</span>
</pre></div><div>新创见的表头结构见：</div><div><img src="timer%20%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E7%BB%86%E8%8A%82%E8%A7%A3%E6%9E%90%20-%20setImmediate%20-%20from%20js.resources/3B5B1086-8656-455B-90B6-D21EB401D690.png" height="auto" width="100%"/><br/></div><div>上图的append函数具体见：</div><div><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'Menlo';font-size:13.5pt;"><span style="color:#cc7832;font-weight:bold;">function </span>append(list<span style="color:#cc7832;">, </span>item) {<br/>  <span style="color:#cc7832;font-weight:bold;">if </span>(item._idleNext || item._idlePrev) {<br/>    remove(item)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">  </span>}<br/><br/>  <span style="color:#808080;">// items are linked  with _idleNext -&gt; (older) and _idlePrev -&gt; (newer)<br/></span><span style="color:#808080;">  // TODO: swap the linkage to match the intuitive older items at "prev"<br/></span><span style="color:#808080;">  </span>item._idleNext = list._idleNext<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">  </span>item._idlePrev = list<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;"><br/></span><span style="color:#cc7832;">  </span><span style="color:#808080;">// the list _idleNext points to tail (newest) and _idlePrev to head (oldest)<br/></span><span style="color:#808080;">  </span>list._idleNext._idlePrev = item<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">  </span>list._idleNext = item<span style="color:#cc7832;">;<br/></span><span style="background-color:#344134;">}</span><br/>exports.append = append<span style="color:#cc7832;">;</span>
</pre>真正第一次执行完毕后的结构：</div><div><img src="timer%20%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E7%BB%86%E8%8A%82%E8%A7%A3%E6%9E%90%20-%20setImmediate%20-%20from%20js.resources/DD76BC7B-F617-40DD-AC3D-2EA5EE234563.png" height="auto" width="100%"/><br/></div><div><img src="timer%20%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E7%BB%86%E8%8A%82%E8%A7%A3%E6%9E%90%20-%20setImmediate%20-%20from%20js.resources/F063724F-A5E2-4C48-841F-B5D2275EF1EC.png" height="auto" width="100%"/><br/></div><div>因为第一次调用setImmediate函数，所以此链表除去一个表头节点，只有一个Immediate节点，list节点与Immediate节点互相指对；从上述代码注释中可以知道：list 的next始终指向最新的节点（也就是最后被插入的节点）；list的prev始终指向表头（也就是最早被插入的节点）。</div><div>当第二次调用setImmediate函数时，第二个节点被插入，结构如图所示：</div><div><img src="timer%20%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E7%BB%86%E8%8A%82%E8%A7%A3%E6%9E%90%20-%20setImmediate%20-%20from%20js.resources/3C9E1B03-01C6-412C-AAA2-9D4ECFA630EB.png" height="auto" width="100%"/><br/></div><div>自此，setImmediate函数算是运行完毕了，那么如何触发回调函数？在我们放行断电后，调试器直接进入setImmediate的回调部分：</div><div><img src="timer%20%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E7%BB%86%E8%8A%82%E8%A7%A3%E6%9E%90%20-%20setImmediate%20-%20from%20js.resources/05CCF163-FADD-4BFE-9A88-26CC60475113.png" height="auto" width="100%"/><br/></div><div>可见最底层的入口函数为：</div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">function processImmediate() {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>  // 将当前的队列切换新的指针</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  const queue = immediateQueue;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  var domain, immediate;</font></div><div><span>  // 将全局队列重新置为空链表【新创建／再创建之后仍旧可以接受新的节点插入】</span><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  immediateQueue = L.create();</font></div><div><span>  // 开始循环处理每一个节点</span><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  while (L.isEmpty(queue) === false) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>    // shift的作用，是把最“老”的节点拿出来【也就是最先被插入的节点】，返回，并且从原始链表中删除</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    immediate = L.shift(queue);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    domain = immediate.domain;</font></div><div><span>    // callback回调函数就被此属性所指向，没有回调的话，直接跳过了</span><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    if (!immediate._onImmediate)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">      continue;</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    if (domain)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">      domain.enter();</font></div><div><span>    // 赋予 _callback 属性</span><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    immediate._callback = immediate._onImmediate;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>    // 开始调用【函数细节见下】</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    tryOnImmediate(immediate, queue);</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    if (domain)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">      domain.exit();</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  }</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  // Only round-trip to C++ land if we have to. Calling clearImmediate() on an</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  // immediate that's in |queue| is okay. Worst case is we make a superfluous</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  // call to NeedImmediateCallbackSetter().</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>  // 如果链表为空，则将此属性置为false，此步骤会触发c底层回调</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  if (L.isEmpty(immediateQueue)) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    process._needImmediateCallback = false;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  }</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">}</font><br/></div></div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">// An optimization so that the try/finally only de-optimizes (since at least v8</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">// 4.7) what is in this smaller function.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">function tryOnImmediate(immediate, queue) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>  // immediate代表当前要处理的节点</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span><span>  // queue是链表将当前节点remove之后的链表</span><br/></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  var threw = true;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  try {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    // make the actual call outside the try/catch to allow it to be optimized</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>    // runCallback 函数比较简单</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    runCallback(immediate);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    threw = false;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  } finally {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>    // 如果回调函数中断了（有错误），则执行下面的逻辑</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    if (threw &amp;&amp; !L.isEmpty(queue)) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">      // Handle any remaining on next tick, assuming we're still alive to do so.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">      while (!L.isEmpty(immediateQueue)) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">        L.append(queue, L.shift(immediateQueue));</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">      }</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">      immediateQueue = queue;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">      process.nextTick(processImmediate);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    }</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  }</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">}</font><br/></div></div><div><br/></div><div>runCallback 函数比较简单：</div><div><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'Menlo';font-size:13.5pt;"><span style="color:#cc7832;font-weight:bold;">function </span>runCallback(timer) {<br/>  <span style="color:#cc7832;font-weight:bold;">const </span>argv = timer._argv<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">  </span><span style="color:#cc7832;font-weight:bold;">const </span>argc = argv ? argv.length : <span style="color:#6897bb;">0</span><span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">  </span><span style="color:#cc7832;font-weight:bold;">switch </span>(argc) {<br/>    <span style="color:#808080;">// fast-path callbacks with 0-3 arguments<br/></span><span style="color:#808080;">    </span><span style="color:#cc7832;font-weight:bold;">case </span><span style="color:#6897bb;">0</span>:<br/>      <span style="color:#cc7832;background-color:#344134;font-weight:bold;">return </span><span style="background-color:#344134;">timer._callback()</span><span style="color:#cc7832;background-color:#344134;">;</span><span style="color:#cc7832;"><br/></span><span style="color:#cc7832;">    </span><span style="color:#cc7832;font-weight:bold;">case </span><span style="color:#6897bb;">1</span>:<br/>      <span style="color:#cc7832;background-color:#344134;font-weight:bold;">return </span><span style="background-color:#344134;">timer._callback(argv[</span><span style="color:#6897bb;background-color:#344134;">0</span><span style="background-color:#344134;">])</span><span style="color:#cc7832;background-color:#344134;">;</span><span style="color:#cc7832;"><br/></span><span style="color:#cc7832;">    </span><span style="color:#cc7832;font-weight:bold;">case </span><span style="color:#6897bb;">2</span>:<br/>      <span style="color:#cc7832;background-color:#344134;font-weight:bold;">return </span><span style="background-color:#344134;">timer._callback(argv[</span><span style="color:#6897bb;background-color:#344134;">0</span><span style="background-color:#344134;">]</span><span style="color:#cc7832;background-color:#344134;">, </span><span style="background-color:#344134;">argv[</span><span style="color:#6897bb;background-color:#344134;">1</span><span style="background-color:#344134;">])</span><span style="color:#cc7832;background-color:#344134;">;</span><span style="color:#cc7832;"><br/></span><span style="color:#cc7832;">    </span><span style="color:#cc7832;font-weight:bold;">case </span><span style="color:#6897bb;">3</span>:<br/>      <span style="color:#cc7832;background-color:#344134;font-weight:bold;">return </span><span style="background-color:#344134;">timer._callback(argv[</span><span style="color:#6897bb;background-color:#344134;">0</span><span style="background-color:#344134;">]</span><span style="color:#cc7832;background-color:#344134;">, </span><span style="background-color:#344134;">argv[</span><span style="color:#6897bb;background-color:#344134;">1</span><span style="background-color:#344134;">]</span><span style="color:#cc7832;background-color:#344134;">, </span><span style="background-color:#344134;">argv[</span><span style="color:#6897bb;background-color:#344134;">2</span><span style="background-color:#344134;">])</span><span style="color:#cc7832;background-color:#344134;">;</span><span style="color:#cc7832;"><br/></span><span style="color:#cc7832;">    </span><span style="color:#808080;">// more than 3 arguments run slower with .apply<br/></span><span style="color:#808080;">    </span><span style="color:#cc7832;font-weight:bold;">default</span>:<br/>      <span style="color:#cc7832;background-color:#344134;font-weight:bold;">return </span><span style="background-color:#344134;">timer._callback.apply(timer</span><span style="color:#cc7832;background-color:#344134;">, </span><span style="background-color:#344134;">argv)</span><span style="color:#cc7832;background-color:#344134;">;</span><span style="color:#cc7832;"><br/></span><span style="color:#cc7832;">  </span>}<br/>}
</pre>用户回调运行完毕后，代码执行很快结束了；上面都是js层次所发生的事情，js层面的工作，主要是为用户提供接口函数，并且为c／c++底层提供接口属性，便于从底层通知js层面，而js层面则负责触发回调，如果js层面的用户回调发生错误，也有相关处理。</div><div><br/></div><div>那么c在什么时候通知js层次，processImmediate函数该执行了呢？请见下节！<font style="font-family: Monaco; font-size: 12px; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51);"/></div><div><br/></div></body></html>