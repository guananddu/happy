<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 6.10 (454267)"/><meta name="author" content="管伟"/><meta name="created" content="2016-12-26 08:10:45 +0000"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2016-12-27 16:53:44 +0000"/><title>buffer 模块深究 - 3 - Buffer.allocUnsafe &amp; Buffer.from</title></head><body><style>
    a { color: #43B0D6 !important; }
    a:visited { color: #7b7ed2 !important; }
    .title-p { font-size:12px; color:gray; }
    .title-hr { margin-bottom: 20px; }
    .tail-hr { margin-top: 20px; }
    .tail-licenses { border:1px dashed lightgray; margin:20px 0 20px 0; padding:20px; font-size:14px; }
</style>
<h2>buffer 模块深究 - 3 - Buffer.allocUnsafe &amp; Buffer.from</h2>
<p class="title-p">版权声明：自由转载-非商用-非衍生-保持署名(<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">创意共享3.0许可证</a>)</p>
<p class="title-p">文章作者：Pooky (<a href="mailto:guananddu@icloud.com">guananddu@icloud.com</a>)</p>
<hr class="title-hr"><div>前两节主要分析 buffer 模块的加载时机，以及 Buffer.alloc 函数的内部调用逻辑，本节主要来分析 Buffer.allocUnsafe 函数，先来一些总结信息：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">Calling Buffer.alloc() can be significantly slower than the alternative Buffer.allocUnsafe() but ensures that the newly created Buffer instance contents will never contain sensitive data.The underlying memory for Buffer instances created(Buffer.allocUnsafe) in this way is not initialized. The contents of the newly created Buffer are unknown and may contain sensitive data. Use Buffer.alloc() instead to initialize Buffer instances to zeroes.</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">Note that the Buffer module pre-allocates an internal Buffer instance of size Buffer.poolSize that is used as a pool for the fast allocation of new Buffer instances created using Buffer.allocUnsafe() and the deprecated new Buffer(size) constructor only <u>when size is less than or equal to Buffer.poolSize &gt;&gt; 1 (floor of Buffer.poolSize divided by two)</u>.</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">Use of this pre-allocated internal memory pool is <u>a key difference</u> between calling Buffer.alloc(size, fill) vs. Buffer.allocUnsafe(size).fill(fill). Specifically, Buffer.alloc(size, fill) will never use the internal Buffer pool, while Buffer.allocUnsafe(size).fill(fill) will use the internal Buffer pool if size is less than or equal to half Buffer.poolSize. The difference is subtle but can be important when an application requires the additional performance that Buffer.allocUnsafe() provides.</font><br/></div></div><div><br/></div><div>注意上面加下划线的语句。来看下面的测试代码：</div><div><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'Menlo';font-size:13.5pt;"><span style="color:#808080;">// Creates an uninitialized buffer of length 20.<br/></span><span style="color:#808080;">// This is faster than calling Buffer.alloc() but the returned<br/></span><span style="color:#808080;">// Buffer instance might contain old data that needs to be<br/></span><span style="color:#808080;">// overwritten using either fill() or write().<br/></span><span style="color:#cc7832;font-weight:bold;">const </span>buf3 = Buffer.<span style="color:#ffc66d;">allocUnsafe</span>( <span style="color:#6897bb;">20 </span>)<span style="color:#cc7832;">;<br/></span><span style="color:#9876aa;">console</span>.<span style="color:#ffc66d;">log</span>( <span style="color:#6a8759;">'buf3: '</span><span style="color:#cc7832;">, </span>buf3 )<span style="color:#cc7832;">;</span>
</pre></div><div>最终，Buffer.allocUnsafe 函数进入 buffer 内部私有函数：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">function allocate(size) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // size == 20</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (size &lt;= 0) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    return new FastBuffer();</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  }</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // Buffer.poolSize == 8 * 1024 == 8192</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // 右移一位相当于 Buffer.poolSize / 2 操作【此节开始部分的文字有说明】</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // 关于“无符号右移运算符”：https://msdn.microsoft.com/zh-cn/library/x0ax6803(VS.80).aspx</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // 如果此次新申请的空间大小小于 Buffer.poolSize 的一半，则不需要再次调用 createUnsafeBuffer</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (size &lt; (Buffer.poolSize &gt;&gt;&gt; 1)) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    // 如果此次新申请的空间大小大于目前 pool 的剩余空间大小</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    if (size &gt; (poolSize - poolOffset))</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      // 则需要新创建 pool【见下】</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      createPool();</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    // 如果不需要新建 pool 则调用 slice 来“切分出”可用区域</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    // slice 分析见下: poolOffset == 1392 | poolOffset + size == 1392 + 20 == 1412</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    var b = allocPool.slice(poolOffset, poolOffset + size);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    // 全局偏移量记录更新</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    poolOffset += size;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    // alignPool 保证偏移量始终是 8 的倍数【见下分析】</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    alignPool();</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    return b; // 最终返回新的 Buffer 实例</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  } else {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    // Even though this is checked above, the conditional is a safety net and</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    // sanity check to prevent any subsequent typed array allocation from not</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    // being zero filled.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    return createUnsafeBuffer(size);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  }</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">}</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">====&gt;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">// createPool 的调用比较简单</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">function createPool() {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // poolSize 记录目前可用的空间大小，因为是新创建，所以为最大值</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  poolSize = Buffer.poolSize;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // 创建 FastBuffer（Buffer） 实例对象，并且把“指针”赋予 allocPool</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  allocPool = createUnsafeBuffer(poolSize);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // 恢复目前的“赋值” pool 的偏移量为 0</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  poolOffset = 0;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">}</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">====&gt;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">// 这个 slice 函数很重要</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">Buffer.prototype.slice = function slice(start, end) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // this.length == 8192 【总空间大小】</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // start == 1392 【申请之前的偏移量】| end == 1412</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  const srcLength = this.length;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  start = adjustOffset(start, srcLength);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  end = end !== undefined ? adjustOffset(end, srcLength) : srcLength;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // 以上 start,end 都会做一下 offset 适配</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  const newLength = end &gt; start ? end - start : 0; // 20</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // ✨✨</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // this.buffer 返回当前的 allocPool Buffer 实例对象的 ArrayBuffer 本体</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // this.byteOffset === 0 因为每一个新创建的 allocPool 肯定是全部暴露出来的</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // 但是这个新创建的 FastBuffer（Buffer）实例对象，则是为老的 allocPool 对象新开了一扇窗口</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // 所以说，此新创建的 FastBuffer 实例对象和目前的全局 allocPool Buffer对象是共享内存的</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // 但是对用户来说，这个 FastBuffer 是一个“新的” Buffer 实例</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  return new FastBuffer(this.buffer, this.byteOffset + start, newLength);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">};</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">====&gt;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">// 此函数主要是做 offset 参数的适配</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">function adjustOffset(offset, length) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  offset = +offset;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // 等于 0 或者不为数字的情况</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (offset === 0 || Number.isNaN(offset)) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    return 0;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  }</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // 为负数的情况</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (offset &lt; 0) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    offset += length;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    return offset &gt; 0 ? offset : 0;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  } else {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    // 正常情况</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    return offset &lt; length ? offset : length;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  }</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">}</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">====&gt;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">function alignPool() {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // Ensure aligned slices</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // 如果不能整除 8 </font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (poolOffset &amp; 0x7) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    // 则加上余数</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    poolOffset |= 0x7;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    // 再补 1 即可</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    poolOffset++;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  }</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">}</font></div><div><br/><br/></div></div><div><br/></div><div>上面整个代码块，则是 Buffer.allocUnsafe 的调用分析。可知其内存分配细节：如果申请大于 Buffer.poolSize / 2 大小 Buffer 实例，则会直接通过创建新的一整个的 FastBuffer 实例来实现；如果申请的 Buffer 实例大小小于 Buffer.poolSize / 2 的的大小，则通过以 Buffer[ Buffer.poolSize ] 为单位的一块一块内存区域来实现内存动态分配。</div><div><br/></div><div><hr/></div><div><br/></div><div>关于 Buffer.from 函数分析，首先看测试代码：</div><div><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'Menlo';font-size:13.5pt;"><span style="color:#808080;">// Creates a Buffer containing [0x1, 0x2, 0x3].<br/></span><span style="color:#cc7832;font-weight:bold;">const </span>buf4 = Buffer.<span style="color:#ffc66d;">from</span>( [ <span style="color:#6897bb;">1</span><span style="color:#cc7832;">, </span><span style="color:#6897bb;">2</span><span style="color:#cc7832;">, </span><span style="color:#6897bb;">3 </span>] )<span style="color:#cc7832;">;<br/></span><span style="color:#9876aa;">console</span>.<span style="color:#ffc66d;">log</span>( <span style="color:#6a8759;">'buf4: '</span><span style="color:#cc7832;">, </span>buf4 )<span style="color:#cc7832;">;</span>
</pre>传入一个真实的数组类型，再经过 Buffer.from 函数的层层判断过后，最终进入函数：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">function fromArrayLike(obj) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // 传入的 obj 即为原数组</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  const length = obj.length;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // 此 allocate 函数，本节前半部分已经分析过，说明参数为数组的情况下，仍旧采用 allocPool 机制来实现内存分配</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // Uint8Array[3]</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  const b = allocate(length);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  for (var i = 0; i &lt; length; i++)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    // 简单赋值，但是这里需要清楚的是 b[ i ] 的值在 8 位之下（包括）【即 255 之下（包括）】</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    b[i] = obj[i];</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  return b;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">}</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">====&gt;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">&gt; var arr = [260, 1]</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">undefined</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">&gt; Buffer.from(arr)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">&lt;Buffer 04 01&gt;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">&gt; var arr = [256, 1]</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">undefined</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">&gt; Buffer.from(arr)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">&lt;Buffer 00 01&gt;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">&gt; var bb = Buffer.from( arr )</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">undefined</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">&gt; bb[ 0 ]</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">0</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">&gt; var arr = [255, 1]</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">undefined</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">&gt; Buffer.from(arr)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">&lt;Buffer ff 01&gt;</font></div><div><br/><br/></div></div><div><br/></div><div><hr/></div><div><br/></div><div>🌟再来看 Buffer.from( String str ) 的调用，如下测试代码，传入的是半角字符：</div><div><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'Menlo';font-size:13.5pt;"><span style="color:#808080;">// Creates a Buffer containing ASCII bytes.<br/></span><span style="color:#cc7832;font-weight:bold;">const </span>buf5 = Buffer.<span style="color:#ffc66d;">from</span>( <span style="color:#6a8759;">'i am a buffer test!i am a buffer test!' </span>)<span style="color:#cc7832;">;<br/></span><span style="color:#9876aa;">console</span>.<span style="color:#ffc66d;">log</span>( <span style="color:#6a8759;">'buf5: '</span><span style="color:#cc7832;">, </span>buf5 )<span style="color:#cc7832;">;</span>
</pre></div><div>最终经过类型判断，进入函数：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">function fromString(string, encoding) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // encoding 为 undefined</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (typeof encoding !== 'string' || encoding === '')</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    encoding = 'utf8';</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // 判断编码字符串是否正确</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (!Buffer.isEncoding(encoding))</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    throw new TypeError('"encoding" must be a valid string encoding');</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (string.length === 0)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    return new FastBuffer();</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // 通过 encoding 的不同来计算 string 的字节大小</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // 见下仍旧是 38</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  var length = byteLength(string, encoding);</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (length &gt;= (Buffer.poolSize &gt;&gt;&gt; 1))</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    return binding.createFromString(string, encoding);</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (length &gt; (poolSize - poolOffset))</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    createPool();</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  var actual = allocPool.write(string, poolOffset, encoding);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  var b = allocPool.slice(poolOffset, poolOffset + actual);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  poolOffset += actual;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  alignPool();</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  return b;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">}</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">====&gt;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">function byteLength(string, encoding) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  . . .</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // 字符个数</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  var len = string.length;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (len === 0)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    return 0;</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // Use a for loop to avoid recursion</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // 不同的编码，不同的字节长计算类型</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  var loweredCase = false;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  for (;;) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    switch (encoding) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      // 单字节编码</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      case 'ascii':</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      case 'latin1':</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      case 'binary':</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">        return len;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      // 多字节编码</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      case 'utf8':</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      case 'utf-8':</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      case undefined:</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">        // 直接调用了 c++ 层次的 api，底层调用 V8 api【不去深究了】</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">        return binding.byteLengthUtf8(string);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      // 双字节编码</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      case 'ucs2':</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      case 'ucs-2':</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      case 'utf16le':</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      case 'utf-16le':</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">        return len * 2;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      // 16 进制的话则需要除 2</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      case 'hex':</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">        return len &gt;&gt;&gt; 1;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      // base64 编码长度计算</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      case 'base64':</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">        return base64ByteLength(string, len);</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      default:</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">        // The C++ binding defaulted to UTF8, we should too.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">        if (loweredCase)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">          return binding.byteLengthUtf8(string);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">        // 如果写得大写字母</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">        encoding = ('' + encoding).toLowerCase();</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">        loweredCase = true;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    }</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  }</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">}</font></div><div><br/><br/></div></div><div><br/></div><div>未完待续</div><div><br/></div>

<hr class="tail-hr">
<div class="tail-licenses">
<p>版权声明：自由转载-非商用-非衍生-保持署名(<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">创意共享3.0许可证</a>)</p>
<p>文章作者：Pooky (<a href="mailto:guananddu@icloud.com">guananddu@icloud.com</a>)</p>
<p>更新日期：Wed Dec 28 2016 00:56:24 GMT+0800 (CST)</p>
</div></body></html>