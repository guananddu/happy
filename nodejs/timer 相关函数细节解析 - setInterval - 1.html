<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 6.10 (454267)"/><meta name="author" content="管伟"/><meta name="created" content="2016-11-14 05:28:15 +0000"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2016-11-15 08:23:06 +0000"/><title>timer 相关函数细节解析 - setInterval - 1</title></head><body><style>
    a { color: #43B0D6 !important; }
    a:visited { color: #7b7ed2 !important; }
    .title-p { font-size:12px; color:gray; }
    .title-hr { margin-bottom: 20px; }
    .tail-hr { margin-top: 20px; }
    .tail-licenses { border:1px dashed lightgray; margin:20px 0 20px 0; padding:20px; font-size:14px; }
</style>
<h2>timer 相关函数细节解析 - setInterval - 1</h2>
<p class="title-p">版权声明：自由转载-非商用-非衍生-保持署名(<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">创意共享3.0许可证</a>)</p>
<p class="title-p">文章作者：Pooky (<a href="mailto:guananddu@icloud.com">guananddu@icloud.com</a>)</p>
<hr class="title-hr"><div>此节开始分析 setInterval 相关逻辑：</div><div><br/></div><div>setInterval 最终调入 timers.js 文件中的：</div><div><pre style="background-color: rgb(43, 43, 43); color: rgb(169, 183, 198); font-family: Menlo;"><font style="font-size: 14px;"><span style="background-color: rgb(52, 65, 52);">exports</span>.setInterval = <span style="color: rgb(204, 120, 50); font-weight: bold;">function</span>(callback<span style="color: rgb(204, 120, 50);">, </span>repeat) {<br/>  <span style="color: rgb(204, 120, 50); font-weight: bold;">if </span>(<span style="color: rgb(204, 120, 50); font-weight: bold;">typeof </span>callback !== <span style="color: rgb(106, 135, 89);">'function'</span>) {<br/>    <span style="color: rgb(204, 120, 50); font-weight: bold;">throw new </span>TypeError(<span style="color: rgb(106, 135, 89);">'"callback" argument must be a function'</span>)<span style="color: rgb(204, 120, 50);">;<br/></span><span style="color: rgb(204, 120, 50);">  </span>}<br/><br/>  repeat *= <span style="color: rgb(104, 151, 187);">1</span><span style="color: rgb(204, 120, 50);">; </span><span style="color: rgb(128, 128, 128);">// coalesce to number or NaN<br/></span><span style="color: rgb(128, 128, 128);"><br/></span><span style="color: rgb(128, 128, 128);">  </span><span style="color: rgb(204, 120, 50); font-weight: bold;">if </span>(!(repeat &gt;= <span style="color: rgb(104, 151, 187);">1 </span>&amp;&amp; repeat &lt;= TIMEOUT_MAX)) {<br/>    repeat = <span style="color: rgb(104, 151, 187);">1</span><span style="color: rgb(204, 120, 50);">; </span><span style="color: rgb(128, 128, 128);">// schedule on next tick, follows browser behaviour<br/></span><span style="color: rgb(128, 128, 128);">  </span>}<br/><br/>  <span style="color: rgb(204, 120, 50); font-weight: bold;">var </span>timer = <span style="color: rgb(204, 120, 50); font-weight: bold;">new </span>Timeout(repeat)<span style="color: rgb(204, 120, 50);">;// 后面省略</span></font><font size="4"
/></pre></div><div>会新建一个 Timeout 对象：</div><div><img src="timer%20%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E7%BB%86%E8%8A%82%E8%A7%A3%E6%9E%90%20-%20setInterval%20-%201.resources/E96C68F3-5753-44A9-B437-5BCF49FF643C.png" height="auto" width="100%"/><br/></div><div>可见，其延迟参数被初始化为 this._idleTimeout 属性，接着往下初始化，注意其关键属性的赋值：</div><div><img src="timer%20%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E7%BB%86%E8%8A%82%E8%A7%A3%E6%9E%90%20-%20setInterval%20-%201.resources/3A8FB49A-D942-468C-BEB6-839258424828.png" height="auto" width="100%"/><br/></div><div>timer._onTimeout 指向一个内部的wrapper函数，而，_repeat 则指向被简易包装后的用户回调函数。</div><div>exports.setInterval 函数的最后，调用 active( timer ) 函数，并且返回新创建的Timeout对象。</div><div>来看看 active(timer) 的逻辑：</div><div><img src="timer%20%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E7%BB%86%E8%8A%82%E8%A7%A3%E6%9E%90%20-%20setInterval%20-%201.resources/60B2C775-1419-4EBC-B1C7-87DF1447ECB5.png" height="auto" width="100%"/><br/></div><div>active 函数又调用了 insert 函数：</div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">// The underlying logic for scheduling or re-scheduling a timer.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">//</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">// Appends a timer onto the end of an existing timers list, or creates a new</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">// TimerWrap backed list if one does not already exist for the specified timeout</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">// duration.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">function insert(item, unrefed) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>  // msecs 即为interval间隔时间，毫秒记</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  const msecs = item._idleTimeout;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  if (msecs &lt; 0 || msecs === undefined) return;</font></div><div><span>  // 这里调用了binding的c++实现，见下</span><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  item._idleStart = TimerWrap.now();</font></div><div><span>  // 真正决定采用哪个list对象：</span><br/></div><div><span>  <img src="timer%20%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E7%BB%86%E8%8A%82%E8%A7%A3%E6%9E%90%20-%20setInterval%20-%201.resources/79C0C8C2-1AFD-4B80-86EE-4497552A3D18.png" height="auto" width="100%"/><br/></span></div><div><span><span>  // 真正区别见注释，一般情况下 unrefed == false，默认使用 refedLists</span><br/></span></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  const lists = unrefed === true ? unrefedLists : refedLists;</font></div><div><span>  // 检查是不是已经存在一个了，key即位setInterval的时间</span><br/></div><div><span>  <img src="timer%20%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E7%BB%86%E8%8A%82%E8%A7%A3%E6%9E%90%20-%20setInterval%20-%201.resources/EDA53B5D-50FA-4359-9CF2-5B8C4D5752BA.png" height="auto" width="100%"/><br/></span></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  // Use an existing list if there is one, otherwise we need to make a new one.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  var list = lists[msecs];</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  if (!list) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    debug('no %d list was found in insert, creating a new one', msecs);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    // Make a new linked list of timers, and create a TimerWrap to schedule</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    // processing for the list.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>    // 看看细节，注意这里的细节，有 new TimerWrap() 的逻辑，会调用至c++层面【详见下方分析】</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>    // 每一个delay节点的timerslist都会又一个TimerWrap的底层对象引用</span></font></div><div>    <img src="timer%20%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E7%BB%86%E8%8A%82%E8%A7%A3%E6%9E%90%20-%20setInterval%20-%201.resources/15196D4E-2F05-4335-BA65-822EF7E40B4D.png" height="auto" width="100%"/><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    list = new TimersList(msecs, unrefed);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>    // 将其初始化为一个空的双向链表</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    L.init(list);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>    // 底层的 Timer 对象持有对js层级的双向链表的引用</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    list._timer._list = list;</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    if (unrefed === true) list._timer.unref();</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>    // 开始调用底层Timer实例的start方法【见下分析】</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    list._timer.start(msecs);</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    lists[msecs] = list;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    list._timer[kOnTimeout] = listOnTimeout;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  }</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  L.append(list, item);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  assert(!L.isEmpty(list)); // list is not empty</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">}</font><br/></div></div><div><br/></div><div>关于 TimerWrap.now()【静态方法】:</div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  static void Now(const FunctionCallbackInfo&lt;Value&gt;&amp; args) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    Environment* env = Environment::GetCurrent(args);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>    // 通过深入调用：uv__update_time -&gt; uv__hrtime 返回绝对cpu时钟滴答数【最终返回纳秒】</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>    <img src="timer%20%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E7%BB%86%E8%8A%82%E8%A7%A3%E6%9E%90%20-%20setInterval%20-%201.resources/E179BAE2-133C-4E3C-B324-06046AD18A60.png" height="auto" width="100%"/><br/></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>    // 下方的loop-&gt;time被更新为： <font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">time     uint64_t     10207884</font><img src="timer%20%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E7%BB%86%E8%8A%82%E8%A7%A3%E6%9E%90%20-%20setInterval%20-%201.resources/09010155-BB51-4A1F-AD92-530BABB89564.png" height="auto" width="100%"/><br/></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    // 更新loop-&gt;time的值（毫秒）</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    uv_update_time(env-&gt;event_loop());</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><img src="timer%20%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E7%BB%86%E8%8A%82%E8%A7%A3%E6%9E%90%20-%20setInterval%20-%201.resources/68A4A5F9-3178-4B3D-BBEE-F5282D91175C.png" height="auto" width="100%"/><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    // uv_now 则返回此数值</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>    // <font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">now     uint64_t     10207884</font></span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    uint64_t now = uv_now(env-&gt;event_loop());</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>    // <font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">timer_base_     uint64_t     9722915【注意此值】</font></span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    CHECK(now &gt;= env-&gt;timer_base());</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>    // 减去timer_base【为什么呢？】</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    now -= env-&gt;timer_base();</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>    // 根据大小返回不同精读的值？</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span><span>    // <font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">now     uint64_t     484969</font></span><br/></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span><span><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>    // 最终返回读值</span><br/></font></span></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    if (now &lt;= 0xfffffff)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">      args.GetReturnValue().Set(static_cast&lt;uint32_t&gt;(now));</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    else</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">      args.GetReturnValue().Set(static_cast&lt;double&gt;(now));</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  }</font><br/></div></div><div><br/></div><div>总的来说，TimeWrap.now() 返回一个与当前loop相关“相对时间点（毫秒记）”，用来标记当前的Timeout对象的开始时间点。</div><div><hr/></div><div>关于new TimerWrap() 逻辑：</div><div><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'Menlo';font-size:13.5pt;"><span style="color:#cc7832;font-weight:bold;">this</span>._timer = <span style="color:#cc7832;font-weight:bold;">new </span>TimerWrap()<span style="color:#cc7832;">;</span>
</pre>需要多说一句，因为此举代码会调用至底层c++：</div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">#0     0x000000010008dd1c in node::TimerWrap::New(v8::FunctionCallbackInfo&lt;v8::Value&gt; const&amp;) at /Users/mrguan/work/build/node/node-6.6.0/src/timer_wrap.cc:57</font></div><div><br/></div><div>...</div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"> private:</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  static void New(const FunctionCallbackInfo&lt;Value&gt;&amp; args) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    // This constructor should not be exposed to public javascript.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    // Therefore we assert that we are not trying to call this as a</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    // normal function.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>    // 调用次函数必需采用构造函数的方式</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    CHECK(args.IsConstructCall()); // line 57</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    Environment* env = Environment::GetCurrent(args);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    new TimerWrap(env, args.This());</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  }</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  TimerWrap(Environment* env, Local&lt;Object&gt; object)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">      : HandleWrap(env,</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">                   object,</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">                   reinterpret_cast&lt;uv_handle_t*&gt;(&amp;handle_),</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">                   AsyncWrap::PROVIDER_TIMERWRAP) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>    // 这个初始化太深入了，只考虑此层级的构造逻辑</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span><span>    // uv_timer_init 具体分析见下；handle_ 是一个实例属性【新创建】</span><br/></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    int r = uv_timer_init(env-&gt;event_loop(), &amp;handle_);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    CHECK_EQ(r, 0);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  }</font><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">...</font></div></div><div><hr/>关于uv_timer_init函数调用：</div><div/><div style="box-sizing: border-box; padding: 8px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div style="color: rgb(51, 51, 51); font-size: 12px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">#0     0x000000010102c6dc in uv_timer_init at /Users/mrguan/work/build/node/node-6.6.0/deps/uv/src/unix/timer.c:55</font></div><div style="color: rgb(51, 51, 51); font-size: 12px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><br/></div><div style="color: rgb(51, 51, 51); font-size: 12px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">int uv_timer_init(uv_loop_t* loop, uv_timer_t* handle) {</font></div><div style="color: rgb(51, 51, 51); font-size: 12px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>  // uv__handle_init 是一个宏，见下</span><br/></font></div><div style="color: rgb(51, 51, 51); font-size: 12px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  uv__handle_init(loop, (uv_handle_t*)handle, UV_TIMER);</font></div><div style="color: rgb(51, 51, 51); font-size: 12px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span>  // 标记handle的timer_cb属性为空</span><br/></div><div style="color: rgb(51, 51, 51); font-size: 12px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  handle-&gt;timer_cb = NULL;</font></div><div style="color: rgb(51, 51, 51); font-size: 12px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  handle-&gt;repeat = 0;</font></div><div style="color: rgb(51, 51, 51); font-size: 12px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  return 0;</font></div><div style="color: rgb(51, 51, 51); font-size: 12px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">}</font><br/></div><div style="color: rgb(51, 51, 51); font-size: 12px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><br/></font></div><div style="color: rgb(51, 51, 51); font-size: 12px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><img src="timer%20%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E7%BB%86%E8%8A%82%E8%A7%A3%E6%9E%90%20-%20setInterval%20-%201.resources/8038BA0B-2977-49BC-98C5-F3C509D27618.png" height="auto" width="100%"/><br/></font></div><div style="color: rgb(51, 51, 51); font-size: 12px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><img src="timer%20%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E7%BB%86%E8%8A%82%E8%A7%A3%E6%9E%90%20-%20setInterval%20-%201.resources/96AA9C27-C82E-4924-8325-AC57A10E86C7.png" height="auto" width="100%"/><br/></font></div><div style="color: rgb(51, 51, 51); font-size: 12px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><br/></font></div><div style="color: rgb(51, 51, 51); font-size: 12px;"><font face="Monaco">uv_timer_s 除了普通的 UV_HANDLE_FIELDS 字段，还有自己的特殊字段，见下截图：</font></div><div style="color: rgb(51, 51, 51); font-size: 12px;"><font face="Monaco"><br/></font></div><div style="color: rgb(51, 51, 51); font-size: 12px;"><font face="Monaco"><img src="timer%20%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E7%BB%86%E8%8A%82%E8%A7%A3%E6%9E%90%20-%20setInterval%20-%201.resources/7A68C994-5BFD-4A0E-BCB0-54038978968D.png" height="auto" width="100%"/> </font></div><div style="color: rgb(51, 51, 51); font-size: 12px;"><font face="Monaco"><img src="timer%20%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E7%BB%86%E8%8A%82%E8%A7%A3%E6%9E%90%20-%20setInterval%20-%201.resources/C075ED62-1B7C-4D1E-BE76-351FA836DAA8.png" height="auto" width="100%"/><br/></font></div><div style="color: rgb(51, 51, 51); font-size: 12px;"/><div style="color: rgb(51, 51, 51); font-size: 12px;"/><div style="color: rgb(51, 51, 51); font-size: 12px;"><font face="Monaco"/></div><div style="color: rgb(51, 51, 51); font-size: 12px;"><font face="Monaco"/></div><div style="color: rgb(51, 51, 51); font-size: 12px;"><font face="Monaco"/></div><div style="color: rgb(51, 51, 51); font-size: 12px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"/></div><div style="color: rgb(51, 51, 51); font-size: 12px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"/></div><div style="color: rgb(51, 51, 51); font-size: 12px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"/></div><div style="color: rgb(51, 51, 51); font-size: 12px;"><font face="Monaco"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"/></font></div></div><div><br/></div><div>来看 uv__handle_init 宏：</div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><span style="font: 18.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #d28f5a">#define uv__handle_init(loop_, h, type_)                                      \<br/>  do {                                                                        \</span></div><div><span style="font: 18.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #d28f5a"><span>    // 设置当前新创建的handle的loop属性【只读，每一个handle均有此属性】</span><br/>    (h)-&gt;loop = (loop_);                                                      \</span></div><div><span style="font: 18.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #d28f5a"><span>    // 设置handle的type</span><br/>    (h)-&gt;type = (type_);                                                      \<br/>    (h)-&gt;flags = UV__HANDLE_REF;  </span><span style="font: 18.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #4dbf56">/* Ref the loop when active. */</span><span style="font: 18.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #d28f5a">             \</span></div><div><span style="font: 18.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #d28f5a"><span>    // 将此handle插入到loop-&gt;handle_queue的队列尾部【双向链表的尾部，最老，即链表头的prev指向此节点】</span><br/>    QUEUE_INSERT_TAIL(&amp;(loop_)-&gt;handle_queue, &amp;(h)-&gt;handle_queue);            \</span></div><div><span style="font: 18.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #d28f5a"><span>    // 见下</span><br/>    uv__handle_platform_init(h);                                              \<br/>  }                                                                           \<br/>  while (</span><span style="font: 18.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #8b84cf">0</span><span style="font: 18.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #d28f5a">)</span><br/></div><div><span style="font: 18.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #d28f5a"><br/></span></div><div><span style="font: 18.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #d28f5a"><span style="font: 18.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #d28f5a">#if defined(_WIN32)<br/>
# define uv__handle_platform_init(h) ((h)-&gt;u.fd = -</span><span style="font: 18.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #8b84cf">1</span><span style="font: 18.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #d28f5a">)<br/>
#else<br/>
# define uv__handle_platform_init(h) ((h)-&gt;next_closing = NULL)<br/>
#endif</span><br/></span></div></div><div><br/></div><div>因此，new TimerWrap() 的逻辑，是新创建了一个Timer的底层对象，这个对象在构造的时候，创建了新的timer handle，并且将此handle插入至loop的handle_queue双向链表中的最末尾的位置去。底层逻辑，参见：</div><div/><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">#0     0x000000010008e1fe in node::TimerWrap::TimerWrap(node::Environment*, v8::Local&lt;v8::Object&gt;) at /Users/mrguan/work/build/node/node-6.6.0/src/timer_wrap.cc:69</font></div></div><div/><div>透过底层timer_wrap的binding实现，可知：</div><div><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'Menlo';font-size:13.5pt;"><span style="color:#cc7832;font-weight:bold;">const </span>TimerWrap = process.binding(<span style="color:#6a8759;">'timer_wrap'</span>).Timer<span style="color:#cc7832;">;</span>
</pre>的返回值应该是一个由c++层次来实现的构造函数：</div><div><img src="timer%20%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E7%BB%86%E8%8A%82%E8%A7%A3%E6%9E%90%20-%20setInterval%20-%201.resources/BF562456-72B1-4DA3-B185-682C9D9698EB.png" height="auto" width="100%"/><br/></div><div>且，其暴露出来的构造函数的名称为：Timer，且为其设置了now这个静态方法，和一系列的原型方法！在创建一个新的TimerLists对象的时候，此对象实例会保有一个this._timer = new TimerWrap() 引用，也就是底层的Timer构造出的对象的引用！在Timer被初始化成功以后，会有新的timer handle被创建，并且被插入至loop-&gt;handle_queue双向链表队列中去。</div><div><hr/></div><div>关于list._timer.start(msecs)底层调用：</div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">#0     0x000000010008e043 in node::TimerWrap::Start(v8::FunctionCallbackInfo&lt;v8::Value&gt; const&amp;) at /Users/mrguan/work/build/node/node-6.6.0/src/timer_wrap.cc:77</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  static void Start(const FunctionCallbackInfo&lt;Value&gt;&amp; args) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>    // 此函数是在js层级被调用，此句的含义，是把js层级的实例对象，转化为c++层级的实例对象</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    TimerWrap* wrap = Unwrap&lt;TimerWrap&gt;(args.Holder());</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    CHECK(HandleWrap::IsAlive(wrap));</font></div><div><span>    // 获取第一个参数 <font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">timeout     int64_t     2000</font></span><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    int64_t timeout = args[0]-&gt;IntegerValue();</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>    // 最终调用此处的重要函数</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    int err = uv_timer_start(&amp;wrap-&gt;handle_, OnTimeout, timeout, 0);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    args.GetReturnValue().Set(err);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  }</font><br/></div><div><br/></div><div>==</div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">#0     0x000000010102c788 in uv_timer_start at /Users/mrguan/work/build/node/node-6.6.0/deps/uv/src/unix/timer.c:68</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">int uv_timer_start(uv_timer_t* handle,</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">                   uv_timer_cb cb,</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">                   uint64_t timeout,</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">                   uint64_t repeat) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  uint64_t clamped_timeout;</font></div><div><span>  // <font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">cb     uv_timer_cb     (node`node::TimerWrap::OnTimeout(uv_timer_s*) at timer_wrap.cc:90)     0x000000010008e360</font></span><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  if (cb == NULL)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    return -EINVAL;</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  if (uv__is_active(handle))</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    uv_timer_stop(handle);</font></div><div><span>  // <font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">timeout     uint64_t     2000</font></span><br/></div><div><span><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>  // <font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">clamped_timeout     uint64_t     13563712</font></span><br/></font></span></div><div><span><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>  // 计算“到期”时间</span><br/></font></span></font></span></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  clamped_timeout = handle-&gt;loop-&gt;time + timeout;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  if (clamped_timeout &lt; timeout)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    clamped_timeout = (uint64_t) -1;</font></div><div><span>  // 设置此handle的timer_cb函数指针</span><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  handle-&gt;timer_cb = cb;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  // 设置此handle的到期时间</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  handle-&gt;timeout = clamped_timeout;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>  // <font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">repeat     uint64_t     0</font></span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  handle-&gt;repeat = repeat;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  /* start_id is the second index to be compared in uv__timer_cmp() */</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>  // 设置 start_id</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  handle-&gt;start_id = handle-&gt;loop-&gt;timer_counter++;</font></div><div><span>  // 重中之重的函数，这里设计两个类型转化：</span><br/></div><div><span>  <img src="timer%20%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E7%BB%86%E8%8A%82%E8%A7%A3%E6%9E%90%20-%20setInterval%20-%201.resources/7B2880AB-098B-4909-A9C4-84DAECF707F0.png" height="auto" width="100%"/><br/></span></div><div><span>  <img src="timer%20%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E7%BB%86%E8%8A%82%E8%A7%A3%E6%9E%90%20-%20setInterval%20-%201.resources/AE13BF43-473E-4A24-86C2-BA69CD0584FB.png" height="auto" width="100%"/><br/></span></div><div><span>  // 第三个参数是一个比较函数指针</span><br/></div><div><span>  <img src="timer%20%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E7%BB%86%E8%8A%82%E8%A7%A3%E6%9E%90%20-%20setInterval%20-%201.resources/2018ADAF-6088-4393-B4AB-A62144ED94F5.png" height="auto" width="100%"/><br/></span></div><div>  // 即一个loop会持有一个timer_heap的最小二叉树【完全二叉树】</div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  heap_insert((struct heap*) &amp;handle-&gt;loop-&gt;timer_heap,</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>    <span>    <span>    <span>  // 当前的handle节点</span></span></span></span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">              (struct heap_node*) &amp;handle-&gt;heap_node,</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">              timer_less_than);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  uv__handle_start(handle);</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  return 0;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">}</font><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"/></div><div>==</div><div>进入heap_insert来看看：</div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">#0     0x000000010102ca54 in heap_insert at /Users/mrguan/work/build/node/node-6.6.0/deps/uv/src/heap-inl.h:115</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">HEAP_EXPORT(void heap_insert(struct heap* heap,</font></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">                             struct heap_node* newnode,</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">                             heap_compare_fn less_than)) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  // 当第一次进入的时候（第一次调用setInterval函数）</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>  // <font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">heap     heap *     0x101b0c1f8     0x0000000101b0c1f8</font></span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>  // <span>    <font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">min     heap_node *     NULL     0x0000000000000000</font></span></span><br/></font></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span><span><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>  //<span>     <font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">nelts     unsigned int     0【除去根之外的节点数】</font></span></span><br/></font></span></span></font></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  struct heap_node** parent;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  struct heap_node** child;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  unsigned int path;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  unsigned int n;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  unsigned int k;</font></div><div>  // 首先置空新节点的各种指针</div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  newnode-&gt;left = NULL;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  newnode-&gt;right = NULL;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  newnode-&gt;parent = NULL;</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  /* Calculate the path from the root to the insertion point.（计算从插入点到跟节点的距离）  This is a min</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">   * heap so we always insert at the left-most free node of the bottom row.【往最底部最左边插入新节点】</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">   */</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  path = 0;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>  // 默认刚开始，heap-&gt;nelts肯定为0</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  for (k = 0, n = 1 + heap-&gt;nelts; n &gt;= 2; k += 1, n /= 2)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    path = (path &lt;&lt; 1) | (n &amp; 1);</font></div><div><span>  // <font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">path     unsigned int     0</font></span><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  /* Now traverse the heap using the path we calculated in the previous step. */</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  parent = child = &amp;heap-&gt;min;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  while (k &gt; 0) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    parent = child;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    if (path &amp; 1)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">      child = &amp;(*child)-&gt;right;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    else</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">      child = &amp;(*child)-&gt;left;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    path &gt;&gt;= 1;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    k -= 1;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  }</font></div><div><br/></div><div><span>  // 插入新节点</span><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  /* Insert the new node. */</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>  // 设置新节点的parent</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  newnode-&gt;parent = *parent;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>  // 第一次调用之时，指的是 loop-&gt;timer_heap-&gt;min 指向新节点</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  *child = newnode;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>  // 可见nelts记录的是二叉树的节点总数</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  heap-&gt;nelts += 1;</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  /* Walk up the tree and check at each node if the heap property holds.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">   * It's a min heap so parent &lt; child must be true.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">   */</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  // 第一次执行setInterval时，此分支不会执行</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  while (newnode-&gt;parent != NULL &amp;&amp; less_than(newnode, newnode-&gt;parent))</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    heap_node_swap(heap, newnode-&gt;parent, newnode);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">}</font><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"/></div><div>==</div><div>🌟 第一次执行 setInterval 时，只会在最小完全二叉堆中，插入一个节点，查看此时变量截图：</div><div><img src="timer%20%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E7%BB%86%E8%8A%82%E8%A7%A3%E6%9E%90%20-%20setInterval%20-%201.resources/7D708E8F-E45F-4145-91E2-9E376882D018.png" height="auto" width="100%"/><br/></div><div>可见，heap-&gt;min 就是（指向） newnode 节点</div><div>==</div><div>🌟 进入宏：uv__handle_start(handle)</div><div><span style="font: 18.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #d28f5a">#define uv__handle_start(h)                                                   \<br/>  do {                                                                        \<br/>    assert(((h)-&gt;flags &amp; UV__HANDLE_CLOSING) == </span><span style="font: 18.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #8b84cf">0</span><span style="font: 18.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #d28f5a">);                           \</span></div><div><span style="font: 18.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #d28f5a">    // 标记其激活状态<br/>    if (((h)-&gt;flags &amp; UV__HANDLE_ACTIVE) != </span><span style="font: 18.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #8b84cf">0</span><span style="font: 18.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #d28f5a">) break;                         \<br/>    (h)-&gt;flags |= UV__HANDLE_ACTIVE;                                          \</span></div><div><span style="font: 18.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #d28f5a">    // 此分支的确会进入【注意此节的上方有相关逻辑】<br/>    if (((h)-&gt;flags &amp; UV__HANDLE_REF) != </span><span style="font: 18.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #8b84cf">0</span><span style="font: 18.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #d28f5a">) uv__active_handle_add(h);         \<br/>  }                                                                           \<br/>  while (</span><span style="font: 18.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #8b84cf">0</span><span style="font: 18.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #d28f5a">)</span><br/></div><div><span style="font: 18.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #d28f5a"><br/></span></div><div><span style="font: 18.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #d28f5a"><span style="font: 18.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #d28f5a">#define uv__active_handle_add(h)                                              \<br/>  do {                                                                        \</span></span></div><div><span style="font: 18.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #d28f5a"><span style="font: 18.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #d28f5a"><span>    // timer handle会使得这里加1</span><br/>    (h)-&gt;loop-&gt;active_handles++;                                              \<br/>  }                                                                           \<br/>  while (</span><span style="font: 18.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #8b84cf">0</span><span style="font: 18.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #d28f5a">)</span><br/></span></div><div>==</div><div>🌟第二个setInterval调用，进入heap_insert之后的变量截图，从中可以看出结构：</div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">#0     0x000000010102cba9 in heap_insert at /Users/mrguan/work/build/node/node-6.6.0/deps/uv/src/heap-inl.h:148</font></div><div><img src="timer%20%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E7%BB%86%E8%8A%82%E8%A7%A3%E6%9E%90%20-%20setInterval%20-%201.resources/446F06D5-E0C9-49B2-8658-41A1261E48FE.png" height="auto" width="100%"/><br/></div><div>可见，原来的根节点heap-&gt;min的left上面插入了一个新的叶子节点，此叶子节点的parent即为heap-min节点；</div><div>==</div><div>🌟同样，在第二次插入完毕之后，会有比较父子节点的权重大小的逻辑，以保证此树始终为最小完全二叉堆结构：</div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  /* Walk up the tree and check at each node if the heap property holds.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">   * It's a min heap so parent &lt; child must be true.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">   */</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  while (newnode-&gt;parent != NULL &amp;&amp; less_than(newnode, newnode-&gt;parent))</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    heap_node_swap(heap, newnode-&gt;parent, newnode);</font><br/></div><div>==</div><div>🌟 来看看父子节点比较函数：</div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">static int timer_less_than(const struct heap_node* ha,</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">                           const struct heap_node* hb) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  const uv_timer_t* a;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  const uv_timer_t* b;</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  a = container_of(ha, const uv_timer_t, heap_node);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  b = container_of(hb, const uv_timer_t, heap_node);</font></div><div><span>  // 谁的触发事件越“早”，谁的位置越靠近根节点</span><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  if (a-&gt;timeout &lt; b-&gt;timeout)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    return 1;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  if (b-&gt;timeout &lt; a-&gt;timeout)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    return 0;</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  /* Compare start_id when both have the same timeout. start_id is</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">   * allocated with loop-&gt;timer_counter in uv_timer_start().</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">   */</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  if (a-&gt;start_id &lt; b-&gt;start_id)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    return 1;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  if (b-&gt;start_id &lt; a-&gt;start_id)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    return 0;</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  return 0;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">}</font><br/></div><div>==</div><div>🌟父子节点换位的算法不再深究</div><div>==</div></div><div><br/></div><div>有关“最小完全二叉堆结构”详细说明：</div><div><a href="https://en.wikipedia.org/wiki/Binary_heap">https://en.wikipedia.org/wiki/Binary_heap</a><br/></div><div><a href="http://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91">http://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91</a><br/></div><div><br/></div><div><img src="timer%20%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E7%BB%86%E8%8A%82%E8%A7%A3%E6%9E%90%20-%20setInterval%20-%201.resources/48F6D219-654C-43FA-B623-EA989883372B.png" height="auto" width="100%"/>  <img src="timer%20%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E7%BB%86%E8%8A%82%E8%A7%A3%E6%9E%90%20-%20setInterval%20-%201.resources/9AF0A140-AA08-468C-8ADD-FD8367783C1E.png" height="auto" width="100%"/><br/></div><div>而loop-&gt;timer_heap的数据结构为右图。</div><div>关于完全二叉树：</div><div><img src="timer%20%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E7%BB%86%E8%8A%82%E8%A7%A3%E6%9E%90%20-%20setInterval%20-%201.resources/C2924C77-422F-497E-88EB-9EDBB904FB9D.png" height="auto" width="100%"/><br/></div><div><br/></div>

<hr class="tail-hr">
<div class="tail-licenses">
<p>版权声明：自由转载-非商用-非衍生-保持署名(<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">创意共享3.0许可证</a>)</p>
<p>文章作者：Pooky (<a href="mailto:guananddu@icloud.com">guananddu@icloud.com</a>)</p>
<p>更新日期：Thu Dec 22 2016 16:38:14 GMT+0800 (CST)</p>
</div></body></html>