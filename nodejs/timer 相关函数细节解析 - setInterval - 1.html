<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 6.10 (454267)"/><meta name="author" content="管伟"/><meta name="created" content="2016-11-14 05:28:15 +0000"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2016-12-24 11:04:00 +0000"/><title>timer 相关函数细节解析 - setInterval - 1</title></head><body><style>
    a { color: #43B0D6 !important; }
    a:visited { color: #7b7ed2 !important; }
    .title-p { font-size:12px; color:gray; }
    .title-hr { margin-bottom: 20px; }
    .tail-hr { margin-top: 20px; }
    .tail-licenses { border:1px dashed lightgray; margin:20px 0 20px 0; padding:20px; font-size:14px; }
</style>
<h2>timer 相关函数细节解析 - setInterval - 1</h2>
<p class="title-p">版权声明：自由转载-非商用-非衍生-保持署名(<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">创意共享3.0许可证</a>)</p>
<p class="title-p">文章作者：Pooky (<a href="mailto:guananddu@icloud.com">guananddu@icloud.com</a>)</p>
<hr class="title-hr"><div>此节开始分析 setInterval 相关逻辑：</div><div><br/></div><div>setInterval 最终调入 timers.js 文件中的：</div><div><br/></div><div><pre style="background-color: rgb(43, 43, 43); color: rgb(169, 183, 198); font-family: Menlo;"><font style="font-size: 14px;"><span style="background-color: rgb(52, 65, 52);">exports</span>.setInterval = <span style="color: rgb(204, 120, 50); font-weight: bold;">function</span>(callback<span style="color: rgb(204, 120, 50);">, </span>repeat) {<br/>  <span style="color: rgb(204, 120, 50); font-weight: bold;">if </span>(<span style="color: rgb(204, 120, 50); font-weight: bold;">typeof </span>callback !== <span style="color: rgb(106, 135, 89);">'function'</span>) {<br/>    <span style="color: rgb(204, 120, 50); font-weight: bold;">throw new </span>TypeError(<span style="color: rgb(106, 135, 89);">'"callback" argument must be a function'</span>)<span style="color: rgb(204, 120, 50);">;<br/></span><span style="color: rgb(204, 120, 50);">  </span>}<br/><br/>  repeat *= <span style="color: rgb(104, 151, 187);">1</span><span style="color: rgb(204, 120, 50);">; </span><span style="color: rgb(128, 128, 128);">// coalesce to number or NaN<br/></span><span style="color: rgb(128, 128, 128);"><br/></span><span style="color: rgb(128, 128, 128);">  </span><span style="color: rgb(204, 120, 50); font-weight: bold;">if </span>(!(repeat &gt;= <span style="color: rgb(104, 151, 187);">1 </span>&amp;&amp; repeat &lt;= TIMEOUT_MAX)) {<br/>    repeat = <span style="color: rgb(104, 151, 187);">1</span><span style="color: rgb(204, 120, 50);">; </span><span style="color: rgb(128, 128, 128);">// schedule on next tick, follows browser behaviour<br/></span><span style="color: rgb(128, 128, 128);">  </span>}<br/><br/>  <span style="color: rgb(204, 120, 50); font-weight: bold;">var </span>timer = <span style="color: rgb(204, 120, 50); font-weight: bold;">new </span>Timeout(repeat)<span style="color: rgb(204, 120, 50);">;// 后面省略</span></font><font size="4"
/></pre></div><div><br/></div><div>会新建一个 Timeout 对象：</div><div><br/></div><div><img src="timer%20%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E7%BB%86%E8%8A%82%E8%A7%A3%E6%9E%90%20-%20setInterval%20-%201.resources/E96C68F3-5753-44A9-B437-5BCF49FF643C.png" height="auto" width="100%"/><br/></div><div><br/></div><div>可见，其延迟参数被初始化为 this._idleTimeout 属性，接着往下初始化，注意其关键属性的赋值：</div><div><br/></div><div><img src="timer%20%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E7%BB%86%E8%8A%82%E8%A7%A3%E6%9E%90%20-%20setInterval%20-%201.resources/3A8FB49A-D942-468C-BEB6-839258424828.png" height="auto" width="100%"/><br/></div><div><br/></div><div>timer._onTimeout 指向一个内部的wrapper函数，而，_repeat 则指向被简易包装后的用户回调函数。</div><div><br/></div><div>exports.setInterval 函数的最后，调用 active( timer ) 函数，并且返回新创建的Timeout对象。</div><div><br/></div><div>来看看 active(timer) 的逻辑：</div><div><br/></div><div><img src="timer%20%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E7%BB%86%E8%8A%82%E8%A7%A3%E6%9E%90%20-%20setInterval%20-%201.resources/60B2C775-1419-4EBC-B1C7-87DF1447ECB5.png" height="auto" width="100%"/><br/></div><div><br/></div><div>active 函数又调用了 insert 函数：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">// The underlying logic for scheduling or re-scheduling a timer.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">//</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">// Appends a timer onto the end of an existing timers list, or creates a new</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">// TimerWrap backed list if one does not already exist for the specified timeout</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">// duration.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">function insert(item, unrefed) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // msecs 即为interval间隔时间，毫秒记</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  const msecs = item._idleTimeout;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (msecs &lt; 0 || msecs === undefined) return;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // 这里调用了binding的c++实现，见下</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  item._idleStart = TimerWrap.now();</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // 真正决定采用哪个list对象：</font></div><div><br/></div><div><img src="timer%20%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E7%BB%86%E8%8A%82%E8%A7%A3%E6%9E%90%20-%20setInterval%20-%201.resources/B4020FFC-2E49-4ED6-BAF8-762C10FEFFAE.png" height="auto" width="100%"/><br/></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // 真正区别见注释，一般情况下 unrefed == false，默认使用 refedLists</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  const lists = unrefed === true ? unrefedLists : refedLists;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // 检查是不是已经存在一个了，key即位setInterval的时间</font></div><div><br/></div><div><img src="timer%20%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E7%BB%86%E8%8A%82%E8%A7%A3%E6%9E%90%20-%20setInterval%20-%201.resources/8AD5A84D-68C8-4F28-ACAA-CCEFC1864EDA.png" height="auto" width="100%"/><br/></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // Use an existing list if there is one, otherwise we need to make a new one.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  var list = lists[msecs];</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (!list) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    debug('no %d list was found in insert, creating a new one', msecs);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    // Make a new linked list of timers, and create a TimerWrap to schedule</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    // processing for the list.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    // 看看细节，注意这里的细节，有 new TimerWrap() 的逻辑，会调用至c++层面【详见下方分析】</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    // 每一个delay节点的timerslist都会又一个TimerWrap的底层对象引用</font></div><div><br/></div><div><img src="timer%20%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E7%BB%86%E8%8A%82%E8%A7%A3%E6%9E%90%20-%20setInterval%20-%201.resources/E87BB754-8EE9-4F92-AD89-39F48BBD4D1B.png" height="auto" width="100%"/><br/></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    list = new TimersList(msecs, unrefed);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    // 将其初始化为一个空的双向链表</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    L.init(list);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    // 底层的 Timer 对象持有对js层级的双向链表的引用</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    list._timer._list = list;</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    if (unrefed === true) list._timer.unref();</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    // 开始调用底层Timer实例的start方法【见下分析】</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    list._timer.start(msecs);</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    lists[msecs] = list;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    list._timer[kOnTimeout] = listOnTimeout;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  }</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  L.append(list, item);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  assert(!L.isEmpty(list)); // list is not empty</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">}</font></div><div><br/></div></div><div><br/></div><div>关于 TimerWrap.now()【静态方法】:</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  static void Now(const FunctionCallbackInfo&lt;Value&gt;&amp; args) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    Environment* env = Environment::GetCurrent(args);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>    // 通过深入调用：uv__update_time -&gt; uv__hrtime 返回绝对cpu时钟滴答数【最终返回纳秒】</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span><br/></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>    <img src="timer%20%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E7%BB%86%E8%8A%82%E8%A7%A3%E6%9E%90%20-%20setInterval%20-%201.resources/E179BAE2-133C-4E3C-B324-06046AD18A60.png" height="auto" width="100%"/><br/></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span><br/></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>    // 下方的loop-&gt;time被更新为： <font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">time     uint64_t     10207884</font></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><br/></font></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span><img src="timer%20%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E7%BB%86%E8%8A%82%E8%A7%A3%E6%9E%90%20-%20setInterval%20-%201.resources/09010155-BB51-4A1F-AD92-530BABB89564.png" height="auto" width="100%"/><br/></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    </font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    // 更新loop-&gt;time的值（毫秒）</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    uv_update_time(env-&gt;event_loop());</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><img src="timer%20%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E7%BB%86%E8%8A%82%E8%A7%A3%E6%9E%90%20-%20setInterval%20-%201.resources/68A4A5F9-3178-4B3D-BBEE-F5282D91175C.png" height="auto" width="100%"/><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    // uv_now 则返回此数值</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>    // <font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">now     uint64_t     10207884</font></span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    uint64_t now = uv_now(env-&gt;event_loop());</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>    // <font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">timer_base_     uint64_t     9722915【注意此值】</font></span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    CHECK(now &gt;= env-&gt;timer_base());</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>    // 减去timer_base【为什么呢？】</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    now -= env-&gt;timer_base();</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>    // 根据大小返回不同精读的值？</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span><span>    // <font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">now     uint64_t     484969</font></span><br/></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span><span><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>    // 最终返回读值</span><br/></font></span></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    if (now &lt;= 0xfffffff)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">      args.GetReturnValue().Set(static_cast&lt;uint32_t&gt;(now));</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    else</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">      args.GetReturnValue().Set(static_cast&lt;double&gt;(now));</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  }</font><br/></div></div><div><br/></div><div>总的来说，TimeWrap.now() 返回一个与当前loop相关“相对时间点（毫秒记）”，用来标记当前的Timeout对象的开始时间点。</div><div><br/></div><div><hr/></div><div><br/></div><div>关于new TimerWrap() 逻辑：</div><div><br/></div><div><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'Menlo';font-size:13.5pt;"><span style="color:#cc7832;font-weight:bold;">this</span>._timer = <span style="color:#cc7832;font-weight:bold;">new </span>TimerWrap()<span style="color:#cc7832;">;</span>
</pre>需要多说一句，因为此举代码会调用至底层c++：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">#0     0x000000010008dd1c in node::TimerWrap::New(v8::FunctionCallbackInfo&lt;v8::Value&gt; const&amp;) at /Users/mrguan/work/build/node/node-6.6.0/src/timer_wrap.cc:57</font></div><div><br/></div><div>...</div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"> private:</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  static void New(const FunctionCallbackInfo&lt;Value&gt;&amp; args) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    // This constructor should not be exposed to public javascript.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    // Therefore we assert that we are not trying to call this as a</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    // normal function.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>    // 调用次函数必需采用构造函数的方式</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    CHECK(args.IsConstructCall()); // line 57</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    Environment* env = Environment::GetCurrent(args);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    new TimerWrap(env, args.This());</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  }</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  TimerWrap(Environment* env, Local&lt;Object&gt; object)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">      : HandleWrap(env,</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">                   object,</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">                   reinterpret_cast&lt;uv_handle_t*&gt;(&amp;handle_),</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">                   AsyncWrap::PROVIDER_TIMERWRAP) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span>    // 这个初始化太深入了，只考虑此层级的构造逻辑</span><br/></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;"><span><span>    // uv_timer_init 具体分析见下；handle_ 是一个实例属性【新创建】</span><br/></span></font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    int r = uv_timer_init(env-&gt;event_loop(), &amp;handle_);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">    CHECK_EQ(r, 0);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">  }</font><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">...</font></div></div><div><br/></div><div><hr/></div><div><br/></div><div>关于uv_timer_init函数调用:</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">#0     0x000000010102c6dc in uv_timer_init at /Users/mrguan/work/build/node/node-6.6.0/deps/uv/src/unix/timer.c:55</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">int uv_timer_init(uv_loop_t* loop, uv_timer_t* handle) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // uv__handle_init 是一个宏，见下</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  uv__handle_init(loop, (uv_handle_t*)handle, UV_TIMER);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // 标记handle的timer_cb属性为空</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  handle-&gt;timer_cb = NULL;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  handle-&gt;repeat = 0;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  return 0;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">}</font></div><div><br/></div><div><img src="timer%20%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E7%BB%86%E8%8A%82%E8%A7%A3%E6%9E%90%20-%20setInterval%20-%201.resources/488E4B93-4894-4656-85F9-AFFBABFEE981.png" height="auto" width="100%"/><br/></div><div><br/></div><div><img src="timer%20%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E7%BB%86%E8%8A%82%E8%A7%A3%E6%9E%90%20-%20setInterval%20-%201.resources/7E303D85-060B-4C86-8BAB-D53DC6BDA0D7.png" height="auto" width="100%"/><br/></div><div><br/></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">uv_timer_s 除了普通的 UV_HANDLE_FIELDS 字段，还有自己的特殊字段，见下截图：</font></div><div><br/></div><div><img src="timer%20%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E7%BB%86%E8%8A%82%E8%A7%A3%E6%9E%90%20-%20setInterval%20-%201.resources/2A89DA05-4AB0-469E-8C99-85E18ABDCAEF.png" height="auto" width="100%"/><br/></div><div><br/></div><div><img src="timer%20%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E7%BB%86%E8%8A%82%E8%A7%A3%E6%9E%90%20-%20setInterval%20-%201.resources/23D32AC8-494A-4ECC-B82E-313F3AEC9D87.png" height="auto" width="100%"/><br/></div><div><br/></div></div><div><br/></div><div>来看 uv__handle_init 宏：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><span style="font: 18.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #d28f5a">#define uv__handle_init(loop_, h, type_)                                      \<br/>  do {                                                                        \</span></div><div><span style="font: 18.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #d28f5a"><span>    // 设置当前新创建的handle的loop属性【只读，每一个handle均有此属性】</span><br/>    (h)-&gt;loop = (loop_);                                                      \</span></div><div><span style="font: 18.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #d28f5a"><span>    // 设置handle的type</span><br/>    (h)-&gt;type = (type_);                                                      \<br/>    (h)-&gt;flags = UV__HANDLE_REF;  </span><span style="font: 18.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #4dbf56">/* Ref the loop when active. */</span><span style="font: 18.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #d28f5a">             \</span></div><div><span style="font: 18.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #d28f5a"><span>    // 将此handle插入到loop-&gt;handle_queue的队列尾部【双向链表的尾部，最老，即链表头的prev指向此节点】</span><br/>    QUEUE_INSERT_TAIL(&amp;(loop_)-&gt;handle_queue, &amp;(h)-&gt;handle_queue);            \</span></div><div><span style="font: 18.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #d28f5a"><span>    // 见下</span><br/>    uv__handle_platform_init(h);                                              \<br/>  }                                                                           \<br/>  while (</span><span style="font: 18.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #8b84cf">0</span><span style="font: 18.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #d28f5a">)</span><br/></div><div><span style="font: 18.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #d28f5a"><br/></span></div><div><span style="font: 18.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #d28f5a"><span style="font: 18.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #d28f5a">#if defined(_WIN32)<br/>
# define uv__handle_platform_init(h) ((h)-&gt;u.fd = -</span><span style="font: 18.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #8b84cf">1</span><span style="font: 18.0px Menlo; font-variant-ligatures: no-common-ligatures; color: #d28f5a">)<br/>
#else<br/>
# define uv__handle_platform_init(h) ((h)-&gt;next_closing = NULL)<br/>
#endif</span><br/></span></div></div><div><br/></div><div>因此，new TimerWrap() 的逻辑，是新创建了一个Timer的底层对象，这个对象在构造的时候，创建了新的timer handle，并且将此handle插入至loop的handle_queue双向链表中的最末尾的位置去。底层逻辑，参见：</div><div/><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">#0     0x000000010008e1fe in node::TimerWrap::TimerWrap(node::Environment*, v8::Local&lt;v8::Object&gt;) at /Users/mrguan/work/build/node/node-6.6.0/src/timer_wrap.cc:69</font></div></div><div/><div><br/></div><div>透过底层timer_wrap的binding实现，可知：</div><div><br/></div><div><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'Menlo';font-size:13.5pt;"><span style="color:#cc7832;font-weight:bold;">const </span>TimerWrap = process.binding(<span style="color:#6a8759;">'timer_wrap'</span>).Timer<span style="color:#cc7832;">;</span>
</pre><div>的返回值应该是一个由c++层次来实现的构造函数：<br/></div></div><div><br/></div><div><img src="timer%20%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E7%BB%86%E8%8A%82%E8%A7%A3%E6%9E%90%20-%20setInterval%20-%201.resources/BF562456-72B1-4DA3-B185-682C9D9698EB.png" height="auto" width="100%"/><br/></div><div><br/></div><div>且，其暴露出来的构造函数的名称为：Timer，且为其设置了now这个静态方法，和一系列的原型方法！在创建一个新的TimerLists对象的时候，此对象实例会保有一个this._timer = new TimerWrap() 引用，也就是底层的Timer构造出的对象的引用！在Timer被初始化成功以后，会有新的timer handle被创建，并且被插入至loop-&gt;handle_queue双向链表队列中去。</div><div><br/></div><div><hr/></div><div><br/></div><div>关于list._timer.start(msecs)底层调用：</div><div><br/></div><div/><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><font style="font-size: 12px; color: rgb(51, 51, 51);">#0     0x000000010008e043 in node::TimerWrap::Start(v8::FunctionCallbackInfo&lt;v8::Value&gt; const&amp;) at /Users/mrguan/work/build/node/node-6.6.0/src/timer_wrap.cc:77</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  static void Start(const FunctionCallbackInfo&lt;Value&gt;&amp; args) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    // 此函数是在js层级被调用，此句的含义，是把js层级的实例对象，转化为c++层级的实例对象</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    TimerWrap* wrap = Unwrap&lt;TimerWrap&gt;(args.Holder());</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    CHECK(HandleWrap::IsAlive(wrap));</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    // 获取第一个参数 timeout     int64_t     2000</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    int64_t timeout = args[0]-&gt;IntegerValue();</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    // 最终调用此处的重要函数</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    int err = uv_timer_start(&amp;wrap-&gt;handle_, OnTimeout, timeout, 0);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    args.GetReturnValue().Set(err);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  }</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">==</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">#0     0x000000010102c788 in uv_timer_start at /Users/mrguan/work/build/node/node-6.6.0/deps/uv/src/unix/timer.c:68</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">int uv_timer_start(uv_timer_t* handle,</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">                   uv_timer_cb cb,</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">                   uint64_t timeout,</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">                   uint64_t repeat) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  uint64_t clamped_timeout;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // cb     uv_timer_cb     (node`node::TimerWrap::OnTimeout(uv_timer_s*) at timer_wrap.cc:90)     0x000000010008e360</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (cb == NULL)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    return -EINVAL;</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (uv__is_active(handle))</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    uv_timer_stop(handle);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // timeout     uint64_t     2000</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // clamped_timeout     uint64_t     13563712</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // 计算“到期”时间</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  clamped_timeout = handle-&gt;loop-&gt;time + timeout;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (clamped_timeout &lt; timeout)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    clamped_timeout = (uint64_t) -1;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // 设置此handle的timer_cb函数指针</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  handle-&gt;timer_cb = cb;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // 设置此handle的到期时间</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  handle-&gt;timeout = clamped_timeout;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // repeat     uint64_t     0</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  handle-&gt;repeat = repeat;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  /* start_id is the second index to be compared in uv__timer_cmp() */</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // 设置 start_id</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  handle-&gt;start_id = handle-&gt;loop-&gt;timer_counter++;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // 重中之重的函数，这里设计两个类型转化：</font></div><div><br/></div><div><img src="timer%20%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E7%BB%86%E8%8A%82%E8%A7%A3%E6%9E%90%20-%20setInterval%20-%201.resources/6B09365E-562E-4398-9304-2C11EB1DC65E.png" height="auto" width="100%"/><br/></div><div><br/></div><div><img src="timer%20%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E7%BB%86%E8%8A%82%E8%A7%A3%E6%9E%90%20-%20setInterval%20-%201.resources/D3D6375F-5DAA-4627-BD3E-42E01F3F606B.png" height="auto" width="100%"/><br/></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // 第三个参数是一个比较函数指针</font></div><div><br/></div><div><img src="timer%20%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E7%BB%86%E8%8A%82%E8%A7%A3%E6%9E%90%20-%20setInterval%20-%201.resources/372DA9E4-A735-49E1-BC23-0C17C78B4B0D.png" height="auto" width="100%"/><br/></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // 即一个loop会持有一个timer_heap的最小二叉树【完全二叉树】</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  heap_insert((struct heap*) &amp;handle-&gt;loop-&gt;timer_heap,</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">              // 当前的handle节点</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">              (struct heap_node*) &amp;handle-&gt;heap_node,</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">              timer_less_than);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  uv__handle_start(handle);</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  return 0;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">}</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">==</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">进入heap_insert来看看：</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">#0     0x000000010102ca54 in heap_insert at /Users/mrguan/work/build/node/node-6.6.0/deps/uv/src/heap-inl.h:115</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">HEAP_EXPORT(void heap_insert(struct heap* heap,</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">                             struct heap_node* newnode,</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">                             heap_compare_fn less_than)) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // 当第一次进入的时候（第一次调用setInterval函数）</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // heap     heap *     0x101b0c1f8     0x0000000101b0c1f8</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  //     min     heap_node *     NULL     0x0000000000000000</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  //     nelts     unsigned int     0【除去根之外的节点数】</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  struct heap_node** parent;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  struct heap_node** child;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  unsigned int path;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  unsigned int n;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  unsigned int k;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // 首先置空新节点的各种指针</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  newnode-&gt;left = NULL;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  newnode-&gt;right = NULL;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  newnode-&gt;parent = NULL;</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  /* Calculate the path from the root to the insertion point.（计算从插入点到跟节点的距离）  This is a min</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">   * heap so we always insert at the left-most free node of the bottom row.【往最底部最左边插入新节点】</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">   */</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  path = 0;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // 默认刚开始，heap-&gt;nelts肯定为0</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  for (k = 0, n = 1 + heap-&gt;nelts; n &gt;= 2; k += 1, n /= 2)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    path = (path &lt;&lt; 1) | (n &amp; 1);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // path     unsigned int     0</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  /* Now traverse the heap using the path we calculated in the previous step. */</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  parent = child = &amp;heap-&gt;min;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  while (k &gt; 0) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    parent = child;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    if (path &amp; 1)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      child = &amp;(*child)-&gt;right;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    else</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">      child = &amp;(*child)-&gt;left;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    path &gt;&gt;= 1;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    k -= 1;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  }</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // 插入新节点</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  /* Insert the new node. */</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // 设置新节点的parent</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  newnode-&gt;parent = *parent;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // 第一次调用之时，指的是 loop-&gt;timer_heap-&gt;min 指向新节点</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  *child = newnode;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // 可见nelts记录的是二叉树的节点总数</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  heap-&gt;nelts += 1;</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  /* Walk up the tree and check at each node if the heap property holds.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">   * It's a min heap so parent &lt; child must be true.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">   */</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // 第一次执行setInterval时，此分支不会执行</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  while (newnode-&gt;parent != NULL &amp;&amp; less_than(newnode, newnode-&gt;parent))</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    heap_node_swap(heap, newnode-&gt;parent, newnode);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">}</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">==</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">🌟 第一次执行 setInterval 时，只会在最小完全二叉堆中，插入一个节点，查看此时变量截图：</font></div><div><br/></div><div><img src="timer%20%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E7%BB%86%E8%8A%82%E8%A7%A3%E6%9E%90%20-%20setInterval%20-%201.resources/F0581B47-EBD6-46CF-A702-0439E5A7449B.png" height="auto" width="100%"/><br/></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">可见，heap-&gt;min 就是（指向） newnode 节点</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">==</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">🌟 进入宏：uv__handle_start(handle)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">#define uv__handle_start(h)                                                   \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  do {                                                                        \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    assert(((h)-&gt;flags &amp; UV__HANDLE_CLOSING) == 0);                           \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    // 标记其激活状态</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    if (((h)-&gt;flags &amp; UV__HANDLE_ACTIVE) != 0) break;                         \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    (h)-&gt;flags |= UV__HANDLE_ACTIVE;                                          \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    // 此分支的确会进入【注意此节的上方有相关逻辑】</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    if (((h)-&gt;flags &amp; UV__HANDLE_REF) != 0) uv__active_handle_add(h);         \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  }                                                                           \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  while (0)</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">#define uv__active_handle_add(h)                                              \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  do {                                                                        \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    // timer handle会使得这里加1</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    (h)-&gt;loop-&gt;active_handles++;                                              \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  }                                                                           \</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  while (0)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">==</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">🌟第二个setInterval调用，进入heap_insert之后的变量截图，从中可以看出结构：</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">#0     0x000000010102cba9 in heap_insert at /Users/mrguan/work/build/node/node-6.6.0/deps/uv/src/heap-inl.h:148</font></div><div><br/></div><div><img src="timer%20%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E7%BB%86%E8%8A%82%E8%A7%A3%E6%9E%90%20-%20setInterval%20-%201.resources/934E6D74-3724-4D48-8672-5BBB12A6BD8E.png" height="auto" width="100%"/><br/></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">可见，原来的根节点heap-&gt;min的left上面插入了一个新的叶子节点，此叶子节点的parent即为heap-min节点；</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">==</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">🌟同样，在第二次插入完毕之后，会有比较父子节点的权重大小的逻辑，以保证此树始终为最小完全二叉堆结构：</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  /* Walk up the tree and check at each node if the heap property holds.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">   * It's a min heap so parent &lt; child must be true.</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">   */</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  while (newnode-&gt;parent != NULL &amp;&amp; less_than(newnode, newnode-&gt;parent))</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    heap_node_swap(heap, newnode-&gt;parent, newnode);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">==</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">🌟 来看看父子节点比较函数：</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">static int timer_less_than(const struct heap_node* ha,</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">                           const struct heap_node* hb) {</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  const uv_timer_t* a;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  const uv_timer_t* b;</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  a = container_of(ha, const uv_timer_t, heap_node);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  b = container_of(hb, const uv_timer_t, heap_node);</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  // 谁的触发事件越“早”，谁的位置越靠近根节点</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (a-&gt;timeout &lt; b-&gt;timeout)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    return 1;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (b-&gt;timeout &lt; a-&gt;timeout)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    return 0;</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  /* Compare start_id when both have the same timeout. start_id is</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">   * allocated with loop-&gt;timer_counter in uv_timer_start().</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">   */</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (a-&gt;start_id &lt; b-&gt;start_id)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    return 1;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  if (b-&gt;start_id &lt; a-&gt;start_id)</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">    return 0;</font></div><div><br/></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">  return 0;</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">}</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">==</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">🌟父子节点换位的算法不再深究</font></div><div><font style="font-size: 12px; color: rgb(51, 51, 51);">==</font></div><div><br/></div></div><div><br/></div><div><hr/><br/></div><div>【附录及资料】</div><div><br/></div><div>有关“最小完全二叉堆结构”详细说明：</div><div><br/></div><div><a href="https://en.wikipedia.org/wiki/Binary_heap">https://en.wikipedia.org/wiki/Binary_heap</a><br/></div><div><br/></div><div><a href="http://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91">http://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91</a><br/></div><div><br/></div><div><br/></div><div><img src="timer%20%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E7%BB%86%E8%8A%82%E8%A7%A3%E6%9E%90%20-%20setInterval%20-%201.resources/48F6D219-654C-43FA-B623-EA989883372B.png" height="auto" width="100%"/>  </div><div><img src="timer%20%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E7%BB%86%E8%8A%82%E8%A7%A3%E6%9E%90%20-%20setInterval%20-%201.resources/9AF0A140-AA08-468C-8ADD-FD8367783C1E.png" height="auto" width="100%"/><br/></div><div><br/></div><div>而loop-&gt;timer_heap的数据结构为右图。</div><div><br/></div><div>关于完全二叉树：</div><div><br/></div><div><img src="timer%20%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E7%BB%86%E8%8A%82%E8%A7%A3%E6%9E%90%20-%20setInterval%20-%201.resources/C2924C77-422F-497E-88EB-9EDBB904FB9D.png" height="auto" width="100%"/><br/></div><div><br/></div>

<hr class="tail-hr">
<div class="tail-licenses">
<p>版权声明：自由转载-非商用-非衍生-保持署名(<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">创意共享3.0许可证</a>)</p>
<p>文章作者：Pooky (<a href="mailto:guananddu@icloud.com">guananddu@icloud.com</a>)</p>
<p>更新日期：Sat Dec 24 2016 19:20:16 GMT+0800 (CST)</p>
</div></body></html>