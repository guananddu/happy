// 函数 f1 的定义
function f1() {
    var num = 0;

    function f2() {
        num++;
        console.log( num );
    }
    return f2;
}

// 诀窍：一步一步理解，步步为营：

// 一：★ 写在调用 f1 之前：
// f1 函数被定义，先不要关心内部 f2 函数的具体定义，你首先可以确定的是：
// > f1 里面有两个局部变量：num 和 f2（函数 f1 中再定义一个函数 f2，内部函数 f2 就是局部变量）
// > 变量 num 是一个数字 0；而变量 f2 是一个函数；（因为 js 中变量可以为任意类型）
// 
// 再观察 return 语句，f1 函数把 f2 这个变量给“返回”了：
// 只有 return f2 这个语句存在，下面的 result 变量才能“被”赋予 f2 的值
// 说白了，return 语句定义了当前函数 f1 在被调用的时候，最终计算出的一个值（可以是任意类型）
// 这个值如果有用，你可以用另一个变量如 "result" 来“接住”此值；如果没用，你也可以置之不理。
// 例如你可以直接写：f1() 来调用 f1 这个函数，但是这样写就拿不到 f2 这个被返回的值了。
// 
// 再说的直白一些："f1()" 这个东西（你甚至可以理解为一个普通语句），可以被最终“计算”出来
// 而且 "f1()" 计算完后有一个值，这个值 由此函数 f1 内部的 return 语句来定义；而且这个值可以被“接住”。

// 二：★ 当 f1 被调用：
// 调用函数 f1 之后，f1 把其内部的 f2 作为返回值赋予了变量 result；
// 故 result 就指向了 f2 函数（可以理解为 result 就是 f2 函数）
// 所以 result 就能被调用（其实就是调用了 f2 函数）
// 
// f1 在被调用“期间”，注意是“期间”，有一个“上下文”（函数运行期间（也就是被调用时）才有上下文的概念）
// 为什么说是“上下文”，这是一个比喻，例如英文单词要放到段落中才知道表达的是什么意思，就是这个概念。
// 为什么会有“上下文”，就是为了让 javascript 引擎知道变量 num 在哪里定义，变量 f2 在哪里定义，从而让代码顺利运行。
// 
// 我们姑且称这个 f1 函数的上下文为 FO1，现在你只需要知道这个 FO1 中分为两层楼：
// 
// 第一层楼：我们称之为：FO1.level1，它指向一个键值对对象（还记得什么是键值对吗？key:value的列表）
// 这个列表中记录了 f1 的局部变量定义：{ num : 0, f2 : function(){...}, arguments: xxx }
// （★注意最后一个  arguments 变量，所有函数在调用时，都会自动（注意是“自动”）加上这个局部变量，它记录了函数的传参和其他信息★）
// （★arguments 变量是一个局部变量，只记录当前正在调用的函数传参信息，只需要知道即可★）
// （★arguments 单词翻译过来就是参数的意思，真的可以把它就当做一个普通的函数局部变量，不要想多★）
// 我们称 FO1.level1 为“局部变量列表”，或者“函数局部作用域”
// 
// 第二层楼：我们称之为：FO1.level2，它也指向一个键值对对象，但是这个对象就很大了，它的值：
// { window: window, Math: xxx, Date: xxx, Array: xxx, ... }
// 我们称它为“全局对象列表”，或者“全局作用域”
// 
// 为什么会有 FO1 这个上下文呢？很简单，当 f1 执行时（被调用时）：
// 如果遇到 "num" 这个字母，要去 FO1 中“寻找”这个 "num" 字母
// 
// f1 会从第一层楼 FO1.level1 开始找，也就是局部变量列表（函数局部作用域）
// yes! num 就在 FO1.level1 中，找到即可，找到就不会再去二楼找了。
// 
// 那比方说，现在要找一个叫 "fake_num" 的变量，从一楼到二楼都找不到，那就是未定义的变量，就会语法报错！
// 那比方说，在函数中用到了：Date 这个东西，它会从一楼找到二楼，直到从二楼（全局作用域）中找到它！
// 
// 剩下最后：f1 被调用的时候，内部的 f2 刚刚被定义！先不考虑 f2 定义之处是什么样子的。
var result = f1();

// 三：★ 当 result( 即 f2 函数 )被调用的时候，注意是“调用期间”，同理，也会有一个 f2 的“上下文”
// 
// 我们姑且称之为：FO2，但是由于 f2 是在 f1 内部，所以呢，这个 FO2 分为三层！
// 
// 第一层：FO2.level1 是“函数局部作用域”，但是由于 f2 内部并没有使用 var 声明的变量
// 所以第一层中，并没有人为定义的局部变量：{ arguments: xxx }，只有一个 arguments 变量。
// 
// 第二层：FO2.level2 是 f2 函数的上一级作用域，f2 的上一级作用域就是 f1 的：FO1.level1 
// 即 f1 的“局部作用域”：{ num : 0, f2 : function(){...}, arguments: xxx }
// 需要注意的就是，num 在这个地方被记录！！！
// 
// 第三层：FO2.level3 仍旧是“全局作用域”对象，同 FO1.level2 不再赘述。
// 
// 那么在 result(即f2) 第一次调用时，在它的函数体中发现有 "num" 这个字母，则它开始从自己的 FO2
// 中寻找 "num" 的含义，先找第一层 FO2.level1 ：{ arguments: xxx } 明显没找到！
// 
// 再找第二层 FO2.level2 ：{ num : 0, f2 : function(){...}, arguments: xxx } 找到了！
// 当然找到以后就不再找第三层了。于是开始执行：num ++
// 而 num ++ 会把 FO2.level2 中的 num:0 进行自加 1 的操作，于是 num 变为 1：
// FO2.level2 : { num : 1, f2 : function(){...}, arguments: xxx }
// 最后使用 console.log( num ) 输出 num，也就是 1
result();

// 四：★ 当 result ( 即 f2 函数 )第二次被调用的时候，仍旧会重复一边刚才的流程，你自然就会理解：
// num ++ 把 FO2.level2 变成了：
// { num : 2, f2 : function(){...}, arguments: xxx }
// 所以会输出 2 ！
result();

// 简单总结：
// 前提：函数中的变量声明必须用 var 来声明才是此函数内局部变量
// 闭包：内部函数总能访问到外部函数中声明的局部变量
// 过程：f2 函数在寻找 num 时，会从自身的局部环境一层一层往外找，直至找到（因为 num 被定义在 f1 的局部环境中），并且可以修改。
